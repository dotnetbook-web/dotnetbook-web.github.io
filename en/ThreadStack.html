<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Platform Architecture</title>
</head>
<body>
    <script src="../res/jquery.js"></script>
    <link rel="stylesheet" href="../res/bootstrap.css">
    <link rel="stylesheet" href="../res/awesome.css">
    <style>

body {
    font-family: PF Regal,Georgia,serif;
    font-size: 16pt;
    font-weight: 300;
    padding-top: 4em;
    background-color: #fdfdfd;
}

.book-title-container {
    width: 100%;
    text-align: center;
    margin: 73px 0 110px 0;
}

.book-title {
    font-size: 57pt;
    margin: 50px 0 70px 0;
    user-select: none;
}
.book-part-title-block {
    display: inline-block;
}
.book-part-title {
    font-size: 21pt;
    color: #656ab6;
    margin: 0 7px;
}

.book-part-title:hover {
    box-shadow: inset 0 -1px #007bff;
    text-decoration: none;
}

.book-superheading-title {
    font-size: 15pt;
    margin: 0 7px;
    color: #656ab6;
}

.article-container
{
    width: 62%;
}

strong {
    font-weight: 500;
}

p, li {
    margin: 0 0 1em;
    line-height: 1.5em;
    font-family: inherit;
}

ol, li {
    margin-top: 1em;
    margin-bottom: 1em;
}

ol {
    padding-left: 1.21em;
}

ul  {
    padding-left: 1em;
}

ol li, ul li {
    padding-left: 0.5em;	
    font-family: inherit;
    text-align: justify;
}

.image-container {
    margin-top: 2em;
    margin-bottom: 1.0em;
    text-align: center;
}

.image-container p {
    margin: 0;
}

.image-container img {
    width: fit-content;
    max-width: 100%;
    max-height: 21em;
    object-fit: contain;
}

.table-container {
    display: block;
    margin-top: 2.1em;
    width: 100%;
}

p.description {
    font-size: 0.8em;
    font-style: italic;
    text-align: center;
    margin-top: 0.5em;
}

.table-width-6 
{
    margin-left: 25%;
    margin-right: 25%;
}

.table-width-8 
{
    margin-left: 12.5%;
    margin-right: 12.5%;
}

.table-width-10 
{
    margin-left: 6.25%;
    margin-right: 6.25%;
}

.table-width-12 
{
    margin-left: 0;
    margin-right: 0;
}

table {
    width: 100%;
}

thead {
    background-color: aliceblue;
}

table th {
    font-weight: 400;
}

table td, table th {
    padding: 7px;
    border-top: solid darkgrey 1px;
    border-bottom: solid darkgrey 1px;
    border-right: dotted darkgray 1px;
    border-left: dotted darkgray 1px;
    font-size: smaller;
}

code, *[class*='lang-'] span, *[class*='lang-'] pre {
    font-family: JB Mono, monospace !important;
}

*[class*='lang-'] {
    padding: 0px 0px 25px 0px;
    font-size: 0.75em;
}


*[class*='lang-'] > div, pre > code {
    border-left-color: #eee;
    border-left-style: dotted;
    border-left-width: 3px;
    padding-left: 25px;
    display: block;
    padding-top: 20px;
    padding-bottom: 20px;
}

*[class*='lang-'] > div pre, pre > code pre {
    margin-bottom: 0;
}

p code:not(.highlight), li code:not(.highlight) {
    font-size: 0.7em;
    color: darkslateblue;
}

/* style for manual selecting */
.box {
    padding: 3px;
    border: gainsboro;
    border-width: 1px;
    border-style: solid;
}

code.highlight {
    font-family: inherit !important;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
}

p code.highlight, li code.highlight {
    padding: 4px;
    background-color: #ffffa1;
}

.wide {
    width:140%;
}

p a, li a {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #b88b59;
}

p a:hover, li a:hover {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #0056b3;
}

blockquote h5 {
    background-color: aquamarine;
    margin: 16px 0 16px -20px;
    padding: 15px 30px 15px;
}

p img {
    width: 95%;
}

blockquote 
{
    padding-left: 0.4em;
    border-left: 0.5em solid rgba(0,0,0,.08);
    font-style: italic;
}

blockquote.big-quote, 
blockquote.breadcrumbs 
{
    background-color: transparent;
    padding: 0;
    border-left: none;
    font-style: normal;
}

blockquote.breadcrumbs, blockquote.breadcrumbs  p
{
    margin: 0;
    padding: 0;
}

blockquote p {
    padding: 1em 1em 1em 0.6em;
    font-family: inherit;
}

blockquote p code {
    font-family: consolas, monospace;
    font-size: 17px;
    padding: 4px 6px;
}

blockquote p em {
    font-weight: 400;
}

blockquote.big-quote > p {
    margin: 0.7em 0 0.7em 0;
    font-family: Charter;
    font-size: 2.5em;
    padding: 0;
    width: 130%;
    line-height: 1em;
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
    padding: 0;
    font-weight: 400;
    font-family: inherit;
    hyphens: none;
}

h1 {
    font-size: 2.2em;
    font-family: Charter,Georgia,serif;
    font-weight: 300;
    margin: 1.8em 0 1.8em 0;
    text-align: center;
    width: 140%;
}

h2 {
    padding-top: 1em;
    padding-left: 1.5em;
    padding-right: 1.5em;
    margin-bottom: 0.5em;
    font-family: Charter, Arial, Helvetica Neue, sans-serif;
    font-size: 1.4em;
    text-align: center;
}

h3 {
    padding-top: 1em;
    font-family: Charter, Arial, Helvetica Neue, sans-serif;
    font-size: 1.15em;
    width: 70%;
}

h4 {
    padding: 1em 0 0 0;
    font-size: 1em;
    font-weight: 300;
    font-style: italic;
}

h5 {
    padding: 0.6em 0 0 0;
    font-weight: 300;
    font-size: 1.1em;
}

/* Sidenotes */

.aside-container {
    position: relative;
}
.aside-container p {
    position: relative;
    top: 9px;
}

.aside-container > .aside-side-container {
    display: block;
    position: absolute;
    top: 12px;
    left: 96%;
    width: 34%;
    font-size: 12pt;
    line-height: 20px;
    margin-left: 100px;
    z-index: 1000;
}

.aside-container > .aside-side-container p {
    line-height: 24px;
    font-size: 13pt;
    margin: 0 0 13px 0;
}

.side-regular-block p {
    top: 0;
}

/* Music side player */
.aside-side-container .music-player {
    width: 100%;
    height: 400px;
}

/* media block after h1 */
.aside-container h1 + .aside-side-container.side-media-block h2 {
    margin: 5em 0 1em 0;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-weight: 600;
}

.aside-side-container > li {
    display: block;
    font-family: Charter;
}

.aside-side-container > li ul, .aside-side-container > li ol {
    padding-left: 30px;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.aside-side-container > li li {
    padding-left: 6px;
    margin: 0 0 6px;
    line-height: 22px;

    font-family: Charter;
}

.aside-side-container p {
    line-height: 25px;
    font-size: 13pt;
    margin: 0 0 15px 0;
}

.aside-side-container blockquote {
    border: aliceblue;
    border-left-style: solid;
}

li blockquote {
    margin-left: 1.5em;
}

/* Paragraphs numbering */
.paragraph-container {
    position: relative;
}

.paragraph-container p, .aside-container > p {
    text-align: justify;
}

.paragraph-container > .paragraph-left-side, .paragraph-container > .paragraph-right-side  {
    font-family: JB Mono, consolas;
    display: block;
    position: absolute;
    top: 17px;
    font-size: 10pt;
    line-height: 20px;
    color: #86abc473;
    z-index: 1000;
}
.paragraph-container > .paragraph-left-side {
    display: none;
    left: -2.1cm;
    width: 35px;
    user-select: none;
}

.paragraph-container > .paragraph-right-side  {
    display: none;
    left: 100%;
    width: 35px;
    padding-left: 45px;
    user-select: none;
}

.article-container
{
    width: 70%;
}

/* X_MENU */
.menu-title {
    text-align: center;
    margin: 35px 50px 35px 50px;
    font-size: 24pt;
    font-family: Charter;
}

.menu-container ol {
    margin: 0;
    padding: 0;
}

.menu-container ol li {
    margin: 0;
    padding: 0;
}

.header {
    height: 2.5em;
    background-color: white;
    position: relative;
    z-index: 1500;
    width: 100%;
    display: flex;
    justify-content: space-between;
    transition: all 1s;
    top: 0;
    box-shadow: 1px -4px 20px rgba(0, 0, 0, .1);
}

.fixed {
    position: fixed !important;
}

.header > .menu {
    pointer-events: auto;
    float: right;
    height: 40px;
    font-family: Charter, 'Helvetica Neue', Arial, sans-serif;
    font-size: 1em;
    color: #fff;
    margin-top:40px;
    margin-right:40px;
}

.menu a {
    color: #fff;
}
.menu a:hover {
    text-decoration: none;
    color: #fff;
}

#menu__toggle {
    opacity: 0;
}

#menu__toggle:checked ~ .menu__btn > span {
    transform: rotate(45deg);
}
#menu__toggle:checked ~ .menu__btn > span::before {
    top: 0;
    transform: rotate(0);
    background-color: black
}
#menu__toggle:checked ~ .menu__btn > span::after {
    top: 0;
    transform: rotate(90deg);
    background-color: black
}
#menu__toggle:checked ~ .menu__box {
    visibility: visible;
    right: 0;
}

.menu__btn {
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    right: 0;
    width: 2.5em;
    height: 2.5em;
    cursor: pointer;
    z-index: 1;
    margin: 0;
    padding: 0.7em;
}

.menu__btn > span,
.menu__btn > span::before,
.menu__btn > span::after {
    display: block;
    position: absolute;

    width: 1.1em;
    height: 1px;

    border-bottom: 1px black solid;

    transition-duration: .25s;
}
.menu__btn > span::before {
    content: '';
    top: -7px;
}
.menu__btn > span::after {
    content: '';
    top: 7px;
}

.menu__box {
    display: block;
    position: fixed;
    visibility: hidden;
    top: 0;
    right: -100%;

    width: 100%;
    height: 100%;

    margin: 0;
    padding: 80px 0;

    list-style: none;

    background-color: white;
    box-shadow: 1px 0px 6px rgba(0, 0, 0, .2);

    transition-duration: .25s;

    overflow-y: auto;
}
.menu__box li a:hover {
    text-decoration: none;
    color: inherit;
}
.menu__list {
    font-size: 0.9em;
    margin: 0 2em 0 2em;
}
.menu__list li {
    text-align: left;
}

/* X_HEADER */

.conflogo {
    margin: 0.5em 0 0 0.8em;
    font-size: 1.1em;
    font-family: Charter;
    user-select: none;
}

.invisible {
    display: none;
}

.header > .menu > div {
    display: inline;
    margin-left: 10px;
    margin-right: 10px;
}

.menu__header_current
{
    text-align: center;
    font-size: 2em;
    margin: 0 0 1em 0;
}

.menu__header_total
{
    text-align: center;
    font-size: 2.4em;
    margin: 1.7em 0 0.3em 0;
}
.menu__header_list 
{
    padding: 0;
    margin-top: 0;
    margin-left: 0;
    margin-right: 0;
}
.menu__header_list > li 
{
    display: inline-block;
    width: 100%;
    margin: 0;
    text-align: center;
    font-family: charter;
}
.menu__header_total_sub
{
    font-size: 1.4em;
    margin: 2em 0 1em 0;
}
.menu__header_total_sub2
{
    font-size: 1.1em;
    margin: 1.5em 0 0.6em 1em;
    text-align: left;
}
/* X_FOOTER */

footer {
    margin-top: 2em;
    background-color: black;
    height: 4em;
    margin-left: -4cm;
    margin-right: -4cm;
    padding-left: 4cm;
    padding-right: 4cm;
}

footer > div {
    box-shadow: 0px 2px 2px rgb(0, 0, 0);
}

.footer-container {
    height: 100%;
}

.footer-wrap {
    color: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 25px 0;
}

.footer-wrap p {
    margin: 0;
    padding: 0px;
    line-height: 1em;
}

.footer-container img {
    height: 1.6em;
    margin-top: auto;
    margin-bottom: auto;
}

.footer-link {
    color: white;
    margin: 0 7px;
    font-size: 1em;
    box-shadow: none;
}

.footer-link:hover {
    color: salmon;
    box-shadow: none;
}

/* MEDIA */
/* XXL */
@media (min-width: 1601px) {
    .book-container
    {
        max-width: 1200px;
        margin-left: auto;
        margin-right: auto;
    }
}

/* XL */
@media (max-width: 1600px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }
}

/* LG */
@media (max-width: 1400px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }

    blockquote.big-quote > p {
        font-size: 2em;
    }
    
    .table-width-6 
    {
        margin-left: 20%;
        margin-right: 20%;
    }

    .table-width-8 
    {
        margin-left: 10%;
        margin-right: 10%;
    }

    .table-width-10 
    {
        margin-left: 5%;
        margin-right: 5%;
    }
}

/* > MD */
@media (min-width: 992px) {
    .hamburger-menu {
        display: none;
    }
}

/* MD */
@media (max-width: 991px) {
    
    h3 {
        width:80%;
    }

    .book-container
    {
        margin-left: 3cm;
        margin-right: 3cm;
    }
    
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    .book-title {
        font-size: 50pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 15pt;
    }                                     

    .article-container, h1 {
        width: 100%;
    }

    .aside-container p {
        top: 0;
    }

    .aside-container h1 + .aside-side-container.side-media-block h2 {
        display: none;
    }

    .wide {
        width: 100%;     
    }

    .side-regular-block {
        margin: 40px 10px;
        padding-left: 100px;
    }
    .aside-side-container .music-player {
        width: 100%;
        height: 100px;
    }
    .aside-side-container.side-media-block {
        padding: 17px 0;
    }
    .aside-side-container.side-media-block h2 {
        margin-top: 20px;
        font-size: 13pt;
        border: none;
    }

    .aside-container > .aside-side-container
    {
        position: relative;
        top: auto;
        left: auto;
        width: auto;
        height: auto;
        margin: 0;
        padding: 17px;
    }

    blockquote.big-quote > p {
        width: 100%;
        font-size: 2em;
    }

    .paragraph-container .paragraph-left-side {
        left: -55px;
    }

    body {
        font-size: 15pt;
    }

    p code:not(.highlight), li code:not(.highlight) {
        font-size: 11pt;
    }

    p, li {
        line-height: 30px;
    }
    
    li {
        margin: 0 0 10px 0;
    }

    .table-width-6 
    {
        margin-left: 25%;
        margin-right: 25%;
    }

    .table-width-8 
    {
        margin-left: 12.5%;
        margin-right: 12.5%;
    }

    .table-width-10 
    {
        margin-left: 6.25%;
        margin-right: 6.25%;
    }

    .side-regular-block {
        border-radius: 5px;
        background-image: linear-gradient(180deg,hsla(0,0%,100%,0) 60%,#fff),linear-gradient(70deg,#dbedff 32%,#ebfff0);
        padding: 22px;
    }    

    .menu__list
    {
        margin-top: 0;
        margin-bottom: 0;
    }

    .menu__list, .menu__header_total_sub2
    {
        margin-left: auto;
        margin-right: auto;
        max-width: 800px;
        width: 80%;
    }

    .book-container 
    {
        position: absolute;
        padding: 0 3cm 0 3cm;
        overflow: scroll;
        overflow-x: auto;
        top: 2.5em;
        bottom: 0;
        width: 100%;
        margin: 0;
    }

    footer {
        margin-top: 2em;
        background-color: black;
        height: 4em;
    }

    footer > div {
        position: relative;
        margin: 0 -3cm;
        background: black;
        padding: 0 3cm;
    }
}

/* Smartphone horizontal - SM */
@media (max-width: 767px) {
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    h1 {
        margin: 1.8em 0em 1.8em 0.3em;
    }

    .book-title {
        font-size: 40pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 17pt;
    }

    .book-container {
        padding: 0 2.5cm;
    }
    ul {
        margin-left: 30px;
        margin-right: 30px;
        padding-left: 25px;
    }
    
    .table-width-6 
    {
        margin-left: 20%;
        margin-right: 20%;
    }

    .table-width-8 
    {
        margin-left: 10%;
        margin-right: 10%;
    }

    .table-width-10 
    {
        margin-left: 0%;
        margin-right: 0%;
    }
    
    .paragraph-container > .paragraph-left-side {
	    display: block;
        top: 14px;
        font-size: 9pt;
    }
    .paragraph-container > .paragraph-right-side {
    	display: block;
        padding-left: 40px;
        top: 14px;
        font-size: 9pt;
    }
    .footer-container img {
        height: 1.3em;
    } 
}

@media (max-width: 630px) {
    .book-container {
        padding: 0 1.5cm;
    }
    .paragraph-container > .paragraph-left-side {
        left: -33px;
    }
    .paragraph-container > .paragraph-right-side {
        padding-left: 24px;
    }
}
/* Smartphone - XS */
@media (max-width: 575px) {
    .book-container {
        padding: 0 50px 0 30px;
    }
    ul {
        margin: 0;
        padding-left: 20px;
    }

    body {
        font-size: 13pt;
    }

    p code:not(.highlight), li code:not(.highlight) 
    {
        font-size: 10pt;
        padding: 3px;
    }

    *[class*='lang-'] > div, pre > code {
        padding-left: 15px;
        padding-top: 15px;
        padding-bottom: 15px;
    }
    
    ol li, ul li {
        padding-left: 0.2em;	
    }
    
    p, li {
        line-height: 24px;
    }    

    .table-width-6 
    {
        margin-left: 0;
        margin-right: 0;
    }

    .table-width-8 
    {
        margin-left: 0%;
        margin-right: 0%;
    }

    .table-width-10 
    {
        margin-left: 0%;
        margin-right: 0%;
    }
    
    .paragraph-container .paragraph-left-side 
    {
        display: none;        
    }
    .paragraph-container .paragraph-right-side 
    {
        padding-left: 21px;
        top: 3px;
	    font-size: 8pt;
    }
    .footer-container img {
        height: 1em;
    } 
    .menu__list {
        margin: 0 1em 0 1em;
    }
    .menu__header_total_sub2
    {
        margin: 1.5em 0 0.6em 1em;
    }
}

/* Fonts */

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-Bold.eot');
    src: local('../res/fonts/PFRegalTextPro-Bold'),
        url('../res/fonts/PFRegalTextPro-Bold.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-Bold.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-Medium.eot');
    src: local('../res/fonts/PFRegalTextPro-Medium'),
        url('../res/fonts/PFRegalTextPro-Medium.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-Medium.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-BlackItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-BlackItalic'),
        url('../res/fonts/PFRegalTextPro-BlackItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-BlackItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-BlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-Black.eot');
    src: local('../res/fonts/PFRegalTextPro-Black'),
        url('../res/fonts/PFRegalTextPro-Black.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-Black.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-Black.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal UBlack';
    src: url('../res/fonts/PFRegalTextPro-UBlack.eot');
    src: local('../res/fonts/PFRegalTextPro-UBlack'),
        url('../res/fonts/PFRegalTextPro-UBlack.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-UBlack.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-UBlack.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-MediumItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-MediumItalic'),
        url('../res/fonts/PFRegalTextPro-MediumItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-MediumItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-MediumItalic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-UBlackItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-UBlackItalic'),
        url('../res/fonts/PFRegalTextPro-UBlackItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-UBlackItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-UBlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-RegularAItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-RegularAItalic'),
        url('../res/fonts/PFRegalTextPro-RegularAItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-RegularAItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-RegularAItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-BoldItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-BoldItalic'),
        url('../res/fonts/PFRegalTextPro-BoldItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-BoldItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-BoldItalic.ttf') format('truetype');
    font-weight: bold;
    font-style: italic;
}

@font-face {
    font-family: 'Charter';
    src: url('../res/fonts/charter-regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}

/*  Regular B */
@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-RegularBItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-RegularBItalic'),
        url('../res/fonts/PFRegalTextPro-RegularBItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-RegularBItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-RegularBItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-RegularB.eot');
    src: local('../res/fonts/PFRegalTextPro-RegularB'),
        url('../res/fonts/PFRegalTextPro-RegularB.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-RegularB.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-RegularB.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Regular.eot');
    src: local('../res/fonts/JetBrainsMono-Regular'),
        url('../res/fonts/JetBrainsMono-Regular.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Regular.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Regular.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Italic.eot');
    src: local('../res/fonts/JetBrainsMono-Italic'),
        url('../res/fonts/JetBrainsMono-Italic.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Italic.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Italic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Medium.eot');
    src: local('../res/fonts/JetBrainsMono-Medium'),
        url('../res/fonts/JetBrainsMono-Medium.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Medium.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Medium-Italic.eot');
    src: local('../res/fonts/JetBrainsMono-Medium-Italic'),
        url('../res/fonts/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Medium-Italic.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Medium-Italic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}
@font-face {
    font-family: 'Font Awesome 5 Free';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("../res/fonts/webfonts/fa-regular-400.eot");
    src: url("../res/fonts/webfonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), 
         url("../res/fonts/webfonts/fa-regular-400.woff2") format("woff2"), 
         url("../res/fonts/webfonts/fa-regular-400.woff") format("woff"), 
         url("../res/fonts/webfonts/fa-regular-400.ttf") format("truetype"), 
         url("../res/fonts/webfonts/fa-regular-400.svg#fontawesome") format("svg"); 
    font-display: swap;
}
    
.fa {
    font-family: 'Font Awesome 5 Free';
    font-weight: 400;
    font-display: swap;
}
@font-face {
  font-family: 'Font Awesome 5 Brands';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../res/fonts/fa-brands-400.eot");
  src: url("../res/fonts/fa-brands-400.eot?#iefix") format("embedded-opentype"), url("../res/fonts/fa-brands-400.woff2") format("woff2"), url("../res/fonts/fa-brands-400.woff") format("woff"), url("../res/fonts/fa-brands-400.ttf") format("truetype"), url("../res/fonts/fa-brands-400.svg#fontawesome") format("svg"); 
}

.fab {
  font-family: 'Font Awesome 5 Brands';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../res/fonts/fa-regular-400.eot");
  src: url("../res/fonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), url("../res/fonts/fa-regular-400.woff2") format("woff2"), url("../res/fonts/fa-regular-400.woff") format("woff"), url("../res/fonts/fa-regular-400.ttf") format("truetype"), url("../res/fonts/fa-regular-400.svg#fontawesome") format("svg"); 
}

.far {
  font-family: 'Font Awesome 5 Free';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 900;
  font-display: auto;
  src: url("../res/fonts/fa-solid-900.eot");
  src: url("../res/fonts/fa-solid-900.eot?#iefix") format("embedded-opentype"), url("../res/fonts/fa-solid-900.woff2") format("woff2"), url("../res/fonts/fa-solid-900.woff") format("woff"), url("../res/fonts/fa-solid-900.ttf") format("truetype"), url("../res/fonts/fa-solid-900.svg#fontawesome") format("svg"); 
}
</style>  
    <div class="book-title-container d-none d-lg-block">
        <div class="book-title">Knowledge Base</div>
        <div class="book-part-title-block">pt.1 <a href="..//ru/Memory/01-00-MemoryManagement-Intro.html" class="book-part-title">Управление памятью</a></div>
        <div class="book-part-title-block">pt.2 <a href="..//ru/Execution/02-00-ExecutionFlow-Intro.html" class="book-part-title">Поток исполнения команд</a></div>
        <br><a href="#" class="book-superheading-title">Обоснование выбора</a>
        / <a href="#" class="book-superheading-title">Упрощенное описание</a>
        / <a href="#" class="book-superheading-title">Подробное описание</a>
    </div>
    <header class="header fixed d-block d-lg-none">
        <p class="conflogo">KB</p> 

        <!-- mobile-menu -->

        <div class="hamburger-menu">
            <input id="menu__toggle" type="checkbox" />
            <label class="menu__btn" for="menu__toggle">
              <span></span>
            </label>
        
            <div class="menu__box">
                <p class="menu__header_current">На странице</p>
                <ol class="menu__list">
                    <li><a href="#basic-structure-x86-platform" onclick="$('#menu__toggle').click(); return true;">
Basic structure, x86 platform</a></li>
<li><a href="#some-words-about-exceptions-in-terms-of-the-x86-platform" onclick="$('#menu__toggle').click(); return true;">
Some words about exceptions in terms of the x86 platform</a></li>
<li><a href="#basic-information-about-x64-and-amd64-platforms-in-progress" onclick="$('#menu__toggle').click(); return true;">
Basic information about x64 and AMD64 platforms </a></li>
<li><a href="#basic-information-about-exception-handling-on-x64-and-amd64-platforms-in-progress" onclick="$('#menu__toggle').click(); return true;">
Basic information about exception handling on x64 and AMD64 platforms </a></li>
<li><a href="#a-little-about-the-imperfection-of-a-thread-stack" onclick="$('#menu__toggle').click(); return true;">
A little about the imperfection of a thread stack</a></li>
<li><a href="#a-big-example-thread-cloning-on-86-platform" onclick="$('#menu__toggle').click(); return true;">
A big example: thread cloning on х86 platform</a></li>
<li><a href="#conclusions-on-stackalloc" onclick="$('#menu__toggle').click(); return true;">
Conclusions on </a></li>

                </ol>
                <p class="menu__header_total">Содержание</p>
                <ul class="menu__header_list">
                    <li>
                        <p class="menu__header_total_sub">
                            Управление памятью
                        </p>
                        <p class="menu__header_total_sub2">
                            Теоретические вопросы:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="../ru/Memory/01-00-MemoryManagement-Intro.html">
                                Общие слова
                            </a></p></li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-02-MemoryManagement-Basics.html">Введение в управление памятью</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-04-MemoryManagement-ThreadStack.html">Стек потока</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-06-MemoryManagement-EntitiesLifetime.html">Время жизни сущности</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-08-MemoryManagement-RefVsValueTypes.html">RefTypes, ValueTypes, Boxing &amp; Unboxing</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-10-MemoryManagement-IDisposable.html">Шаблон IDisposable</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-12-MemoryManagement-Finalizer.html">Финализация</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../ru/Memory/01-14-MemoryManagement-Results.html">Выводы</a></p>
                            </li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Практические вопросы:
                        </p>
                        <ol class="menu__list" start="9">
                            <li><p><a href="../ru/Memory/02-02-MemoryManagement-MemorySpan.html">
                                Memory&lt;T&gt;, Span&lt;T&gt;
                            </a></p></li>
                        </ol> 
                    </li>
                    <li>
                        <p class="menu__header_total_sub">
                            Поток исполнения команд
                        </p>
                        <p class="menu__header_total_sub2">
                            Многопоточность:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="../ru/Execution/1-Threads/1-OS/1-threadsScheduling.html">
                                Потоки и планирование потоков
                            </a></p></li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Искл­юч­ител­ьные си­ту­а­ции:
                        </p>
                        <ol class="menu__list" start="2">
                            <li><p><a href="../ru/Execution/2-ExceptionalFlow/1-Exceptions-Intro.html">
                                Введение в исключительные ситуации
                            </a></p></li>
                            <li><p><a href="../ru/Execution/2-ExceptionalFlow/2-Exceptions-Architecture.html">
                                Архитектура исключительной ситуации
                            </a></p></li>
                            <li><p><a href="../ru/Execution/2-ExceptionalFlow/3-Exceptions-Events.html">
                                События об исключительных ситуациях
                            </a></p></li>
                            <li><p><a href="../ru/Execution/2-ExceptionalFlow/4-Exceptions-Types.html">
                                Виды исключительных ситуаций
                            </a></p></li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
    </header>

    <div class="book-container">
        <div class="article-container">
            <!--<p class="d-xs-block d-sm-none">XS</p>
            <p class="d-none d-xs-block d-sm-none">SM</p>
            <p class="d-none d-sm-block d-md-none">MD</p>
            <p class="d-none d-lg-block d-xl-none">LG</p>
            <p class="d-none d-xl-block">XL</p> -->
            <h1 id="a-thread-stack">A thread stack</h1>
<blockquote>
<p><a href="https://github.com/sidristij/dotnetbook/issues/58">A link to the discus&shy;sion</a></p>
</blockquote>
<h2 id="basic-structure-x86-platform">Basic struc&shy;ture, x86 plat&shy;form</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">01</div>
<p>There is a memory region that is rarely menti&shy;oned. However&shy;, it probably takes a primary role in the work of an appli&shy;ca&shy;tion. This is the most frequ&shy;ently used and a quite limited region with instan&shy;ta&shy;neous memory allo&shy;ca&shy;tion and cleanup. This region is called &laquo;a thread stack&raquo;. And since a pointer to a thread stack is encoded essen&shy;ti&shy;ally by processor regis&shy;ters which are in the thread context, each thread has its own stack during exe&shy;cu&shy;tion. Why is it neces&shy;sary?</p>
<div class="paragraph-right-side">01</div>
</div>
<p>Let’s review a simple example of code:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Method1()
{
    Method2(123);
}

<span style="color:Blue;">void</span> Method2(<span style="color:Blue;">int</span> arg)
{
    <span style="color:Green;">// ...</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">02</div>
<p>Nothing signi&shy;fi&shy;cant happens in this code. However&shy;, we wouldn’t skip it and instead will exa&shy;mine it care&shy;fully . When any <code>Method1</code> calls any <code>Method2</code>, any such call (not only in .NET but in other plat&shy;forms too) goes through the follo&shy;wing steps:</p>
<div class="paragraph-right-side">02</div>
</div>
<ol>
<li>First&shy;, a JIT-compiled code saves method para&shy;me&shy;ters to the stack (star&shy;ting with a third one). The first two para&shy;me&shy;ters are passed through regis&shy;ters. It is impor&shy;tant to remember that the first passed para&shy;meter of instance methods is a pointer to an object that the method works with, i.e. <code>this</code> pointer. So&shy;, in these (almost all) cases only one para&shy;meter goes to regis&shy;ters, while the stack is used for the rest.</li>
<li>Next&shy;, a compiler puts the <code>call</code> method call instr&shy;uc&shy;tion which puts the method return add&shy;ress to the stack. This is the add&shy;ress of an instr&shy;uc&shy;tion that follows the <code>call</code> instr&shy;uc&shy;tion. Thus&shy;, each method knows where it should return to, so that calling code could continue its work.</li>
<li>After passing all para&shy;me&shy;ters and calling the method we should unders&shy;tand how to restore the stack if we exi&shy;ting the method and don’t want to calcu&shy;late bytes occu&shy;pied in the stack. To do this, we save the value of the EBP register, which always stores a pointer to the begin&shy;ning of a current stack frame (i.e. a range where the infor&shy;ma&shy;tion for a specific called method is stored). Saving the value of this register at each call, we create a single linked list of stack frames. Note that in fact they follow each other preci&shy;sely without gaps. However&shy;, to simp&shy;lify memory cleanup from a frame and to debug an appli&shy;ca&shy;tion (a debugger uses these poin&shy;ters to show Stack Trace&shy;) a single linked list is built.</li>
<li>The last thing to do during the method call is to allo&shy;cate a memory range for local vari&shy;ables. As a compiler knows in advance how much memory is needed, it allo&shy;cates it imme&shy;di&shy;a&shy;tely by moving a pointer to the top of the stack (SP/ESP/RSP) by a neces&shy;sary number of bytes.</li>
<li>The fifth step is the exe&shy;cu&shy;tion of a method code, i.e. useful ope&shy;ra&shy;tions.</li>
<li>While exi&shy;ting the method, the top of the stack is restored from the EBP which is the place where the begin&shy;ning of a current stack frame is stored.</li>
<li>And finally, we use <code>ret</code> instr&shy;uc&shy;tion to exit the method.  It takes the return add&shy;ress that was put on the stack by the <code>call</code> instr&shy;uc&shy;tion and makes <code>jmp</code> based on this add&shy;ress.</li>
</ol>
<p>The figure shows these processes:</p>
<div class="image-container"><p><img src="../imgs/ThreadStack/AnyMethodCall.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">03</div>
<p>Note that the stack grows star&shy;ting from higher and finishing with lower addresses, i.e. in reverse.</p>
<div class="paragraph-right-side">03</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">04</div>
<p>Loo&shy;king at this you may think that if not the majo&shy;rity but at least the half of all ope&shy;ra&shy;tions a processor deals with are to service the struc&shy;ture of a program and not its payload. I mean servi&shy;cing method calls, checking if one type can be cast to another one, compi&shy;ling Generic vari&shy;a&shy;tions, searching methods in inter&shy;face tables&hellip; Espe&shy;ci&shy;ally if we remember that the major part of the modern code is written from the pers&shy;pec&shy;tive of working through inter&shy;faces and imple&shy;men&shy;ting a multi&shy;tude of small methods, each perfor&shy;ming its own functions&hellip; The work often involves base types and casting types to an inter&shy;face or to an inhe&shy;ritor. With all these input condi&shy;tions you might make a conc&shy;lu&shy;sion about the lavish&shy;ness of inf&shy;rast&shy;ruc&shy;ture code. The only thing I can tell you is that compi&shy;lers, inclu&shy;ding JIT, have a lot of tech&shy;ni&shy;ques that allow them to create more produc&shy;tive code. Where possible they insert an entire method body instead of calling it and rather than searching a method in an inter&shy;face VSD, compi&shy;lers call it directly. The saddest thing is that it’s hard to mea&shy;sure the load on inf&shy;rast&shy;ruc&shy;ture: it’s neces&shy;sary that a JITter or any other compiler inserts some metrics before and after inf&shy;rast&shy;ruc&shy;ture code running. That is before a method call and after ini&shy;ti&shy;a&shy;li&shy;zing a stack frame inside this method. Before and after exi&shy;ting a method. Before compi&shy;la&shy;tion and after it. And so on. But let’s not talk about sad things, but discuss what we can do with the obta&shy;ined infor&shy;ma&shy;tion.</p>
<div class="paragraph-right-side">04</div>
</div>
<h2 id="some-words-about-exceptions-in-terms-of-the-x86-platform">Some words about excep&shy;tions in terms of the x86 plat&shy;form</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">05</div>
<p>If we look inside the code of methods, we will see another struc&shy;ture, working with a thread stack. See for your&shy;self:</p>
<div class="paragraph-right-side">05</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Method1()
{
    <span style="color:Blue;">try</span>
    {
        Method2(123);
    } <span style="color:Blue;">catch</span> {
        <span style="color:Green;">// ...</span>
    }
}

<span style="color:Blue;">void</span> Method2(<span style="color:Blue;">int</span> arg)
{
    Method3();
}

<span style="color:Blue;">void</span> Method3()
{
    <span style="color:Blue;">try</span>
    {
        <span style="color:Green;">//...</span>
    } <span style="color:Blue;">catch</span> {
        <span style="color:Green;">//...</span>
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">06</div>
<p>If an excep&shy;tion appears in any method, called from <code>Method3</code>, the control will be returned to the <code>catch</code> block of <code>Method3</code>. If han&shy;dling of this excep&shy;tion failed, its han&shy;dling will start in <code>Method1</code>. However&shy;, if nothing happens, <code>Method3</code> will finish its work and control will be passed to <code>Method2</code> where an excep&shy;tion can also be thrown. However&shy;, natu&shy;rally, it will be han&shy;dled in <code>Method1</code> and not in <code>Method3</code>. The idea of such conve&shy;nient aut&shy;om&shy;ation is that data struc&shy;tures that form the chains of excep&shy;tion han&shy;dlers are also put to the method stack frame where they are declared. We will talk about excep&shy;tions sepa&shy;ra&shy;tely. Here&shy;, I should only note that the model of excep&shy;tions in .NET Frame&shy;work CLR is diffe&shy;rent from Core CLR. Core&shy;CLR has to be diffe&shy;rent for various plat&shy;forms. That’s why it has a distinc&shy;tive model of excep&shy;tions which is offered through PAL (Plat&shy;form Adap&shy;tion Layer&shy;) in diffe&shy;rent imple&shy;men&shy;ta&shy;tions depen&shy;ding on the plat&shy;form. Big .NET Frame&shy;work CLR doesn’t need this as it exists in Windows ec&shy;osystem that for many years has been using a common mech&shy;anism for excep&shy;tion han&shy;dling called SEH (Struc&shy;tured Excep&shy;tion Handling&shy;). This mech&shy;anism is used by almost all prog&shy;ram&shy;ming langu&shy;ages (during final compi&shy;la&shy;tion) because it ensures end-to-end excep&shy;tion han&shy;dling between modules, written in diffe&shy;rent langu&shy;ages. It works like this:</p>
<div class="paragraph-right-side">06</div>
</div>
<ol>
<li>When a program enters a <code>try</code> block, the mech&shy;anism puts the struc&shy;ture to the stack , the first field of which indi&shy;cates a previous block of excep&shy;tion han&shy;dling (e.g. a calling method which also has try-catch), the type of the block, the excep&shy;tion code and the han&shy;dler add&shy;ress.</li>
<li>The add&shy;ress of highest-prio&shy;rity excep&shy;tion han&shy;dler for the Thread Envi&shy;ron&shy;ment Block (TEB)—basi&shy;cally, a thread context—within the chain of han&shy;dlers is changed to the add&shy;ress created by us. Thus&shy;, we added our block to the chain.</li>
<li>After the exe&shy;cu&shy;tion of the <code>try</code> block, the mech&shy;anism performs a reverse ope&shy;ra&shy;tion: the previous highest-prio&shy;rity han&shy;dler is regis&shy;tered in TEB, thus pushing our han&shy;dler out of the chain.</li>
<li>If an excep&shy;tion occurs, the highest-prio&shy;rity han&shy;dler is taken from TEB and han&shy;dlers in the chain are called in turn. Each of them checks whether this excep&shy;tion matches its parti&shy;cular type. If it does, the han&shy;dling block is acti&shy;vated (e.g., <code>catch</code>).</li>
<li>The add&shy;ress of SEH struc&shy;ture which was in the stack BEFORE the excep&shy;tion han&shy;dler method is restored in TEB.</li>
</ol>
<div class="paragraph-container">
<div class="paragraph-left-side">07</div>
<p>As you can see, it’s not so diffi&shy;cult. However&shy;, all this infor&shy;ma&shy;tion also exists on the stack.</p>
<div class="paragraph-right-side">07</div>
</div>
<h2 id="basic-information-about-x64-and-amd64-platforms-in-progress">Basic infor&shy;ma&shy;tion about x64 and AMD64 plat&shy;forms [In Progress&shy;]</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="basic-information-about-exception-handling-on-x64-and-amd64-platforms-in-progress">Basic infor&shy;ma&shy;tion about excep&shy;tion han&shy;dling on x64 and AMD64 plat&shy;forms [In Progress&shy;]</h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h2 id="a-little-about-the-imperfection-of-a-thread-stack">A little about the imper&shy;fec&shy;tion of a thread stack</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">08</div>
<p>Let’s think about a secu&shy;rity issue and possible prob&shy;lems that can appear the&shy;or&shy;etically. To do this, let’s look again at the struc&shy;ture of a thread stack which is essen&shy;ti&shy;ally a usual array. The memory range in which frames are built grows from the end to the begin&shy;ning. It means that more recent frames are assigned ini&shy;tial addresses. As it was said earlier frames are connected through a single linked list. This is because the size of a frame is not fixed and should be &laquo;read&raquo; by any debugger. A processor, in this case, doesn’t deli&shy;neate frames from each other: any method can read the entire memory region. And assu&shy;ming that we are in virtual memory that is divided into ranges of really allo&shy;cated memory, we can use special Win&shy;API function and any add&shy;ress on the stack to get an allo&shy;cated memory range where this add&shy;ress exists. Dea&shy;ling with a single linked list is easy:</p>
<div class="paragraph-right-side">08</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// the variable is on the stack</span>
    <span style="color:Blue;">int</span> x;

    <span style="color:Green;">// Get information about a memory range, allocated for the stack</span>
    MEMORY_BASIC_INFORMATION *stackData = <span style="color:Blue;">new</span> MEMORY_BASIC_INFORMATION();
    VirtualQuery((<span style="color:Blue;">void</span> *)&amp;x, stackData, <span style="color:Blue;">sizeof</span>(MEMORY_BASIC_INFORMATION));
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">09</div>
<p>Thus we can get and modify all data which exists as local vari&shy;ables in methods that called us. If an appli&shy;ca&shy;tion doesn’t adjust the settings of a sandbox used for calling third-party libra&shy;ries, which enhance the functi&shy;o&shy;na&shy;lity of the appli&shy;ca&shy;tion, the third-party library can get data, even if the API you are using doesn’t provide for it. This tech&shy;nique may seem purely arti&shy;fi&shy;cial, but in the world of C/C++ where there is no App&shy;Domain with confi&shy;gured rights, the attack on the stack is a typical way to hack appli&shy;ca&shy;tions. Moreover&shy;, we can use reflec&shy;tion to look at the type we need, repli&shy;cate its struc&shy;ture on our side and replace the VMT add&shy;ress with our add&shy;ress, using the refe&shy;rence from the stack to an object, and redi&shy;rect the whole work with a parti&shy;cular instance to our side. By the way, SEH is also acti&shy;vely used to hack appli&shy;ca&shy;tions. Using an excep&shy;tion han&shy;dler, you can change its add&shy;ress and make OS exe&shy;cute malware code. However&shy;, the solu&shy;tion is simple: always adjust the settings of a sandbox when you want to work with libra&shy;ries, exten&shy;ding the functi&shy;o&shy;na&shy;lity of your appli&shy;ca&shy;tion. I mean diffe&shy;rent plug-ins, add-ons and other exten&shy;sions.</p>
<div class="paragraph-right-side">09</div>
</div>
<h2 id="a-big-example-thread-cloning-on-86-platform">A big example: thread cloning on х86 plat&shy;form</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">10</div>
<p>To memo&shy;rize the details of what we have read, we should look at the same topic from diffe&shy;rent pers&shy;pec&shy;tives. Which example can you really design for a thread stack? Call a method from another? Magic&hellip; Of course not: we do it many times every day. Instead&shy;, we will copy the exe&shy;cu&shy;tion thread. It means we will ensure that after calling a parti&shy;cular method we would get two threads instead of one: our thread and a new one that conti&shy;nues to exe&shy;cute code from the point of the clone method call as if it got here itself. It will look like this:</p>
<div class="paragraph-right-side">10</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> MakeFork()
{
    <span style="color:Green;">// To ensure everything was cloned, we create local variables:</span>
    <span style="color:Green;">// Their values in the new thread should be the same as in the parent one</span>
    <span style="color:Blue;">var</span> sameLocalVariable = 123;
    <span style="color:Blue;">var</span> sync = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();

    <span style="color:Green;">// Clocking time</span>
    <span style="color:Blue;">var</span> stopwatch = Stopwatch.StartNew();

    <span style="color:Green;">// Cloning a thread</span>
    <span style="color:Blue;">var</span> forked = Fork.CloneThread();

    <span style="color:Green;">// From now on the code is executed by two threads.</span>
    <span style="color:Green;">// forked = true is for the child thread, false is for the parent one</span>
    <span style="color:Blue;">lock</span>(sync)
    {
        Console.WriteLine(<span style="color:#A31515;">&quot;in {0} thread: {1}, local value: {2}, time to enter = {3} ms&quot;</span>,
            forked ? <span style="color:#A31515;">&quot;forked&quot;</span> : <span style="color:#A31515;">&quot;parent&quot;</span>,
            Thread.CurrentThread.ManagedThreadId,
            sameLocalVariable,
            stopwatch.ElapsedMilliseconds);
    }

    <span style="color:Green;">// When exiting the method the parent thread will return control to the method </span>
    <span style="color:Green;">// that called MakeFork(), i.e. will continue work as usual,</span>
    <span style="color:Green;">// and the execution of the child thread will finish.</span>
}

<span style="color:Green;">// Sample output:</span>
<span style="color:Green;">// in forked thread: 2, local value: 123, time to enter = 2 ms</span>
<span style="color:Green;">// in parent thread: 1, local value: 123, time to enter = 2 ms</span>
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">11</div>
<p>Admit&shy;, this is an inte&shy;res&shy;ting concept. Of course, you may argue a lot about the approp&shy;ri&shy;a&shy;te&shy;ness of such actions, but the main task of this example is to put a fine point to the expla&shy;na&shy;tions of working prin&shy;ciples for this data struc&shy;ture. How do we clone threads? To answer this ques&shy;tion, we should unders&shy;tand what things char&shy;ac&shy;te&shy;rize a thread. Actually&shy;, it is char&shy;ac&shy;te&shy;rized by the follo&shy;wing struc&shy;tures and data regions:</p>
<div class="paragraph-right-side">11</div>
</div>
<ol>
<li>A set of CPU regis&shy;ters. All regis&shy;ters define the state of an exe&shy;cu&shy;tion thread: star&shy;ting from the add&shy;ress of a current exe&shy;cu&shy;tion instr&shy;uc&shy;tion to the addresses of a thread stack and the data it uses.</li>
<li><a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">Thread Envi&shy;ron&shy;ment Block</a> or TIB/TEB stores system infor&shy;ma&shy;tion about a thread, inclu&shy;ding the addresses of excep&shy;tion han&shy;dlers.</li>
<li>A thread stack, the add&shy;ress of which is defined by SS:ESP regis&shy;ters.</li>
<li>The plat&shy;form context of a thread that contains local data for the thread (a refe&shy;rence comes from TIB).</li>
</ol>
<div class="paragraph-container">
<div class="paragraph-left-side">12</div>
<p>And surely something else that we don’t know. But we don’t have to know everything in case of an example: this code is not for produc&shy;tion use, but to unders&shy;tand the idea. That’s why it takes into account only the most impor&shy;tant things. If we want this code to function in its basic form, we need to copy a set of regis&shy;ters to a new thread (changing SS:ESP as the stack will be new) and edit the stack itself, so it would contain what we need.</p>
<div class="paragraph-right-side">12</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">13</div>
<p>Well&shy;, if a thread stack deter&shy;mines which methods were called and which data they use, it means that the&shy;or&shy;etically by changing these struc&shy;tures you can change local vari&shy;ables of methods and eli&shy;mi&shy;nate the call of some method from the stack, replace the method with another or your own method in any place of a chain. Ok&shy;, we have decided on this. Now&shy;, let’s look at some pseu&shy;do&shy;code:</p>
<div class="paragraph-right-side">13</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> RootMethod()
{
    MakeFork();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">14</div>
<p>When <code>Make&shy;Fork&shy;()</code> is called, what do we expect in terms of stack traces?  We expect that nothing will change in a parent thread, and a child thread will be taken from the thread pool (for speed). The call of <code>Make&shy;Fork</code> method with its local data will be imi&shy;tated in this thread, and the exe&shy;cu&shy;tion of code will continue not from the begin&shy;ning of the method, but from the point after <code>Clone&shy;Thread</code> call. Thus&shy;, the stack trace in our ima&shy;gi&shy;na&shy;tion will look like:</p>
<div class="paragraph-right-side">14</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Parent Thread</span>
RootMethod -&gt; MakeFork

<span style="color:Green;">// Child Thread</span>
ThreadPool -&gt; MakeFork
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">15</div>
<p>What do we have from the begin&shy;ning? We have our thread. We also have an oppor&shy;tu&shy;nity to create a new thread or sch&shy;edule a task to an object pool, exe&shy;cu&shy;ting our code there. We also unders&shy;tand that the infor&shy;ma&shy;tion about nested calls is stored in a call stack and we can mani&shy;pu&shy;late it (for example, using C++/CLI). Also&shy;, if we imple&shy;ment agre&shy;e&shy;ments and put to the stack top the return add&shy;ress for the <code>ret</code> instr&shy;uc&shy;tion as well as the EBP register value and allo&shy;cate space for locals (if neces&shy;sary), we can imi&shy;tate the method call. Manual entries to a thread stack can be made from C#, but we will need regis&shy;ters and will have to use them very care&shy;fully. Thus&shy;, we can’t do without turning to C++. Here CLI/C++ comes to help us the first time in life (at least for me). It allows writing mixed code: a part of instr&shy;uc&shy;tions is written in .NET, another part in C++, and the third part can even be written in assembly language. That’s exactly what we need.</p>
<div class="paragraph-right-side">15</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">16</div>
<p>So&shy;, how will a thread stack look like, when our code will call <code>Make&shy;Fork</code> which will call <code>Clone&shy;Thread</code> which will go to the unma&shy;naged world of CLI/C++ and call the cloning method (the imple&shy;men&shy;ta&shy;tion itself) there? Let’s look at the figure (note once again that the stack is growing from higher to lower addresses. From left to right):</p>
<div class="paragraph-right-side">16</div>
</div>
<div class="image-container"><p><img src="../imgs/ThreadStack/step1.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">17</div>
<p>In order not to move the whole thing from figure to figure, let’s simp&shy;lify it and keep only what we need:</p>
<div class="paragraph-right-side">17</div>
</div>
<div class="image-container"><p><img src="../imgs/ThreadStack/step2.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">18</div>
<p>When we create a thread or take a made-up thread from the pool, another stack appears in our figure. However&shy;, this stack is not ini&shy;ti&shy;a&shy;lized yet.</p>
<div class="paragraph-right-side">18</div>
</div>
<div class="image-container"><p><img src="../imgs/ThreadStack/step3.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">19</div>
<p>Now&shy;, we need to imi&shy;tate the running of <code>Fork&shy;.Clone&shy;Thread&shy;()</code> method in a new thread. To do this, we need to add a series of frames to the end of its thread stack: as if CLI/C++ method was called by a managed wrapper through a C++ wrapper from <code>Fork&shy;.Clone&shy;Thread&shy;()</code> which was in turn called from a dele&shy;gate trans&shy;ferred to <code>Thread&shy;Pool</code>. To do this, we will copy a neces&shy;sary stack region to an array (note that the copies of EBP regis&shy;ters, used for buil&shy;ding a frame chain, in the cloned region “over&shy;look” the former region):</p>
<div class="paragraph-right-side">19</div>
</div>
<div class="image-container"><p><img src="../imgs/ThreadStack/step4.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">20</div>
<p>To ensure the integ&shy;rity of stack after copying the previously cloned region, we esti&shy;mate in advance which addresses will be taken by EBP fields in a new place and change them to copies imme&shy;di&shy;a&shy;tely:</p>
<div class="paragraph-right-side">20</div>
</div>
<div class="image-container"><p><img src="../imgs/ThreadStack/step5.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">21</div>
<p>The last step is to copy our array to the end of the child thread stack care&shy;fully, using a minimal number of regis&shy;ters, and move our ESP and EBP regis&shy;ters to new places. We imi&shy;tated the call of all these methods in terms of the stack:</p>
<div class="paragraph-right-side">21</div>
</div>
<div class="image-container"><p><img src="../imgs/ThreadStack/step6.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">22</div>
<p>But not in terms of code. In terms of code, we need to access those methods that we have just created. The simp&shy;lest way is to imi&shy;tate the exit from a method: restore <code>ESP</code> from <code>EBP</code>, put into <code>EBP</code> what it points to and call <code>ret</code> instr&shy;uc&shy;tion, ini&shy;ti&shy;a&shy;ting the exit from a suppo&shy;sedly called C++ method for thread cloning. This will end up with retur&shy;ning to a real wrapper of the CLI/C++ call, which will pass control to <code>Make&shy;Fork&shy;()</code>, but in a child thread. This tech&shy;nique works.</p>
<div class="paragraph-right-side">22</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">23</div>
<p>Now&shy;, let’s look at another code. The first thing we do is the oppor&shy;tu&shy;nity for CLI/C++ code to create a .NET thread. To do this, we need to create in .NET:</p>
<div class="paragraph-right-side">23</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">extern</span> <span style="color:#A31515;">&quot;C&quot;</span> __declspec(dllexport)
<span style="color:Blue;">void</span> __stdcall MakeManagedThread(AdvancedThreading_Unmanaged *helper, StackInfo *stackCopy)
{
    AdvancedThreading::Fork::MakeThread(helper, stackCopy);
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">24</div>
<p>Don’t yet pay atten&shy;tion to the types of para&shy;me&shy;ters. They are requ&shy;ired to transfer infor&shy;ma&shy;tion about which stack region should be copied from a parent stack to a child one. The method of thread crea&shy;tion wraps the call of unma&shy;naged method in a dele&shy;gate, trans&shy;fers data and put the dele&shy;gate into a queue for proces&shy;sing by the thread pool.</p>
<div class="paragraph-right-side">24</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">void</span> MakeThread(AdvancedThreading_Unmanaged *helper, StackInfo *stackCopy)
{
    ForkData^ data = gcnew ForkData();
    data-&gt;helper = helper;
    data-&gt;info = stackCopy;

    ThreadPool::QueueUserWorkItem(gcnew WaitCallback(&amp;InForkedThread), data);
}

[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">void</span> InForkedThread(Object^ state)
{
    ForkData^ data = (ForkData^)state;
    data-&gt;helper-&gt;InForkedThread(data-&gt;info);
}
</pre></div>
</div>
<p>And at last the cloning method itself (its .NET part actu&shy;ally):</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">bool</span> CloneThread()
{
    ManualResetEvent^ resetEvent = gcnew ManualResetEvent(<span style="color:Blue;">false</span>);
    AdvancedThreading_Unmanaged *helper = <span style="color:Blue;">new</span> AdvancedThreading_Unmanaged();
    <span style="color:Blue;">int</span> somevalue;

    <span style="color:Green;">// *</span>
    helper-&gt;stacktop = (<span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span> *)&amp;somevalue;
    <span style="color:Blue;">int</span> forked = helper-&gt;ForkImpl();
    <span style="color:Blue;">if</span> (!forked)
    {
        resetEvent-&gt;WaitOne();
    }
    <span style="color:Blue;">else</span>
    {
        resetEvent-&gt;Set();
    }
    <span style="color:Blue;">return</span> forked;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">25</div>
<p>To unders&shy;tand where this method exists in a chain of stack frames, we have saved the add&shy;ress of a stack vari&shy;able (*). We will use this add&shy;ress in a cloning method, which will be discussed further. Also&shy;, for you to unders&shy;tand what is it all about I will show the code of a struc&shy;ture that is neces&shy;sary to store infor&shy;ma&shy;tion about the stack copy:</p>
<div class="paragraph-right-side">25</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> StackInfo
{
<span style="color:Blue;">public</span>:
    <span style="color:Green;">// The copy of registers values</span>
    <span style="color:Blue;">int</span> EAX, EBX, ECX, EDX;
    <span style="color:Blue;">int</span> EDI, ESI;
    <span style="color:Blue;">int</span> ESP;
    <span style="color:Blue;">int</span> EBP;
    <span style="color:Blue;">int</span> EIP;
    <span style="color:Blue;">short</span> CS;

    <span style="color:Green;">// The address of a stack copy</span>
    <span style="color:Blue;">void</span> *frame;

    <span style="color:Green;">// The size of a copy</span>
    <span style="color:Blue;">int</span> size;

    <span style="color:Green;">// The address ranges of the original stack are necessary</span>
    <span style="color:Green;">// to replace the addresses on the stack, if exist, with new ones</span>
    <span style="color:Blue;">int</span> origStackStart, origStackSize;
};
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">26</div>
<p>The work of the algo&shy;rithm is divided into two stages: firstly, we prepare data in a parent thread to repre&shy;sent neces&shy;sary stack frames in a child thread. Secondly&shy;, the child thread data is restored and over&shy;lays its own exe&shy;cu&shy;tion thread stack, thus imi&shy;ta&shy;ting the calls of methods that were never called.</p>
<div class="paragraph-right-side">26</div>
</div>
<h3 id="a-method-of-preparation-for-copying">A method of prepa&shy;ra&shy;tion for copying</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">27</div>
<p>I will desc&shy;ribe the code step-by-step. To do so, I will divide the entire code into parts and comment on each part sepa&shy;ra&shy;tely. Let’s start.</p>
<div class="paragraph-right-side">27</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">28</div>
<p>External code calls <code>Fork&shy;.Clone&shy;Thread&shy;()</code> through an internal wrap over the unma&shy;naged code and through a series of addi&shy;ti&shy;onal methods if code runs while debug&shy;ging (so-called debugger assis&shy;tants). That’s why we saved the add&shy;ress of a vari&shy;able on the stack in the .NET part: for a C++ method this add&shy;ress is a kind of label, and now we know which region of the stack we can copy.</p>
<div class="paragraph-right-side">28</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span> AdvancedThreading_Unmanaged::ForkImpl()
{
    StackInfo copy;
    StackInfo* info;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">29</div>
<p>First of all, before any ope&shy;ra&shy;tion, we copy the regis&shy;ters locally to avoid corrup&shy;ting them. Additionally&shy;, we need to save the add&shy;ress of code, where we will make <code>goto</code> when the stack will be imi&shy;tated in a child thread and we will have to exit <code>Clone&shy;Thread</code> in the child thread. As an "exit point” we choose <code>Jmp&shy;Point&shy;On&shy;Methods&shy;Chain&shy;Call&shy;Emulation</code> on purpose, because after saving this add&shy;ress "for the future” we addi&shy;ti&shy;o&shy;nally put number 0 on the stack.</p>
<div class="paragraph-right-side">29</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// Save ALL registers</span>
    _asm
    {
        mov copy.EAX, EAX
        mov copy.EBX, EBX
        mov copy.ECX, ECX
        mov copy.EDX, EBX
        mov copy.EDI, EDI
        mov copy.ESI, ESI
        mov copy.EBP, EBP
        mov copy.ESP, ESP

        <span style="color:Green;">// Save CS:EIP for far jmp</span>
        mov copy.CS, CS
        mov copy.EIP, offset JmpPointOnMethodsChainCallEmulation

        <span style="color:Green;">// Save mark for this method to indicate the point it was called from</span>
        push 0
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">30</div>
<p>Then&shy;, after <code>Jmp&shy;Point&shy;On&shy;Methods&shy;Chain&shy;Call&shy;Emulation</code> we retrieve this number from the stack and check if it’s still <code>0</code>. If it is, then we are still in the same thread which means we have a lot of things to do and we go to <code>Non&shy;Cloned</code>. If the value is <code>1</code>, it means that the child thread added all neces&shy;sary compo&shy;nents to the thread stack, put number <code>1</code> on the stack and made <code>goto</code> to this point (note that <code>goto</code> is made from another method). This means it’s time to exit <code>Clone&shy;Thread</code> from the child tread, the call of which was imi&shy;tated.</p>
<div class="paragraph-right-side">30</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
JmpPointOnMethodsChainCallEmulation:

    _asm
    {
        pop EAX
        cmp EAX, 0
        je NonCloned

        pop EBP
        mov EAX, 1
        ret
    }
NonCloned:
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">31</div>
<p>OK, we made sure that we have a lot to do and we need to prepare data for the child thread. We will work with the struc&shy;ture of previously saved regis&shy;ters not to go to the assembler language level again. First&shy;, let’s get the EBP register value out of this struc&shy;ture. Essentially&shy;, the register is the "Next” field in a single linked list of stack frames. Follo&shy;wing the add&shy;ress that exists there, we access the frame of a method which called us. If we use the add&shy;ress which is conta&shy;ined in the first field there, we will access an even lower frame. This way we can get to the managed part of <code>Clone&shy;Thread</code> as we saved the add&shy;ress of the vari&shy;able in its stack frame and know exactly where to stop. The cycle shown below solves exactly this task.</p>
<div class="paragraph-right-side">31</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">int</span> *curptr = (<span style="color:Blue;">int</span> *)copy.EBP;
    <span style="color:Blue;">int</span> frames = 0;

    <span style="color:Green;">//</span>
    <span style="color:Green;">//  Calculate frames count between a current call and Fork.CloneTherad() call</span>
    <span style="color:Green;">//</span>
    <span style="color:Blue;">while</span> ((<span style="color:Blue;">int</span>)curptr &lt; stacktop)
    {
        curptr = (<span style="color:Blue;">int</span>*)*curptr;
        frames++;
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">32</div>
<p>Because we got the add&shy;ress of <code>Clone&shy;Thread</code> managed method frame begin&shy;ning we know how much we should copy to imi&shy;tate the call of <code>Clone&shy;Thread</code> from <code>Make&shy;Fork</code>. However&shy;, since we also need <code>Make&shy;Fork</code> (we need to exit into it exactly), it’s neces&shy;sary to make another tran&shy;si&shy;tion in a single linked list: <code>*(int *)curptr</code>. After that, we create an array to save the stack by simple copying.</p>
<div class="paragraph-right-side">32</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">//</span>
    <span style="color:Green;">//  We need to copy the stack part from our method to a user code method including its locals on the stack</span>
    <span style="color:Green;">//</span>
    <span style="color:Blue;">int</span> localsStart = copy.EBP;                             <span style="color:Green;">// our EBP points to the EBP value for the parent method + saved ESI, EDI</span>
    <span style="color:Blue;">int</span> localsEnd = *(<span style="color:Blue;">int</span> *)curptr;                         <span style="color:Green;">// points to the end of a user&#39;s method&#39;s locals (additional leave)</span>

    <span style="color:Blue;">byte</span> *arr = <span style="color:Blue;">new</span> <span style="color:Blue;">byte</span>[localsEnd - localsStart];
    memcpy(arr, (<span style="color:Blue;">void</span>*)localsStart, localsEnd - localsStart);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">33</div>
<p>Another task to be solved is upda&shy;ting the addresses of vari&shy;ables, which are still on the stack and point to it. To solve this task, we get a range of addresses which were allo&shy;cated by the ope&shy;ra&shy;ting system for the thread stack. We save the retri&shy;eved infor&shy;ma&shy;tion and start the second part of a cloning process, prepa&shy;ring a dele&shy;gate for the thread pool:</p>
<div class="paragraph-right-side">33</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// Get information about stack pages</span>
    MEMORY_BASIC_INFORMATION *stackData = <span style="color:Blue;">new</span> MEMORY_BASIC_INFORMATION();
    VirtualQuery((<span style="color:Blue;">void</span> *)copy.EBP, stackData, <span style="color:Blue;">sizeof</span>(MEMORY_BASIC_INFORMATION));

    <span style="color:Green;">// fill StackInfo structure</span>
    info = <span style="color:Blue;">new</span> StackInfo(copy);
    info-&gt;origStackStart = (<span style="color:Blue;">int</span>)stackData-&gt;BaseAddress;
    info-&gt;origStackSize = (<span style="color:Blue;">int</span>)stackData-&gt;RegionSize;
    info-&gt;frame = arr;
    info-&gt;size = (localsEnd - localsStart);

    <span style="color:Green;">// call managed ThreadPool.QueueUserWorkitem to make fork</span>
    MakeManagedThread(<span style="color:Blue;">this</span>, info);

    <span style="color:Blue;">return</span> 0;
}
</pre></div>
</div>
<h3 id="a-method-of-restoration-from-a-copy">A method of resto&shy;ra&shy;tion from a copy</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">34</div>
<p>This method is conse&shy;qu&shy;en&shy;ti&shy;ally called after the previous one quits running: we obta&shy;ined a copy of the parent thread stack region and a full set of its regis&shy;ters. Our task is to add all calls, copied from the parent thread, to our thread, taken from a thread pool, as if we made these calls ourse&shy;lves. After finishing its work <code>Make&shy;Fork</code> of the child thread will return to this method which will release the thread and get it back to the pool when work is over.</p>
<div class="paragraph-right-side">34</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> AdvancedThreading_Unmanaged::InForkedThread(StackInfo * stackCopy)
{
    StackInfo copy;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">35</div>
<p>First&shy;, we save the values of working regis&shy;ters to restore them pain&shy;lessly after <code>Make&shy;Fork</code> finishes its work. To have a minimal impact on regis&shy;ters in the future, we unload the para&shy;me&shy;ters trans&shy;ferred to us on our stack. They will be accessed through <code>SS:ESP</code> only , which will be predic&shy;table for us.</p>
<div class="paragraph-right-side">35</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">short</span> CS_EIP[3];

    <span style="color:Green;">// Save original registers to restore</span>
    __asm pushad

    <span style="color:Green;">// safe copy w-out changing registers</span>
    <span style="color:Blue;">for</span>(<span style="color:Blue;">int</span> i = 0; i &lt; <span style="color:Blue;">sizeof</span>(StackInfo); i++)
        ((<span style="color:Blue;">byte</span> *)&amp;copy)[i] = ((<span style="color:Blue;">byte</span> *)stackCopy)[i];

    <span style="color:Green;">// Setup FWORD for far jmp</span>
    *(<span style="color:Blue;">int</span>*)CS_EIP = copy.EIP;
    CS_EIP[2] = copy.CS;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">36</div>
<p>Our next task is to correct the <code>EBP</code> values in a stack copy that form a single linked list of frames, so they would reflect their future posi&shy;tions. To do this, we calcu&shy;late the offset between the add&shy;ress of our thread stack and the parent thread stack, the offset between the copy of the parent thread stack range and the parent thread itself.</p>
<div class="paragraph-right-side">36</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// calculate ranges</span>
    <span style="color:Blue;">int</span> beg = (<span style="color:Blue;">int</span>)copy.frame;
    <span style="color:Blue;">int</span> size = copy.size;
    <span style="color:Blue;">int</span> baseFrom = (<span style="color:Blue;">int</span>) copy.origStackStart;
    <span style="color:Blue;">int</span> baseTo = baseFrom + (<span style="color:Blue;">int</span>)copy.origStackSize;
    <span style="color:Blue;">int</span> ESPr;

    __asm mov ESPr, ESP

    <span style="color:Green;">// target = EBP[ - locals - EBP - ret - whole stack frames copy]</span>
    <span style="color:Blue;">int</span> targetToCopy = ESPr - 8 - size;

    <span style="color:Green;">// the offset between the parent stack and the current stack;</span>
    <span style="color:Blue;">int</span> delta_to_target = (<span style="color:Blue;">int</span>)targetToCopy - (<span style="color:Blue;">int</span>)copy.EBP;

    <span style="color:Green;">// the offset between the parent stack start and its copy;</span>
    <span style="color:Blue;">int</span> delta_to_copy = (<span style="color:Blue;">int</span>)copy.frame - (<span style="color:Blue;">int</span>)copy.EBP;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">37</div>
<p>Using this data we follow the copy of the stack within a cycle and correct the addresses to their future values.</p>
<div class="paragraph-right-side">37</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// In the stack copy we have many saved EPBs which form a single linked list.</span>
    <span style="color:Green;">// We need to fix the copy to make these pointers appropriate for our thread stack.</span>
    <span style="color:Blue;">int</span> ebp_cur = beg;
    <span style="color:Blue;">while</span>(<span style="color:Blue;">true</span>)
    {
        <span style="color:Blue;">int</span> val = *(<span style="color:Blue;">int</span>*)ebp_cur;

        <span style="color:Blue;">if</span>(baseFrom &lt;= val &amp;&amp; val &lt; baseTo)
        {
            <span style="color:Blue;">int</span> localOffset = val + delta_to_copy;
            *(<span style="color:Blue;">int</span> *)ebp_cur += delta_to_target;
            ebp_cur = localOffset;
        }
        <span style="color:Blue;">else</span>
            <span style="color:Blue;">break</span>;
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">38</div>
<p>When the single linked list is corrected, we should update the values of regis&shy;ters in their copy, so that if it contains refe&shy;rences to the stack, they will be updated too. The algo&shy;rithm here is not precise at all. Because if an inapp&shy;rop&shy;riate value from the stack add&shy;ress range appears there by some reason, it will be corrected by mistake. However&shy;, our task is just to unders&shy;tand the functi&shy;o&shy;ning of a thread stack and that’s why this tech&shy;nique is suitable for this purpose.</p>
<div class="paragraph-right-side">38</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    CHECKREF(EAX);
    CHECKREF(EBX);
    CHECKREF(ECX);
    CHECKREF(EDX);

    CHECKREF(ESI);
    CHECKREF(EDI);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">39</div>
<p>Now&shy;, the most impor&shy;tant part. When we add the copy of the parent stack to the end of our stack, everything will be OK until <code>Make&shy;Fork</code> in the child thread tries to exit (make <code>return</code>). We need to show it where it should exit to. To do this, we also imi&shy;tate the call of <code>Make&shy;Fork</code> itself from this method. We put the add&shy;ress of <code>Restore&shy;Point&shy;After&shy;Cloned&shy;Exited</code> label on the stack as if the <code>call</code> processor instr&shy;uc&shy;tion puts the return add&shy;ress and the current <code>EBP</code> to the stack, imi&shy;ta&shy;ting the buil&shy;ding of a single linked list of method frames chains. Then we put a copy of the parent stack on the stack using the usual <code>push</code> ope&shy;ra&shy;tion, thus repre&shy;sen&shy;ting all methods, called in the parent stack from the <code>Make&shy;Fork</code> method inclu&shy;ding itself. The stack is ready!</p>
<div class="paragraph-right-side">39</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// prepare for __asm nret</span>
    __asm push offset RestorePointAfterClonedExited
    __asm push EBP

    <span style="color:Blue;">for</span>(<span style="color:Blue;">int</span> i = (size &gt;&gt; 2) - 1; i &gt;= 0; i--)
    {
        <span style="color:Blue;">int</span> val = ((<span style="color:Blue;">int</span> *)beg)[i];
        __asm push val;
    };
</pre></div>
</div>
<p>Next&shy;, we should restore regis&shy;ters.</p>
<pre><code>    // restore registers, push 1 for Fork() and jmp
    _asm {
        push copy.EAX
        push copy.EBX
        push copy.ECX
        push copy.EDX
        push copy.ESI
        push copy.EDI
        pop EDI
        pop ESI
        pop EDX
        pop ECX
        pop EBX
        pop EAX
</code></pre>
<div class="paragraph-container">
<div class="paragraph-left-side">40</div>
<p>Now&shy;, it’s time to remember the strange code where we put <code>0</code> on stack and then checked for <code>0</code>. In this thread, we put <code>1</code> and make a long <code>jmp</code> to the <code>Fork&shy;Impl</code> method code. Because we are exactly there accor&shy;ding to the stack, but in fact, we are still here. When we get there <code>Fork&shy;Impl</code> will recog&shy;nize the change of a thread and will exit to the <code>Make&shy;Fork</code> method, which will get to the <code>Restore&shy;Point&shy;After&shy;Cloned&shy;Exited</code> after finishing its work because earlier we imi&shy;tated the call of <code>Make&shy;Fork</code> from this point. By resto&shy;ring the regis&shy;ters to the state of “just called from <code>Thread&shy;Pool</code>” we finish work, giving the thread to the pool.</p>
<div class="paragraph-right-side">40</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
        push 1
        jmp fword ptr CS_EIP
    }

RestorePointAfterClonedExited:

    <span style="color:Green;">// Restore original registers</span>
    __asm popad
    <span style="color:Blue;">return</span>;
 }
</pre></div>
</div>
<p>Let’s check. This screenshot is made before a thread cloning call:</p>
<div class="image-container"><p><img src="../imgs/ThreadStack/ForkBeforeEnter.png" alt="" /></p>
</div>
<p>This screenshot is made after:</p>
<div class="image-container"><p><img src="../imgs/ThreadStack/ForkAfterEnter.png" alt="" /></p>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">41</div>
<p>As we see now, there are two threads in <code>Fork&shy;Impl</code> instead of one. Both of them exited this method.</p>
<div class="paragraph-right-side">41</div>
</div>
<h1 id="a-few-words-about-a-lower-level">A few words about a lower level</h1>
<div class="paragraph-container">
<div class="paragraph-left-side">42</div>
<p>If we look at an even lower level, we will recall that the memory is, in fact, virtual and it is divided into 8 and 4 Kb pages. Each of these pages can either exist or not exist physically. If it exists, it can be mapped to a file or real RAM. It is exactly this virtu&shy;a&shy;li&shy;za&shy;tion mech&shy;anism that allows appli&shy;ca&shy;tions to have sepa&shy;rate memory and provides secu&shy;rity levels between an appli&shy;ca&shy;tion and an ope&shy;ra&shy;ting system. What does this have to do with a thread stack? As any other random access memory of an appli&shy;ca&shy;tion a thread stack is its part and also consists of 4 and 8 Kb pages. On the sides of a range allo&shy;cated for the stack, there are two pages. An attempt to access these pages will produce an excep&shy;tion, notif&shy;ying an OS that an appli&shy;ca&shy;tion tries to add&shy;ress an unal&shy;lo&shy;cated memory range. The actu&shy;ally allo&shy;cated ranges inside this region are those pages which the appli&shy;ca&shy;tion addressed: if the appli&shy;ca&shy;tion allo&shy;cates 2 Mb of memory for a thread, that doesn’t mean they will be allo&shy;cated straight away. They will be allo&shy;cated on demand: if a thread stack will grow up to 1 Mb&shy;, that will mean that the appli&shy;ca&shy;tion got exactly 1 Mb of RAM for the stack.</p>
<div class="paragraph-right-side">42</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">43</div>
<p>When an appli&shy;ca&shy;tion allo&shy;cates memory for local vari&shy;ables, two things happen: the value of ESP register grows and the memory for vari&shy;ables is set to null. That’s why when you write a recur&shy;sive method which enters infi&shy;nite recur&shy;sion, you will get <code>Stack&shy;Overflow&shy;Exception</code>: acqu&shy;i&shy;ring the entire memory allo&shy;cated for the stack (the entire ava&shy;ilable region), you will run into a special Guard Page the access to which will make an ope&shy;ra&shy;ting system ini&shy;tiate <code>Stack&shy;Overflow</code> at the OS level. It will pass to .NET and will be caught resul&shy;ting in <code>Stack&shy;Overflow&shy;Exception</code> for a .NET appli&shy;ca&shy;tion.</p>
<div class="paragraph-right-side">43</div>
</div>
<h1 id="the-memory-allocation-on-the-stack-stackalloc">The memory allo&shy;ca&shy;tion on the stack: <code>stac&shy;kalloc</code></h1>
<div class="paragraph-container">
<div class="paragraph-left-side">44</div>
<p>In C# there is a quite inte&shy;res&shy;ting and rarely used keyword <code>stac&shy;kalloc</code>. It is so rarely used in code (I’d rather say &laquo;never&raquo; instead of &laquo;rarely&raquo;) that it’s hard to find a suitable example of its use and it’s even harder to create an example because if it’s seldom used the expe&shy;ri&shy;ence of working with it is too little. Why&shy;? Because for those who try to figure out what this instr&shy;uc&shy;tion does, <code>stac&shy;kalloc</code> becomes more thr&shy;ea&shy;tening than useful, as the dark side of <code>stac&shy;kalloc</code> is unsafe code. The result it returns is not a managed pointer: the value is a usual pointer to the range of unpro&shy;tected memory. And if you make an entry at this add&shy;ress after a method finishes its work, you will start writing to local vari&shy;ables of some method or will overw&shy;rite the return add&shy;ress from the method, and an appli&shy;ca&shy;tion will finish work with an error. However&shy;, our task is to get to hidden corners and figure out what they hide. Also&shy;, we should unders&shy;tand that this inst&shy;rument was created on purpose and not just to spill our water and slip on it. Quite oppo&shy;site: we were giving this inst&shy;rument to use it and create really quick soft&shy;ware. Did I inspire you? Then&shy;, let’s start.</p>
<div class="paragraph-right-side">44</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">45</div>
<p>To find the approp&shy;riate use cases for this keyword, we should turn to its authors, i.e. Micro&shy;soft and see how they use it. We can do this with the help of a full-text search in the  <a href="https://github.com/dotnet/coreclr">coreclr repo&shy;si&shy;tory</a>. Besides diffe&shy;rent tests of the keyword itself, we will find no more than 25 use cases of this keyword in the library code. I hope I moti&shy;vated you enough in the previous parag&shy;raph and you won’t stop rea&shy;ding my work when you see such a small number. To say the truth, the CLR team is more far-sighted and profes&shy;si&shy;onal than the .NET Frame&shy;work team. And if they created something, it should help us a lot. But if it is not used in .NET Frame&shy;work&hellip; Well&shy;, we can suppose that not all engi&shy;neers there know there is such a powerful opti&shy;mi&shy;za&shy;tion inst&shy;rument. Otherwise&shy;, its would be more widely used.</p>
<div class="paragraph-right-side">45</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">46</div>
<p><strong>Interop&shy;.Read&shy;Dir class</strong>
<a href="https://github.com/dotnet/coreclr/blob/b29f6328510207970763580d6f4db864e4b198af/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs#L71-L83">/src/mscorlib/shared/Interop&shy;/Unix&shy;/System&shy;.Native&shy;/Interop&shy;.Read&shy;Dir&shy;.cs</a></p>
<div class="paragraph-right-side">46</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">unsafe</span>
{
    <span style="color:Green;">// s_readBufferSize is zero when the native implementation does not support reading into a buffer.</span>
    <span style="color:Blue;">byte</span>* buffer = <span style="color:Blue;">stackalloc</span> <span style="color:Blue;">byte</span>[s_readBufferSize];
    InternalDirectoryEntry temp;
    <span style="color:Blue;">int</span> ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, <span style="color:Blue;">out</span> temp);
    <span style="color:Green;">// We copy data into DirectoryEntry to ensure there are no dangling references.</span>
    outputEntry = ret == 0 ?
                <span style="color:Blue;">new</span> DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } :
                <span style="color:Blue;">default</span>(DirectoryEntry);

    <span style="color:Blue;">return</span> ret;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">47</div>
<p>What is <code>stac&shy;kalloc</code> used here for? As we see the code goes to the unsafe method after memory allo&shy;ca&shy;tion to fill the created buffer with data. That means a memory range that the unsafe method needs for a record is allo&shy;cated right on the stack dyna&shy;mi&shy;cally. It’s a great opti&shy;mi&shy;za&shy;tion, given that alter&shy;na&shy;tives are to get a memory range from Windows or fixed (pinned) .NET array that besides burde&shy;ning the heap also burdens the GC because the array is fixed, so the GC wouldn’t move it when acces&shy;sing its data. By allo&shy;ca&shy;ting memory on the stack we risk nothing: the allo&shy;ca&shy;tion is almost instan&shy;ta&shy;neous and we can easily fill it with data and exit this method. And together with the exit from the method, its stack frame will disap&shy;pear. As a result, we save a lot of time.</p>
<div class="paragraph-right-side">47</div>
</div>
<p>Let’s look at another example:</p>
<div class="paragraph-container">
<div class="paragraph-left-side">48</div>
<p><strong>Class Number&shy;.Formatting::Format&shy;Decimal</strong>
<a href="https://github.com/dotnet/coreclr/blob/efebb38f3c18425c57f94ff910a50e038d13c848/src/mscorlib/shared/System/Number.Formatting.cs#L287-L311">/src/mscorlib/shared/System&shy;/Number&shy;.Formatting&shy;.cs</a></p>
<div class="paragraph-right-side">48</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">static</span> <span style="color:Blue;">string</span> FormatDecimal(<span style="color:Blue;">decimal</span> value, ReadOnlySpan&lt;<span style="color:Blue;">char</span>&gt; format, NumberFormatInfo info)
{
    <span style="color:Blue;">char</span> fmt = ParseFormatSpecifier(format, <span style="color:Blue;">out</span> <span style="color:Blue;">int</span> digits);

    NumberBuffer number = <span style="color:Blue;">default</span>;
    DecimalToNumber(value, <span style="color:Blue;">ref</span> number);

    ValueStringBuilder sb;
    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Blue;">char</span>* stackPtr = <span style="color:Blue;">stackalloc</span> <span style="color:Blue;">char</span>[CharStackBufferSize];
        sb = <span style="color:Blue;">new</span> ValueStringBuilder(<span style="color:Blue;">new</span> Span&lt;<span style="color:Blue;">char</span>&gt;(stackPtr, CharStackBufferSize));
    }

    <span style="color:Blue;">if</span> (fmt != 0)
    {
        NumberToString(<span style="color:Blue;">ref</span> sb, <span style="color:Blue;">ref</span> number, fmt, digits, info, isDecimal:<span style="color:Blue;">true</span>);
    }
    <span style="color:Blue;">else</span>
    {
        NumberToStringFormat(<span style="color:Blue;">ref</span> sb, <span style="color:Blue;">ref</span> number, format, info);
    }

    <span style="color:Blue;">return</span> sb.ToString();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">49</div>
<p>This is an example of number format&shy;ting which is based on an even more inte&shy;res&shy;ting example of a class <a href="https://github.com/dotnet/coreclr/blob/efebb38f3c18425c57f94ff910a50e038d13c848/src/mscorlib/shared/System/Text/ValueStringBuilder.cs">Value&shy;String&shy;Builder</a>, working on the basis of <code>Span&shy;<T></code>. The essence of this code section is that it doesn’t use the allo&shy;ca&shy;tion of memory for the char&shy;acter accu&shy;mu&shy;la&shy;tion buffer to collect the textual repre&shy;sen&shy;ta&shy;tion of a formatted number as quickly as possible. This wonderful code allo&shy;cates memory right in the method stack frame, ensu&shy;ring no need for the GC to collect garbage in String&shy;Builder instances if the method worked on its basis. The method run time also decre&shy;ases: the memory allo&shy;ca&shy;tion in the heap also takes time. Besides&shy;, using <code>Span&shy;<T></code> type instead of bare poin&shy;ters make the work of <code>stac&shy;kalloc</code> based code look safer.</p>
<div class="paragraph-right-side">49</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">50</div>
<p>Also&shy;, before making conc&shy;lu&shy;sions I should show what you mustn’t do. In other words, I will show which code can work well but will fail at the worst possible time. Let’s look at the example:</p>
<div class="paragraph-right-side">50</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> GenerateNoise(<span style="color:Blue;">int</span> noiseLength)
{
    <span style="color:Blue;">var</span> buf = <span style="color:Blue;">new</span> Span(<span style="color:Blue;">stackalloc</span> <span style="color:Blue;">int</span>[noiseLength]);
    <span style="color:Green;">// generate noise</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">51</div>
<p>This little code can cause a lot of troubles: you can’t just pass the size to allo&shy;cate memory on the stack from the outside. If you need a size which is set exter&shy;nally, accept the buffer itself:</p>
<div class="paragraph-right-side">51</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> GenerateNoise(Span&lt;<span style="color:Blue;">int</span>&gt; noiseBuf)
{
    <span style="color:Green;">// generate noise</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">52</div>
<p>This code is more infor&shy;ma&shy;tive as it makes a user think and be careful when choosing numbers. In case of bad luck, the first variant can produce <code>Stack&shy;Overflow&shy;Exception</code> with a method not being quite deep into a thread stack: it is enough to pass a big number as a para&shy;meter. The second variant when you can actu&shy;ally accept the size is when this method is called in specific cases and the calling code &laquo;knows&raquo; the working algo&shy;rithm of this method. Without knowing the internal struc&shy;ture of a method there is no specific idea about the possible range for <code>noi&shy;se&shy;Length</code> and as a result errors can occur.</p>
<div class="paragraph-right-side">52</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">53</div>
<p>The second example which I see is that if we misde&shy;ter&shy;mined the size of a buffer which we allo&shy;cated on the stack and we don’t want to decrease the effi&shy;ci&shy;ency of work, we can take a number of ways: allo&shy;cate more memory on the stack or allo&shy;cate it in the heap. The second variant will probably be more approp&shy;riate in most cases (this is what was done in the case of <code>Value&shy;String&shy;Buffer</code>) as it is safer in respect of getting <code>Stack&shy;Overflow&shy;Exception</code>.</p>
<div class="paragraph-right-side">53</div>
</div>
<h2 id="conclusions-on-stackalloc">Conc&shy;lu&shy;sions on <code>stac&shy;kalloc</code></h2>
<p>So&shy;, what is <code>stac&shy;kalloc</code> best used for?</p>
<ul>
<li><p>To work with unma&shy;naged code when it is neces&shy;sary to fill some data buffer with an unma&shy;naged method or accept some data buffer from an unma&shy;naged method which will be used during the method body life&shy;time.</p>
</li>
<li><p>For methods that need an array, but again while these methods work. The example with format&shy;ting is very good: this method can be called too often to avoid allo&shy;ca&shy;ting tempo&shy;rary arrays in the heap.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">54</div>
<p>The use of this allo&shy;cator can signi&shy;fi&shy;cantly increase the perfor&shy;mance of your appli&shy;ca&shy;tions.</p>
<div class="paragraph-right-side">54</div>
</div>
<h1 id="conclusions-on-section">Conc&shy;lu&shy;sions on section</h1>
<div class="paragraph-container">
<div class="paragraph-left-side">55</div>
<p>Of course in general terms, we don’t need to edit the stack in produc&shy;tion code: only if we want to spend our time solving an inte&shy;res&shy;ting problem. However&shy;, unders&shy;tan&shy;ding its struc&shy;ture shows us that it’s appa&shy;rently simple to edit it and get data from it. I mean if you create an API to extend the functi&shy;o&shy;na&shy;lity of your appli&shy;ca&shy;tion and if this API doesn’t give access to some data, that doesn’t mean that this data can’t be accessed. That’s why always check that your appli&shy;ca&shy;tion is hack proof.</p>
<div class="paragraph-right-side">55</div>
</div>

        </div>
        <footer>
            <div class="footer-container">
                <div class="footer-wrap">
                    <img src="../res/img/logo-w-noindex.svg">
                    <p>
                        <a class="footer-link" target="_blank" href="mailto:sidristij@clrium.ru"><i class="far fa-envelope" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://vk.com/clrium"><i class="fab fa-vk" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://youtube.com/clrium"><i class="fab fa-youtube" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://github.com/clrium"><i class="fab fa-github" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="skype:stanislav.sidristyi"><i class="fab fa-skype" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://t.me/clrium_group"><i class="fab fa-telegram" aria-hidden="true"></i></a>
                    </p>
                </div>
            </div>
        </footer>
    </div>
</body>
</html>