<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Platform Architecture</title>
</head>
<body>
    <script src="../res/jquery.js"></script>
    <link rel="stylesheet" href="../res/bootstrap.css">
    <link rel="stylesheet" href="../res/awesome.css">
    <style>

body {
    font-family: PF Regal,Georgia,serif;
    font-size: 16pt;
    font-weight: 300;
    padding-top: 4em;
    background-color: #fdfdfd;
}

.book-title-container {
    width: 100%;
    text-align: center;
    margin: 73px 0 110px 0;
}

.book-title {
    font-size: 57pt;
    margin: 50px 0 70px 0;
    user-select: none;
}
.book-part-title-block {
    display: inline-block;
}
.book-part-title {
    font-size: 21pt;
    color: #656ab6;
    margin: 0 7px;
}

.book-part-title:hover {
    box-shadow: inset 0 -1px #007bff;
    text-decoration: none;
}

.book-superheading-title {
    font-size: 15pt;
    margin: 0 7px;
    color: #656ab6;
}

.article-container
{
    width: 62%;
}

strong {
    font-weight: 500;
}

p, li {
    margin: 0 0 1em;
    line-height: 1.5em;
    font-family: inherit;
}

ol, li {
    margin-top: 1em;
    margin-bottom: 1em;
}

ol {
    padding-left: 1.21em;
}

ul  {
    padding-left: 1em;
}

ol li, ul li {
    padding-left: 0.5em;	
    font-family: inherit;
    text-align: justify;
}

table {
    margin: 30px 0;
    width: 100%;
}

thead {
    background-color: aliceblue;
}

table th {
    font-weight: 400;
}

table td, table th {
    padding: 7px;
    border-top: solid darkgrey 1px;
    border-bottom: solid darkgrey 1px;
    border-right: dotted darkgray 1px;
    border-left: dotted darkgray 1px;
    font-size: smaller;
}

code, *[class*='lang-'] span, *[class*='lang-'] pre {
    font-family: JB Mono, monospace !important;
}

*[class*='lang-'] {
    padding: 0px 0px 25px 0px;
    font-size: 0.75em;
}


*[class*='lang-'] > div, pre > code {
    border-left-color: #eee;
    border-left-style: dotted;
    border-left-width: 3px;
    padding-left: 25px;
    display: block;
    padding-top: 20px;
    padding-bottom: 20px;
}

*[class*='lang-'] > div pre, pre > code pre {
    margin-bottom: 0;
}

p code:not(.highlight), li code:not(.highlight) {
    font-size: 0.7em;
    border: gainsboro;
    border-width: 1px;
    border-style: solid;
    padding: 3px;
    color: darkslateblue;
}

code.highlight {
    font-family: inherit !important;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
}

p code.highlight, li code.highlight {
    padding: 4px;
    background-color: #ffffa1;
}

.wide {
    width:140%;
}

p a, li a {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #b88b59;
}

p a:hover, li a:hover {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #0056b3;
}

blockquote h5 {
    background-color: aquamarine;
    margin: 16px 0 16px -20px;
    padding: 15px 30px 15px;
}

p img {
    width: 95%;
}

blockquote 
{
    padding-left: 0.4em;
    border-left: 0.5em solid rgba(0,0,0,.08);
    font-style: italic;
}

blockquote.big-quote, 
blockquote.breadcrumbs 
{
    background-color: transparent;
    padding: 0;
    border-left: none;
    font-style: normal;
}

blockquote.breadcrumbs, blockquote.breadcrumbs  p
{
    margin: 0;
    padding: 0;
}

blockquote p {
    padding: 1em 1em 1em 0.6em;
    font-family: inherit;
}

blockquote p code {
    font-family: consolas, monospace;
    font-size: 17px;
    padding: 4px 6px;
}

blockquote p em {
    font-weight: 400;
}

blockquote.big-quote > p {
    margin: 0.7em 0 0.7em 0;
    font-family: Charter;
    font-size: 2.5em;
    padding: 0;
    width: 130%;
    line-height: 1em;
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
    padding: 0;
    font-weight: 400;
    font-family: inherit;
}

h1 {
    font-size: 2.2em;
    font-family: Charter,Georgia,serif;
    font-weight: 300;
    margin: 1.8em 0 1.8em 0;
    text-align: center;
    width: 140%;
}

h2 {
    margin-top: 2em;
    font-family: Charter, Arial, Helvetica Neue, sans-serif;
    font-size: 1.25em;
    width: 70%;
}

h3 {
    margin: 1.5em 0 0 0;
    font-size: 1.3em;
    font-weight: 300;
    font-style: italic;
}

h4 {
    margin: 20px 0 10px 0;
    font-size: 16pt;
    font-weight: 500;
    font-style: italic;
}

/* Sidenotes */

.aside-container {
    position: relative;
}
.aside-container p {
    position: relative;
    top: 9px;
}

.aside-container > .aside-side-container {
    display: block;
    position: absolute;
    top: 12px;
    left: 96%;
    width: 34%;
    font-size: 12pt;
    line-height: 20px;
    margin-left: 100px;
    z-index: 1000;
}

.aside-container > .aside-side-container p {
    line-height: 24px;
    font-size: 13pt;
    margin: 0 0 13px 0;
}

.side-regular-block p {
    top: 0;
}

/* Music side player */
.aside-side-container .music-player {
    width: 100%;
    height: 400px;
}

/* media block after h1 */
.aside-container h1 + .aside-side-container.side-media-block h2 {
    margin: 7em 0 1em 0;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-weight: 600;
}

.aside-side-container > li {
    display: block;
    font-family: Charter;
}

.aside-side-container > li ul, .aside-side-container > li ol {
    padding-left: 30px;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.aside-side-container > li li {
    padding-left: 6px;
    margin: 0 0 6px;
    line-height: 22px;

    font-family: Charter;
}

.aside-side-container p {
    line-height: 25px;
    font-size: 13pt;
    margin: 0 0 15px 0;
}

.aside-side-container blockquote {
    border: aliceblue;
    border-left-style: solid;
}

/* Paragraphs numbering */
.paragraph-container {
    position: relative;
}
.paragraph-container p {
    position: relative;
    top: 9px;
}

.paragraph-container p, .aside-container > p {
    text-align: justify;
}

.paragraph-container > .paragraph-left-side, .paragraph-container > .paragraph-right-side  {
    font-family: JB Mono, consolas;
    display: block;
    position: absolute;
    top: 17px;
    font-size: 10pt;
    line-height: 20px;
    color: #86abc473;
    z-index: 1000;
}
.paragraph-container > .paragraph-left-side {
    display: none;
    left: -2.1cm;
    width: 35px;
    user-select: none;
}

.paragraph-container > .paragraph-right-side  {
    display: none;
    left: 100%;
    width: 35px;
    padding-left: 45px;
    user-select: none;
}

.article-container
{
    width: 70%;
}

/* X_MENU */
.menu-title {
    text-align: center;
    margin: 35px 50px 35px 50px;
    font-size: 24pt;
    font-family: Charter;
}

.menu-container ol {
    margin: 0;
    padding: 0;
}

.menu-container ol li {
    margin: 0;
    padding: 0;
}

.header {
    height: 2.5em;
    background-color: white;
    position: relative;
    z-index: 1500;
    width: 100%;
    display: flex;
    justify-content: space-between;
    transition: all 1s;
    top: 0;
    box-shadow: 1px -4px 20px rgba(0, 0, 0, .1);
}

.fixed {
    position: fixed !important;
}

.header > .menu {
    pointer-events: auto;
    float: right;
    height: 40px;
    font-family: Charter, 'Helvetica Neue', Arial, sans-serif;
    font-size: 1em;
    color: #fff;
    margin-top:40px;
    margin-right:40px;
}

.menu a {
    color: #fff;
}
.menu a:hover {
    text-decoration: none;
    color: #fff;
}

#menu__toggle {
    opacity: 0;
}

#menu__toggle:checked ~ .menu__btn > span {
    transform: rotate(45deg);
}
#menu__toggle:checked ~ .menu__btn > span::before {
    top: 0;
    transform: rotate(0);
    background-color: black
}
#menu__toggle:checked ~ .menu__btn > span::after {
    top: 0;
    transform: rotate(90deg);
    background-color: black
}
#menu__toggle:checked ~ .menu__box {
    visibility: visible;
    right: 0;
}

.menu__btn {
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    right: 0;
    width: 2.5em;
    height: 2.5em;
    cursor: pointer;
    z-index: 1;
    margin: 0;
    padding: 0.7em;
}

.menu__btn > span,
.menu__btn > span::before,
.menu__btn > span::after {
    display: block;
    position: absolute;

    width: 1.1em;
    height: 1px;

    background-color: black;

    transition-duration: .25s;
}
.menu__btn > span::before {
    content: '';
    top: -8px;
}
.menu__btn > span::after {
    content: '';
    top: 8px;
}

.menu__box {
    display: block;
    position: fixed;
    visibility: hidden;
    top: 0;
    right: -100%;

    width: 100%;
    height: 100%;

    margin: 0;
    padding: 80px 0;

    list-style: none;

    background-color: white;
    box-shadow: 1px 0px 6px rgba(0, 0, 0, .2);

    transition-duration: .25s;

    overflow-y: auto;
}
.menu__box li a:hover {
    text-decoration: none;
    color: inherit;
}
.menu__list {
    font-size: 0.9em;
    margin: 0 2em 0 2em;
}
.menu__list li {
    text-align: left;
}

/* X_HEADER */

.conflogo {
    margin: 0.5em 0 0 0.8em;
    font-size: 1.1em;
    font-family: Charter;
    user-select: none;
}

.invisible {
    display: none;
}

.header > .menu > div {
    display: inline;
    margin-left: 10px;
    margin-right: 10px;
}

.menu__header_current
{
    text-align: center;
    font-size: 2em;
    margin: 0 0 1em 0;
}

.menu__header_total
{
    text-align: center;
    font-size: 2.4em;
    margin: 1.7em 0 0.3em 0;
}
.menu__header_list 
{
    padding: 0;
    margin-top: 0;
    margin-left: 0;
    margin-right: 0;
}
.menu__header_list > li 
{
    display: inline-block;
    width: 100%;
    margin: 0;
    text-align: center;
    font-family: charter;
}
.menu__header_total_sub
{
    font-size: 1.4em;
    margin: 2em 0 1em 0;
}
.menu__header_total_sub2
{
    font-size: 1.1em;
    margin: 1.5em 0 0.6em 1em;
    text-align: left;
}
/* X_FOOTER */

footer {
    margin-top: 2em;
    background-color: black;
    height: 4em;
}

footer > div {
    box-shadow: 0px 2px 2px rgb(0, 0, 0);
}

.footer-container {
    height: 100%;
}

.footer-wrap {
    color: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 25px 0;
}

.footer-wrap p {
    margin: 0;
    padding: 0px;
    line-height: 1em;
}

.footer-container img {
    height: 1.6em;
    margin-top: auto;
    margin-bottom: auto;
}

.footer-link {
    color: white;
    margin: 0 7px;
    font-size: 1em;
    box-shadow: none;
}

.footer-link:hover {
    color: salmon;
    box-shadow: none;
}

/* MEDIA */
/* XXL */
@media (min-width: 1601px) {
    .book-container
    {
        max-width: 1200px;
        margin-left: auto;
        margin-right: auto;
    }
}

/* XL */
@media (max-width: 1600px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }
}

/* LG */
@media (max-width: 1400px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }

    blockquote.big-quote > p {
        font-size: 2em;
    }
}

/* > MD */
@media (min-width: 992px) {
    .hamburger-menu {
        display: none;
    }
}

/* MD */
@media (max-width: 991px) {
    
    h2 {
        width:80%;
    }

    .book-container
    {
        margin-left: 3cm;
        margin-right: 3cm;
    }
    
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    .book-title {
        font-size: 50pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 15pt;
    }                                     

    .article-container, h1 {
        width: 100%;
    }

    .aside-container p {
        top: 0;
    }

    .aside-container h1 + .aside-side-container.side-media-block h2 {
        display: none;
    }

    .wide {
        width: 100%;     
    }

    .side-regular-block {
        margin: 40px 10px;
        padding-left: 100px;
    }
    .aside-side-container .music-player {
        width: 100%;
        height: 100px;
    }
    .aside-side-container.side-media-block {
        padding: 17px 0;
    }
    .aside-side-container.side-media-block h2 {
        margin-top: 20px;
        font-size: 13pt;
        border: none;
    }

    .aside-container > .aside-side-container
    {
        position: relative;
        top: auto;
        left: auto;
        width: auto;
        height: auto;
        margin: 0;
        padding: 17px;
    }

    blockquote.big-quote > p {
        width: 100%;
        font-size: 2em;
    }

    .paragraph-container .paragraph-left-side {
        left: -55px;
    }

    body {
        font-size: 15pt;
    }

    p code:not(.highlight), li code:not(.highlight) {
        font-size: 11pt;
    }

    p, li {
        line-height: 30px;
    }
    
    li {
        margin: 0 0 10px 0;
    }

    .side-regular-block {
        border-radius: 5px;
        background-image: linear-gradient(180deg,hsla(0,0%,100%,0) 60%,#fff),linear-gradient(70deg,#dbedff 32%,#ebfff0);
        padding: 22px;
    }    

    .menu__list
    {
        margin-top: 0;
        margin-bottom: 0;
    }

    .menu__list, .menu__header_total_sub2
    {
        margin-left: auto;
        margin-right: auto;
        max-width: 800px;
        width: 80%;
    }

    .book-container 
    {
        position: absolute;
        padding: 0 3cm 0 3cm;
        overflow: scroll;
        overflow-x: auto;
        top: 2.5em;
        bottom: 0;
        width: 100%;
        margin: 0;
    }

    footer {
        margin-top: 2em;
        background-color: black;
        height: 4em;
    }

    footer > div {
        position: relative;
        margin: 0 -3cm;
        background: black;
        padding: 0 3cm;
    }
}

/* Smartphone horizontal - SM */
@media (max-width: 767px) {
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    h1 {
        margin: 1.8em 0em 1.8em 0.3em;
    }

    .book-title {
        font-size: 40pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 17pt;
    }

    .book-container {
        padding: 0 2.5cm;
    }
    ul {
        margin-left: 30px;
        margin-right: 30px;
        padding-left: 25px;
    }
    .paragraph-container > .paragraph-left-side {
	    display: block;
        top: 14px;
        font-size: 9pt;
    }
    .paragraph-container > .paragraph-right-side {
    	display: block;
        padding-left: 40px;
        top: 14px;
        font-size: 9pt;
    }
    .footer-container img {
        height: 1.3em;
    } 
}

@media (max-width: 630px) {
    .book-container {
        padding: 0 1.5cm;
    }
    .paragraph-container > .paragraph-left-side {
        left: -33px;
    }
    .paragraph-container > .paragraph-right-side {
        padding-left: 24px;
    }
}
/* Smartphone - XS */
@media (max-width: 575px) {
    .book-container {
        padding: 0 50px 0 30px;
    }
    ul {
        margin: 0;
        padding-left: 20px;
    }

    body {
        font-size: 13pt;
    }

    p code:not(.highlight), li code:not(.highlight) 
    {
        font-size: 10pt;
        padding: 3px;
    }
   
    p, li {
        line-height: 24px;
    }    
    
    .paragraph-container .paragraph-left-side 
    {
        display: none;        
    }
    .paragraph-container .paragraph-right-side 
    {
        padding-left: 21px;
        top: 14px;
	    font-size: 8pt;
    }
    .footer-container img {
        height: 1em;
    } 
    .menu__list {
        margin: 0 1em 0 1em;
    }
    .menu__header_total_sub2
    {
        margin: 1.5em 0 0.6em 1em;
    }
}

/* Fonts */

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-Bold.eot');
    src: local('../res/fonts/PFRegalTextPro-Bold'),
        url('../res/fonts/PFRegalTextPro-Bold.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-Bold.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-Medium.eot');
    src: local('../res/fonts/PFRegalTextPro-Medium'),
        url('../res/fonts/PFRegalTextPro-Medium.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-Medium.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-BlackItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-BlackItalic'),
        url('../res/fonts/PFRegalTextPro-BlackItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-BlackItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-BlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-Black.eot');
    src: local('../res/fonts/PFRegalTextPro-Black'),
        url('../res/fonts/PFRegalTextPro-Black.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-Black.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-Black.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal UBlack';
    src: url('../res/fonts/PFRegalTextPro-UBlack.eot');
    src: local('../res/fonts/PFRegalTextPro-UBlack'),
        url('../res/fonts/PFRegalTextPro-UBlack.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-UBlack.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-UBlack.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-MediumItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-MediumItalic'),
        url('../res/fonts/PFRegalTextPro-MediumItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-MediumItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-MediumItalic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-UBlackItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-UBlackItalic'),
        url('../res/fonts/PFRegalTextPro-UBlackItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-UBlackItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-UBlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-RegularAItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-RegularAItalic'),
        url('../res/fonts/PFRegalTextPro-RegularAItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-RegularAItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-RegularAItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-BoldItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-BoldItalic'),
        url('../res/fonts/PFRegalTextPro-BoldItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-BoldItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-BoldItalic.ttf') format('truetype');
    font-weight: bold;
    font-style: italic;
}

@font-face {
    font-family: 'Charter';
    src: url('../res/fonts/charter-regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}

/*  Regular B */
@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-RegularBItalic.eot');
    src: local('../res/fonts/PFRegalTextPro-RegularBItalic'),
        url('../res/fonts/PFRegalTextPro-RegularBItalic.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-RegularBItalic.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-RegularBItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../res/fonts/PFRegalTextPro-RegularB.eot');
    src: local('../res/fonts/PFRegalTextPro-RegularB'),
        url('../res/fonts/PFRegalTextPro-RegularB.woff2') format('woff2'),
        url('../res/fonts/PFRegalTextPro-RegularB.woff') format('woff'),
        url('../res/fonts/PFRegalTextPro-RegularB.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Regular.eot');
    src: local('../res/fonts/JetBrainsMono-Regular'),
        url('../res/fonts/JetBrainsMono-Regular.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Regular.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Regular.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Italic.eot');
    src: local('../res/fonts/JetBrainsMono-Italic'),
        url('../res/fonts/JetBrainsMono-Italic.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Italic.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Italic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Medium.eot');
    src: local('../res/fonts/JetBrainsMono-Medium'),
        url('../res/fonts/JetBrainsMono-Medium.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Medium.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../res/fonts/JetBrainsMono-Medium-Italic.eot');
    src: local('../res/fonts/JetBrainsMono-Medium-Italic'),
        url('../res/fonts/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
        url('../res/fonts/JetBrainsMono-Medium-Italic.woff') format('woff'),
        url('../res/fonts/JetBrainsMono-Medium-Italic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}
@font-face {
    font-family: 'Font Awesome 5 Free';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("../res/fonts/webfonts/fa-regular-400.eot");
    src: url("../res/fonts/webfonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), 
         url("../res/fonts/webfonts/fa-regular-400.woff2") format("woff2"), 
         url("../res/fonts/webfonts/fa-regular-400.woff") format("woff"), 
         url("../res/fonts/webfonts/fa-regular-400.ttf") format("truetype"), 
         url("../res/fonts/webfonts/fa-regular-400.svg#fontawesome") format("svg"); 
    font-display: swap;
}
    
.fa {
    font-family: 'Font Awesome 5 Free';
    font-weight: 400;
    font-display: swap;
}
@font-face {
  font-family: 'Font Awesome 5 Brands';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../res/fonts/fa-brands-400.eot");
  src: url("../res/fonts/fa-brands-400.eot?#iefix") format("embedded-opentype"), url("../res/fonts/fa-brands-400.woff2") format("woff2"), url("../res/fonts/fa-brands-400.woff") format("woff"), url("../res/fonts/fa-brands-400.ttf") format("truetype"), url("../res/fonts/fa-brands-400.svg#fontawesome") format("svg"); 
}

.fab {
  font-family: 'Font Awesome 5 Brands';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../res/fonts/fa-regular-400.eot");
  src: url("../res/fonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), url("../res/fonts/fa-regular-400.woff2") format("woff2"), url("../res/fonts/fa-regular-400.woff") format("woff"), url("../res/fonts/fa-regular-400.ttf") format("truetype"), url("../res/fonts/fa-regular-400.svg#fontawesome") format("svg"); 
}

.far {
  font-family: 'Font Awesome 5 Free';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 900;
  font-display: auto;
  src: url("../res/fonts/fa-solid-900.eot");
  src: url("../res/fonts/fa-solid-900.eot?#iefix") format("embedded-opentype"), url("../res/fonts/fa-solid-900.woff2") format("woff2"), url("../res/fonts/fa-solid-900.woff") format("woff"), url("../res/fonts/fa-solid-900.ttf") format("truetype"), url("../res/fonts/fa-solid-900.svg#fontawesome") format("svg"); 
}
</style>  
    <div class="book-title-container d-none d-lg-block">
        <div class="book-title">Knowledge Base</div>
        <div class="book-part-title-block">pt.1 <a href="..//ru/Memory/01-00-MemoryManagement-Intro.html" class="book-part-title">Управление памятью</a></div>
        <div class="book-part-title-block">pt.2 <a href="..//ru/Execution/02-00-ExecutionFlow-Intro.html" class="book-part-title">Поток исполнения команд</a></div>
        <br><a href="#" class="book-superheading-title">Обоснование выбора</a>
        / <a href="#" class="book-superheading-title">Упрощенное описание</a>
        / <a href="#" class="book-superheading-title">Подробное описание</a>
    </div>
    <header class="header fixed d-block d-lg-none">
        <p class="conflogo">KB</p> 

        <!-- mobile-menu -->

        <div class="hamburger-menu">
            <input id="menu__toggle" type="checkbox" />
            <label class="menu__btn" for="menu__toggle">
              <span></span>
            </label>
        
            <div class="menu__box">
                <p class="menu__header_current">На странице</p>
                <ol class="menu__list">
                    <li><a href="#copying" onclick="$('#menu__toggle').click(); return true;">
Copying</a></li>
<li><a href="#overridable-methods-and-inheritance" onclick="$('#menu__toggle').click(); return true;">
Overridable methods and inheritance</a></li>
<li><a href="#the-behavior-when-calling-instance-methods" onclick="$('#menu__toggle').click(); return true;">
The behavior when calling instance methods</a></li>
<li><a href="#the-capability-to-point-to-the-position-of-elements" onclick="$('#menu__toggle').click(); return true;">
The capability to point to the position of elements.</a></li>
<li><a href="#the-difference-in-allocation" onclick="$('#menu__toggle').click(); return true;">
The difference in allocation</a></li>
<li><a href="#the-choice-between-a-class-or-a-structure" onclick="$('#menu__toggle').click(); return true;">
The choice between a class or a structure</a></li>
<li><a href="#the-object-base-type-and-implementation-of-interfaces.boxing" onclick="$('#menu__toggle').click(); return true;">
The Object base type and implementation of interfaces. Boxing</a></li>
<li><a href="#going-deeper-in-boxing" onclick="$('#menu__toggle').click(); return true;">
Going deeper in boxing</a></li>
<li><a href="#what-if-you-want-to-see-boxing-personally" onclick="$('#menu__toggle').click(); return true;">
What if you want to see boxing personally?</a></li>
<li><a href="#questions" onclick="$('#menu__toggle').click(); return true;">
Questions</a></li>
<li><a href="#references" onclick="$('#menu__toggle').click(); return true;">
References</a></li>

                </ol>
                <p class="menu__header_total">Содержание</p>
                <ul class="menu__header_list">
                    <li>
                        <p class="menu__header_total_sub">
                            Управление памятью
                        </p>
                        <p class="menu__header_total_sub2">
                            Теоретические вопросы:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="..//ru/Memory/01-00-MemoryManagement-Intro.html">
                                Общие слова
                            </a></p></li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-02-MemoryManagement-Basics.html">Введение в управление памятью</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-04-MemoryManagement-ThreadStack.html">Стек потока</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-06-MemoryManagement-EntitiesLifetime.html">Время жизни сущности</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-08-MemoryManagement-RefVsValueTypes.html">RefTypes, ValueTypes, Boxing &amp; Unboxing</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-10-MemoryManagement-IDisposable.html">Шаблон Disposable</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-12-MemoryManagement-Finalizer.html">Финализация</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="..//ru/Memory/01-14-MemoryManagement-Results.html">Выводы</a></p>
                            </li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Практические вопросы:
                        </p>
                        <ol class="menu__list" start="9">
                            <li><p><a href="..//ru/Memory/02-02-MemoryManagement-MemorySpan.html">
                                Memory&lt;T&gt;, Span&lt;T&gt;
                            </a></p></li>
                        </ol> 
                    </li>
                    <li>
                        <p class="menu__header_total_sub">
                            Поток исполнения команд
                        </p>
                        <p class="menu__header_total_sub2">
                            Многопоточность:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="..//ru/Execution/1-Threads/1-OS/1-threadsScheduling.html">
                                Потоки и планирование потоков
                            </a></p></li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Искл­юч­ител­ьные си­ту­а­ции:
                        </p>
                        <ol class="menu__list" start="2">
                            <li><p><a href="..//ru/Execution/2-ExceptionalFlow/1-Exceptions-Intro.html">
                                Введение в исключительные ситуации
                            </a></p></li>
                            <li><p><a href="..//ru/Execution/2-ExceptionalFlow/2-Exceptions-Architecture.html">
                                Архитектура исключительной ситуации
                            </a></p></li>
                            <li><p><a href="..//ru/Execution/2-ExceptionalFlow/3-Exceptions-Events.html">
                                События об исключительных ситуациях
                            </a></p></li>
                            <li><p><a href="..//ru/Execution/2-ExceptionalFlow/4-Exceptions-Types.html">
                                Виды исключительных ситуаций
                            </a></p></li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
    </header>

    <div class="book-container">
        <div class="article-container">
            <!--<p class="d-xs-block d-sm-none">XS</p>
            <p class="d-none d-xs-block d-sm-none">SM</p>
            <p class="d-none d-sm-block d-md-none">MD</p>
            <p class="d-none d-lg-block d-xl-none">LG</p>
            <p class="d-none d-xl-block">XL</p> -->
            <h1 id="reference-types-vs-value-types">Reference Types vs Value Types</h1>
<blockquote>
<p >
<a href="https://github.com/sidristij/dotnetbook/issues/57">A link to the discussion</a></p>
</blockquote>
<div class="paragraph-container">
<div class="paragraph-left-side">01</div>
<p >
First, let’s talk about Refe&shy;rence Types and Value Types. I think people don’t really unders&shy;tand the diffe&shy;rences and bene&shy;fits of both. They usu&shy;ally say refe&shy;rence types store content on the heap and value types store content on the stack, which is wrong.</p>
<div class="paragraph-right-side">01</div>
</div>
<p >
Let’s discuss the real diffe&shy;rences:</p>
<ul>
<li>
<p >
<em>A value type</em>: its value is <strong>an entire structure</strong>. The value of a refe&shy;rence type is <strong>a reference</strong> to an object. – A struc&shy;ture in memory: value types contain only the data you indi&shy;cated. Refe&shy;rence types also contain two system fields. The first one stores &lsquo;Sync&shy;Block&shy;Index&rsquo;, the  second one stores the infor&shy;ma&shy;tion about a type, inclu&shy;ding the infor&shy;ma&shy;tion about a Virtual Methods Table (VMT).</p>
</li>
<li>
<p >
Refe&shy;rence types can have methods that are over&shy;ridden when inhe&shy;rited. Value types cannot be inhe&shy;rited.</p>
</li>
<li>
<p >
You should allo&shy;cate space on the heap for an instance of a refe&shy;rence type. A value type <em>can</em> be allo&shy;cated on the stack, or it becomes the part of a refe&shy;rence type. This suffi&shy;ci&shy;ently incre&shy;ases the perfor&shy;mance of some algo&shy;rithms.</p>
</li>
</ul>
<p >
However, there are common fea&shy;tures:</p>
<ul>
<li>
<p >
Both subc&shy;lasses can inherit the object type and become its repre&shy;sen&shy;ta&shy;tives.</p>
</li>
</ul>
<p >
Let’s look closer at each fea&shy;ture.</p>
<h2 id="copying">Copying</h2>
<p >
The main diffe&shy;rence between the two types is as follows:</p>
<ul>
<li>
<p >
Each vari&shy;able, class or struc&shy;ture fields or method para&shy;me&shy;ters that take a refe&shy;rence type store <strong>a reference</strong> to a value;</p>
</li>
<li>
<p >
But each vari&shy;able, class or struc&shy;ture fields or method para&shy;me&shy;ters that take a value type store a value exactly, i.e. an entire struc&shy;ture.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">02</div>
<p >
This means that assig&shy;ning or passing a para&shy;meter to a method will copy the value. Even if you change the copy, the ori&shy;ginal will stay the same. However, if you change refe&shy;rence type fields, this will “affect” all parts with a refe&shy;rence to an instance of a type. Let’s look at the
example:</p>
<div class="paragraph-right-side">02</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
DateTime dt = DateTime.Now;   <span style="color:Green;">// Here, we allocate space for DateTime variable when calling a method,</span>
                              <span style="color:Green;">// but it will contain zeros. Next, let’s copy all </span>
                              <span style="color:Green;">// values of the Now property to dt variable</span>
DateTime dt2 = dt;            <span style="color:Green;">// Here, we copy the value once again</span>

<span style="color:Blue;">object</span> obj = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();    <span style="color:Green;">// Here, we create an object by allocating memory on the Small Object Heap,</span>
                              <span style="color:Green;">// and put a pointer to the object in obj variable</span>
<span style="color:Blue;">object</span> obj2 = obj;            <span style="color:Green;">// Here, we copy a reference to this object. Finally, </span>
                              <span style="color:Green;">// we have one object and two references.</span>
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">03</div>
<p >
It seems this property produces ambi&shy;guous code constructs. One of them is values change in collec&shy;tions:</p>
<div class="paragraph-right-side">03</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Let’s declare a structure</span>
<span style="color:Blue;">struct</span> ValueHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Data;
}

<span style="color:Green;">// Let’s create an array of such structures and initialize the Data field = 5</span>
<span style="color:Blue;">var</span> array = <span style="color:Blue;">new</span> [] { <span style="color:Blue;">new</span> ValueHolder { Data = 5 } };

<span style="color:Green;">// Let’s use an index to get the structure and put 4 in the Data field</span>
array[0].Data = 4;

<span style="color:Green;">// Let’s check the value</span>
Console.WriteLine(array[0].Data);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">04</div>
<p >
There is a small trick in this code: it looks as if we first get a copy of the struc&shy;ture and then set a new value to the <code>Data</code> field of this copy. If this were the case we would get the ori&shy;ginal number <code>5</code> when we try to read the value next time. However, this doesn't happen. MSIL has a sepa&shy;rate instr&shy;uc&shy;tion for setting the values of fields in the struc&shy;tures of an array, which incre&shy;ases perfor&shy;mance. The code will work as intended: the program will output <code>4</code> to the console.</p>
<div class="paragraph-right-side">04</div>
</div>
<p >
Let’s see what will happen if we change this code:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Let’s declare a structure</span>
<span style="color:Blue;">struct</span> ValueHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Data;
}

<span style="color:Green;">// Let’s create a list of such structures and initialize the Data field = 5</span>
<span style="color:Blue;">var</span> list = <span style="color:Blue;">new</span> List&lt;ValueHolder&gt; { <span style="color:Blue;">new</span> ValueHolder { Data = 5 } };

<span style="color:Green;">// Let’s use an index to get the structure and put 4 in the Data field</span>
list[0].Data = 4;

<span style="color:Green;">// Let’s check the value</span>
Console.WriteLine(list[0].Data);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">05</div>
<p >
The compi&shy;la&shy;tion of this code will fail, because when you write <code>list[0].Data = 4</code> you get the copy of the struc&shy;ture first. In fact, you are calling an instance method of the <code>List&lt;T&gt;</code> type that under&shy;lies the access by an index. It takes the copy of a struc&shy;ture from an internal array (<code>List&lt;T&gt;</code> stores data in arrays) and returns this copy to you from the access method using an index. Next, you try to modify the copy, which is not used further along. This code is just poin&shy;t&shy;less and the compiler pr&shy;ohibits such beh&shy;avior knowing that people tend to misuse value types. We should rewrite this example in the follo&shy;wing way:</p>
<div class="paragraph-right-side">05</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Let’s declare a structure</span>
<span style="color:Blue;">struct</span> ValueHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Data;
}

<span style="color:Green;">// Let’s create a list of such structures and initialize the Data field = 5</span>
<span style="color:Blue;">var</span> list = <span style="color:Blue;">new</span> List&lt;ValueHolder&gt; { <span style="color:Blue;">new</span> ValueHolder { Data = 5 } };

<span style="color:Green;">// Let’s use an index to get the structure and put 4 in the Data field. Then, let’s save it again.</span>
<span style="color:Blue;">var</span> copy = list[0];
copy.Data = 4;
list[0] = copy;

<span style="color:Green;">// Let’s check the value</span>
Console.WriteLine(list[0].Data);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">06</div>
<p >
This code is correct despite its appa&shy;rent redun&shy;dancy. The program will output <code>4</code> to the console.</p>
<div class="paragraph-right-side">06</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">07</div>
<p >
The next example shows what I mean by <em>“the value of a structure is an entire structure”</em>:</p>
<div class="paragraph-right-side">07</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Variant 1</span>
<span style="color:Blue;">struct</span> PersonInfo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
}

<span style="color:Blue;">int</span> x = 5;
PersonInfo person;
<span style="color:Blue;">int</span> y = 6;

<span style="color:Green;">// Variant 2</span>

<span style="color:Blue;">int</span> x = 5;
<span style="color:Blue;">int</span> Height;
<span style="color:Blue;">int</span> Width;
<span style="color:Blue;">int</span> HairColor;
<span style="color:Blue;">int</span> y = 6;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">08</div>
<p >
Both examples are iden&shy;tical in terms of their data loca&shy;tion in memory since the value of a struc&shy;ture is an entire struc&shy;ture. In other words, the memory allo&shy;cated for a struc&shy;ture is iden&shy;tical to the memory allo&shy;cated for its fields (as if these fields were not wrapped by the struc&shy;ture syntax).</p>
<div class="paragraph-right-side">08</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">09</div>
<p >
The next examples are also iden&shy;tical in terms of the ele&shy;ments’ loca&shy;tion in memory as the struc&shy;ture takes place where it is defined among other class fields:</p>
<div class="paragraph-right-side">09</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Variant 1</span>
<span style="color:Blue;">struct</span> PersonInfo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
}

<span style="color:Blue;">class</span> Employee
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">public</span> PersonInfo person;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> y;
}

<span style="color:Green;">// Variant 2</span>
<span style="color:Blue;">class</span> Employee
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> y;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">10</div>
<p >
I am not saying that it is abso&shy;lu&shy;tely iden&shy;tical in every sense, only in terms of place&shy;ment in memory.</p>
<div class="paragraph-right-side">10</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">11</div>
<p >
Of course, this is not the case of refe&shy;rence types. A refe&shy;rence type instance itself is in the unre&shy;ach&shy;able Small Object Heap (SOH) or the Large Object Heap (LOH). A type class vari&shy;able contains only a value (32-bit or 64-bit integer) that is a pointer to a specific instance of the class in memory.</p>
<div class="paragraph-right-side">11</div>
</div>
<p >
Let’s look at the last example to close the issue.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Variant 1</span>
<span style="color:Blue;">struct</span> PersonInfo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> HairColor;
}

<span style="color:Blue;">void</span> Method(<span style="color:Blue;">int</span> x, PersonInfo person, <span style="color:Blue;">int</span> y);

<span style="color:Green;">// Variant 2</span>
<span style="color:Blue;">void</span> Method(<span style="color:Blue;">int</span> x, <span style="color:Blue;">int</span> HairColor, <span style="color:Blue;">int</span> Width, <span style="color:Blue;">int</span> Height, <span style="color:Blue;">int</span> y);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">12</div>
<p >
In terms of memory both vari&shy;ants of code will work in a similar way, but not in terms of arch&shy;it&shy;ecture. It is not just a repla&shy;ce&shy;ment of a vari&shy;able number of argu&shy;ments. The order of the struc&shy;ture vari&shy;ables is diffe&shy;rent because method para&shy;me&shy;ters are put on the stack in the order they are declared, how&shy;ever, the stack grows from higher to lower addresses which means the order of pushing a struc&shy;ture piece by piece will be diffe&shy;rent from pushing it as a whole.</p>
<div class="paragraph-right-side">12</div>
</div>
<h2 id="overridable-methods-and-inheritance">Overridable methods and inheritance</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">13</div>
<p >
The next big diffe&shy;rence between the two types is the lack of virtual
methods table in struc&shy;tures. This means that:</p>
<div class="paragraph-right-side">13</div>
</div>
<ol>
<li>
<p >
You cannot desc&shy;ribe and over&shy;ride virtual methods in struc&shy;tures.</p>
</li>
<li>
<p >
A struc&shy;ture cannot inherit another one. The only way to emu&shy;late inhe&shy;ri&shy;tance is to put a base type struc&shy;ture in the first field. The fields of an “inhe&shy;rited” struc&shy;ture will go after the fields of a “base” struc&shy;ture and it will create logical inhe&shy;ri&shy;tance. The fields of both struc&shy;tures will coin&shy;cide based on the offset.</p>
</li>
<li>
<p >
You can pass struc&shy;tures to unma&shy;naged code. However, you will lose the infor&shy;ma&shy;tion about methods. This is because a struc&shy;ture is just space in memory, filled with data without the infor&shy;ma&shy;tion about a type. You can pass it to unma&shy;naged methods, for example, written in C++, without changes.</p>
</li>
</ol>
<div class="paragraph-container">
<div class="paragraph-left-side">14</div>
<p >
The lack of a virtual methods table subt&shy;racts a certain part of inhe&shy;ri&shy;tance “magic” from struc&shy;tures but gives them other advan&shy;tages. The first one is that we can pass instances of such a struc&shy;ture to external envi&shy;ron&shy;ments (outside .NET Frame&shy;work). Remember, this is just a memory
range! We can also take a memory range from unma&shy;naged code and cast a type to our struc&shy;ture to make its fields more acces&shy;sible. You cannot do this with classes as they have two inac&shy;ces&shy;sible fields. These are Sync&shy;Block&shy;Index and a virtual methods table add&shy;ress. If those two fields pass to unma&shy;naged code, it will be dange&shy;rous. Using a virtual methods table one can access any type and change it to attack an appli&shy;ca&shy;tion.</p>
<div class="paragraph-right-side">14</div>
</div>
<p >
Let’s show it is just a memory range without addi&shy;ti&shy;onal logic.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">unsafe</span> <span style="color:Blue;">void</span> Main()
{
    <span style="color:Blue;">int</span> secret = 666;
    HeightHolder hh;
    hh.Height = 5;
    WidthHolder wh;
    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Green;">// This cast wouldn’t work if structures had the information about a type.</span>
        <span style="color:Green;">// The CLR would check a hierarchy before casting a type and if it didn’t find WidthHolder,</span>
        <span style="color:Green;">// it would output an InvalidCastException exception. But since a structure is a memory range,</span>
        <span style="color:Green;">// you can interpret it as any kind of structure.</span>
        wh = *(WidthHolder*)&amp;hh;
   }
   Console.WriteLine(<span style="color:#A31515;">&quot;Width: &quot;</span> + wh.Width);
   Console.WriteLine(<span style="color:#A31515;">&quot;Secret:&quot;</span> + wh.Secret);
}

<span style="color:Blue;">struct</span> WidthHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Width;
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Secret;
}

<span style="color:Blue;">struct</span> HeightHolder
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> Height;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">15</div>
<p >
Here, we perform the ope&shy;ra&shy;tion that is impos&shy;sible in strong typing. We cast one type to another incom&shy;pa&shy;tible one that contains one extra field. We intro&shy;duce an addi&shy;ti&shy;onal vari&shy;able inside the Main method. In theory, its value is secret. However, the example code will output the value of a vari&shy;able, not found in any of the struc&shy;tures inside the <code>Main()</code> method. You might consider it a breach in secu&shy;rity, but things are not so simple. You cannot get rid of unma&shy;naged code in a program. The main reason is the struc&shy;ture of the thread stack. One can use it to access unma&shy;naged code and play with local vari&shy;ables. You can defend your code from these attacks by rando&shy;mi&shy;zing the size of a stack frame. Or, you can delete the infor&shy;ma&shy;tion about <code>EBP</code> register to comp&shy;li&shy;cate the return of a stack frame. However, this doesn't matter for us now. What we are inte&shy;rested in this example is the follo&shy;wing. The &laquo;secret&raquo; vari&shy;able goes <strong>before</strong> the defi&shy;ni&shy;tion of hh vari&shy;able and <strong>after</strong> it in Width&shy;Holder struc&shy;ture (in diffe&shy;rent places, actu&shy;ally). So why did we easily get its value? The answer is that stack grows from right to left. The vari&shy;ables declared first will have much higher addresses, and those declared later will have lower addresses.</p>
<div class="paragraph-right-side">15</div>
</div>
<h2 id="the-behavior-when-calling-instance-methods">The behavior when calling instance methods</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">16</div>
<p >
Both data types have another fea&shy;ture which is not plain to see and can explain the struc&shy;ture of both types. It deals with calling instance methods.</p>
<div class="paragraph-right-side">16</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Green;">// The example with a reference type</span>
<span style="color:Blue;">class</span> FooClass
{
    <span style="color:Blue;">private</span> <span style="color:Blue;">int</span> x;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">int</span> val)
    {
        x = val;
    }
}

<span style="color:Green;">// The example with a value type</span>
<span style="color:Blue;">struct</span> FooStruct
{
    <span style="color:Blue;">private</span> <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">int</span> val)
    {
        x = val;
    }
}

FooClass klass = <span style="color:Blue;">new</span> FooClass();
FooStruct strukt = <span style="color:Blue;">new</span> FooStruct();

klass.ChangeTo(10);
strukt.ChangeTo(10);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">17</div>
<p >
Logi&shy;cally, we can decide that the method has one compiled body. In other words, there is no instance of a type that has its own compiled set of methods, similar to the sets of other instances. However, the called method knows which instance it belongs to as a refe&shy;rence to the instance of a type is the first para&shy;meter. We can rewrite our example and it will be iden&shy;tical to what we said before. I’m not using an example with virtual methods deli&shy;be&shy;ra&shy;tely, as they have another proce&shy;dure.</p>
<div class="paragraph-right-side">17</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Green;">// An example with a reference type</span>
<span style="color:Blue;">class</span> FooClass
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
}

<span style="color:Green;">// An example with a value type</span>
<span style="color:Blue;">struct</span> FooStruct
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;
}
<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(FooClass klass, <span style="color:Blue;">int</span> val)
{
    klass.x = val;
}

<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">ref</span> FooStruct strukt, <span style="color:Blue;">int</span> val)
{
    strukt.x = val;
}

FooClass klass = <span style="color:Blue;">new</span> FooClass();
FooStruct strukt = <span style="color:Blue;">new</span> FooStruct();

ChangeTo(klass, 10);
ChangeTo(<span style="color:Blue;">ref</span> strukt, 10);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">18</div>
<p >
I should explain the use of the ref keyword. If I didn’t use it, I would get a <strong>copy</strong> of the struc&shy;ture as a method para&shy;meter instead of the ori&shy;ginal. Then I would change it, but the ori&shy;ginal would stay the same. I would have to return a changed copy from a method to a caller (another copying), and the caller would save this value back in the vari&shy;able (one more copying). Instead, an instance method gets a pointer and use it for changing the ori&shy;ginal straight away. Using a pointer doesn’t influ&shy;ence perfor&shy;mance as any processor-level ope&shy;ra&shy;tions use poin&shy;ters. Ref is a part of the C# world, no more.</p>
<div class="paragraph-right-side">18</div>
</div>
<h2 id="the-capability-to-point-to-the-position-of-elements">The capability to point to the position of elements.</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">19</div>
<p >
Both struc&shy;tures and classes have another capa&shy;bi&shy;lity to point to the offset of a parti&shy;cular field in respect to the begin&shy;ning of a struc&shy;ture in memory. This serves several purposes:</p>
<div class="paragraph-right-side">19</div>
</div>
<ul>
<li>
<p >
to work with external APIs in the unma&shy;naged world without having to insert unused fields before a neces&shy;sary one;</p>
</li>
<li>
<p >
to instruct a compiler to locate a field right at the begin&shy;ning of the (<code>[FieldOffset(0)]</code>) type. It will make the work with this type faster. If it is a frequ&shy;ently used field, we can increase appli&shy;ca&shy;tion's perfor&shy;mance. However, this is true only for value types. In refe&shy;rence types the field with a zero offset contains the add&shy;ress of a virtual methods table, which takes 1 machine word. Even if you add&shy;ress the first field of a class, it will use complex addres&shy;sing (add&shy;ress + offset). This is because the most used class field is the add&shy;ress of a virtual methods table. The table is neces&shy;sary to call all the virtual methods;</p>
</li>
<li>
<p >
to point to several fields using one add&shy;ress. In this case, the same value is interp&shy;reted as diffe&shy;rent data types. In C++ this data type is called a union;</p>
</li>
<li>
<p >
not to bother to declare anything: a compiler will allo&shy;cate fields opti&shy;mally. Thus, the final order of fields may be diffe&shy;rent.</p>
</li>
</ul>
<p >
<strong>General remarks</strong></p>
<ul>
<li>
<p >
<strong>Auto</strong>: the run-time envi&shy;ron&shy;ment aut&shy;om&shy;at&shy;ically chooses a loca&shy;tion and a packing for all class or struc&shy;ture fields. The defined struc&shy;tures that are marked by a member of this enu&shy;me&shy;ra&shy;tion cannot pass into unma&shy;naged code. The attempt to do it will produce an excep&shy;tion;</p>
</li>
<li>
<p >
<strong>Explicit</strong>: a prog&shy;rammer expli&shy;citly cont&shy;rols the exact loca&shy;tion of each field of a type with the Field&shy;Offset&shy;Attribute;</p>
</li>
<li>
<p >
<strong>Sequential</strong>: type members come in a sequ&shy;en&shy;tial order, defined during type design. The Struct&shy;Layout&shy;Attribute.Pack value of a packing step indi&shy;cates their loca&shy;tion.</p>
</li>
</ul>
<p >
<strong>Using FieldOffset to skip unused structure fields</strong></p>
<div class="paragraph-container">
<div class="paragraph-left-side">20</div>
<p >
The struc&shy;tures coming from the unma&shy;naged world can contain reserved fields. One can use them in a future version of a library. In C/C++ we fill these gaps by adding fields, e.g. reserved1, reserved2, ... However, in .NET we just offset to the begin&shy;ning of a field by using the Field&shy;Offset&shy;Attribute attri&shy;bute and <code>[StructLayout(LayoutKind.Explicit)]</code>.</p>
<div class="paragraph-right-side">20</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[StructLayout(LayoutKind.Explicit)]
<span style="color:Blue;">public</span> <span style="color:Blue;">struct</span> SYSTEM_INFO
{
    [FieldOffset(0)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> OemId;

    <span style="color:Green;">// 92 bytes reserved</span>
    [FieldOffset(100)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> PageSize;
    [FieldOffset(108)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> ActiveProcessorMask;
    [FieldOffset(116)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> NumberOfProcessors;
    [FieldOffset(124)] <span style="color:Blue;">public</span> <span style="color:Blue;">ulong</span> ProcessorType;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">21</div>
<p >
A gap is occu&shy;pied but unused space. The struc&shy;ture will have the size equal to 132 and not 40 bytes as it may seem from the begin&shy;ning.</p>
<div class="paragraph-right-side">21</div>
</div>
<p >
<strong>Union</strong></p>
<div class="paragraph-container">
<div class="paragraph-left-side">22</div>
<p >
Using the Field&shy;Offset&shy;Attribute you can emu&shy;late the C/C++ type called a union. It allows to access the same data as enti&shy;ties of
diffe&shy;rent types. Let’s look at the example:</p>
<div class="paragraph-right-side">22</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// If we read the RGBA.Value, we will get an Int32 value accumulating all</span>
<span style="color:Green;">// other fields.</span>
<span style="color:Green;">// However, if we try to read the RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, we </span>
<span style="color:Green;">// will get separate components of Int32.</span>
[StructLayout(LayoutKind.Explicit)]
<span style="color:Blue;">public</span> <span style="color:Blue;">struct</span> RGBA
{
    [FieldOffset(0)] <span style="color:Blue;">public</span> <span style="color:Blue;">uint</span> Value;
    [FieldOffset(0)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> R;
    [FieldOffset(1)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> G;
    [FieldOffset(2)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> B;
    [FieldOffset(3)] <span style="color:Blue;">public</span> <span style="color:Blue;">byte</span> Alpha;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">23</div>
<p >
You might say such beh&shy;avior is possible only for value types. However, you can simu&shy;late it for refe&shy;rence types, using one add&shy;ress for over&shy;lap&shy;ping two refe&shy;rence types or one refe&shy;rence type and one value type:</p>
<div class="paragraph-right-side">23</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">class</span> Program
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">static</span> <span style="color:Blue;">void</span> Main()
    {
        Union x = <span style="color:Blue;">new</span> Union();
        x.Reference.Value = <span style="color:#A31515;">&quot;Hello!&quot;</span>;
        Console.WriteLine(x.Value.Value);
    }

    [StructLayout(LayoutKind.Explicit)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">class</span> Union
    {
        <span style="color:Blue;">public</span> Union()
        {
            Value = <span style="color:Blue;">new</span> Holder&lt;IntPtr&gt;();
            Reference = <span style="color:Blue;">new</span> Holder&lt;<span style="color:Blue;">object</span>&gt;();
        }

        [FieldOffset(0)]
        <span style="color:Blue;">public</span> Holder&lt;IntPtr&gt; Value;

        [FieldOffset(0)]
        <span style="color:Blue;">public</span> Holder&lt;<span style="color:Blue;">object</span>&gt; Reference;
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">class</span> Holder&lt;T&gt;
    {
        <span style="color:Blue;">public</span> T Value;
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">24</div>
<p >
I used a generic type for over&shy;lap&shy;ping on purpose. If I used usual
over&shy;lap&shy;ping, this type would cause the Type&shy;Load&shy;Exception when loaded in an appli&shy;ca&shy;tion domain. It might look like a secu&shy;rity breach in theory (espe&shy;ci&shy;ally, when talking about appli&shy;ca&shy;tion <strong>plug-ins</strong>), but if we try to run this code using a protected domain, we will get the same <code>TypeLoadException</code>.</p>
<div class="paragraph-right-side">24</div>
</div>
<h2 id="the-difference-in-allocation">The difference in allocation</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">25</div>
<p >
Another fea&shy;ture that diffe&shy;ren&shy;ti&shy;ates both types is memory allo&shy;ca&shy;tion for objects or struc&shy;tures. The CLR must decide on several things before allo&shy;ca&shy;ting memory for an object. What is the size of an object? Is it more or less than 85K? If it is less, then is there enough free space on the SOH to allo&shy;cate this object? If it is more, the CLR acti&shy;vates Garbage Collector. It goes through an object graph, compacts the objects by moving them to cleared space. If there is still no space on the SOH, the allo&shy;ca&shy;tion of addi&shy;ti&shy;onal virtual memory pages will start. It is only then that an object gets allo&shy;cated space, cleared from garbage. After&shy;wards, the CLR lays out Sync&shy;Block&shy;Index and Virtual&shy;Methods&shy;Table. Finally, the refe&shy;rence to an object returns to a user.</p>
<div class="paragraph-right-side">25</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">26</div>
<p >
If an allo&shy;cated object is bigger than 85K, it goes to the Large Objects Heap (LOH). This is the case of large strings and arrays. Here, we must find the most suitable space in memory from the list of unoc&shy;cu&shy;pied ranges or allo&shy;cate a new one. It is not quick, but we are going to deal with the objects of such size care&shy;fully. Also, we are not going to talk about them here.</p>
<div class="paragraph-right-side">26</div>
</div>
<p >
There are several possible scena&shy;rios for Ref&shy;Types:</p>
<ul>
<li>
<p >
Ref&shy;Type < 85K, there is space on the SOH: quick memory allo&shy;ca&shy;tion;</p>
</li>
<li>
<p >
Ref&shy;Type < 85K, the space on the SOH is running out: very slow memory allo&shy;ca&shy;tion;</p>
</li>
<li>
<p >
Ref&shy;Type > 85K, slow memory allo&shy;ca&shy;tion.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">27</div>
<p >
Such ope&shy;ra&shy;tions are rare and can’t compete with Val&shy;Types. The algo&shy;rithm of memory allo&shy;ca&shy;tion for value types doesn’t exist. The allo&shy;ca&shy;tion of memory for value types costs nothing. The only thing that happens when allo&shy;ca&shy;ting memory for this type is setting fields to null. Let’s see why this happens: 1. When one declares a vari&shy;able in the body of a method, the time of memory allo&shy;ca&shy;tion for a struc&shy;ture is close to zero. That is because the time of allo&shy;ca&shy;tion for local vari&shy;ables doesn’t depend on their number; 2. If Val&shy;Types are allo&shy;cated as fields, Reftypes will increase the size of the fields. A Value type is allo&shy;cated enti&shy;rely, beco&shy;ming its part; 3. As in case of copying, if Val&shy;Types are passed as method para&shy;me&shy;ters, there appears a diffe&shy;rence, depen&shy;ding on the size and loca&shy;tion of a para&shy;meter.</p>
<div class="paragraph-right-side">27</div>
</div>
<p >
However, that doesn’t take more time than copying one vari&shy;able into another.</p>
<h2 id="the-choice-between-a-class-or-a-structure">The choice between a class or a structure</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">28</div>
<p >
Let’s discuss the advan&shy;tages and disad&shy;van&shy;tages of both types and decide on their use scena&shy;rios. A classic prin&shy;ciple says we should choose a value type if it is not larger than 16 bytes, stays unchanged during its life and is not inhe&shy;rited. However, choosing the right type means revi&shy;e&shy;wing it from diffe&shy;rent pers&shy;pec&shy;tives basing on scena&shy;rios of future use. I propose three groups of criteria:</p>
<div class="paragraph-right-side">28</div>
</div>
<ul>
<li>
<p >
based on type system arch&shy;it&shy;ecture, in which your type will inte&shy;ract;</p>
</li>
<li>
<p >
based on your approach as a system prog&shy;rammer to choosing a type with optimal perfor&shy;mance;</p>
</li>
<li>
<p >
when there is no other choice.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">29</div>
<p >
Each designed fea&shy;ture should reflect its purpose. This doesn’t deal with its name or inte&shy;rac&shy;tion inter&shy;face (methods, proper&shy;ties) only. One can use arch&shy;it&shy;ectural consi&shy;de&shy;ra&shy;tions to choose between value and refe&shy;rence types. Let’s think why a struc&shy;ture and not a class might be chosen from the type system arch&shy;it&shy;ecture's point of view.</p>
<div class="paragraph-right-side">29</div>
</div>
<ol>
<li>
<p >
If your designed type is agnostic to its state, this will mean its state reflects a process or is a value of something. In other words, an instance of a type is cons&shy;tant and unch&shy;an&shy;geable by nature. We can create another instance of a type based on this cons&shy;tant by indi&shy;ca&shy;ting some offset. Or, we can create a new instance by indi&shy;ca&shy;ting its proper&shy;ties. However, we mustn’t change it. I don’t mean that struc&shy;ture is an immu&shy;table type. You can change its field values. More&shy;over, you can pass a refe&shy;rence to a struc&shy;ture into a method using the ref para&shy;meter and you will get changed fields after exi&shy;ting the method. What I talk here about is arch&shy;it&shy;ectural sense. I will give several examples.</p>
<ul>
<li>
<p >
Date&shy;Time is a struc&shy;ture which encap&shy;su&shy;lates the concept of a moment in time. It stores this data as a uint but gives access to sepa&shy;rate char&shy;ac&shy;ter&shy;istics of a moment in time: year, month, day, hour, minutes, seconds, milli&shy;se&shy;conds and even processor ticks. However, it is unch&shy;an&shy;geable, basing on what it encap&shy;su&shy;lates. We cannot change a moment in time. I cannot live the next minute as if it was my best birthday in the childhood. Thus, if we choose a data type, we can choose a class with a rea&shy;donly inter&shy;face, which produces a new instance for each change of proper&shy;ties. Or, we can choose a struc&shy;ture, which can but shouldn’t change the fields of its instances: its <em>value</em> is the desc&shy;rip&shy;tion of a moment in time, like a number. You cannot access the struc&shy;ture of a number and change it. If you want to get another moment in time, which differs for one day from ori&shy;ginal, you will just get a new instance of a struc&shy;ture.</p>
</li>
<li>
<p >
<code>KeyValuePair&lt;TKey, TValue&gt;</code> is a struc&shy;ture that encap&shy;su&shy;lates the concept of a connected key–value pair. This struc&shy;ture is only to output the content of a dicti&shy;o&shy;nary during enu&shy;me&shy;ra&shy;tion. From the arch&shy;it&shy;ectural point of view a key and a value are inse&shy;pa&shy;rable concepts in <code>Dictionary&lt;T&gt;</code>. However, inside we have a complex struc&shy;ture, where a key lies sepa&shy;ra&shy;tely from a value. For a user a key-value pair is an inse&shy;pa&shy;rable concept in terms of inter&shy;face and the mea&shy;ning of a data struc&shy;ture. It is an entire <em>value</em> itself. If one assigns another value for a key, the whole pair will change. Thus, they repre&shy;sent a single entity. This makes a struc&shy;ture an ideal variant in this case.</p>
</li>
</ul>
</li>
<li>
<p >
If your designed type is an inse&shy;pa&shy;rable part of an external type but is integral struc&shy;tu&shy;rally. That means it is incor&shy;rect to say the external type refers to an instance of an encap&shy;su&shy;lated type. However, it is correct to say that an encap&shy;su&shy;lated type is a part of an external together with all its proper&shy;ties. This is useful when desig&shy;ning a struc&shy;ture which is a part of another struc&shy;ture.</p>
<ul>
<li>
<p >
For example, if we take a struc&shy;ture of a file header it will be inapp&shy;rop&shy;riate to pass a refe&shy;rence from one file to another, e.g. some header.txt file. This would be approp&shy;riate when inser&shy;ting a docu&shy;ment in another, not by embed&shy;ding a file but using a refe&shy;rence in a file system. A good example is sho&shy;rtcut files in Windows OS. However, if we talk about a file header (for example JPEG file header conta&shy;i&shy;ning meta&shy;data about an image size, comp&shy;res&shy;sion methods, phot&shy;ography para&shy;me&shy;ters, GPS coor&shy;di&shy;nates and other), then we should use struc&shy;tures to design types for parsing the header. If you desc&shy;ribe all the headers in struc&shy;tures, you will get the same posi&shy;tion of fields in memory as it is in a file. Using simple unsafe <code>*(Header *)readedBuffer</code> trans&shy;for&shy;ma&shy;tion without dese&shy;ri&shy;a&shy;li&shy;za&shy;tion you will get fully filled data struc&shy;tures.</p>
</li>
</ul>
</li>
<li>
<p >
Neither example shows the inhe&shy;ri&shy;tance of beh&shy;avior. They show that there is no need to inherit the beh&shy;avior of these enti&shy;ties. They are self-conta&shy;ined. However, if we take the effec&shy;ti&shy;ve&shy;ness of code into consi&shy;de&shy;ra&shy;tion, we will see the choice from another side:</p>
</li>
<li>
<p >
If we need to take some struc&shy;tured data from unma&shy;naged code, we should choose struc&shy;tures. We can also pass data struc&shy;ture to an unsafe method. A refe&shy;rence type is not suitable for this at all.</p>
</li>
<li>
<p >
A struc&shy;ture is your choice if a type passes the data in method calls (as returned values or as a method para&shy;meter) and there is no need to refer to the same value from diffe&shy;rent places. The perfect example is tuples. If a method returns several values using tuples, it will return a Value&shy;Tuple, declared as a struc&shy;ture. The method won’t allo&shy;cate space on the heap, but will use the stack of the thread, where memory allo&shy;ca&shy;tion costs nothing.</p>
</li>
<li>
<p >
If you design a system that creates big traffic of instances that have small size and life&shy;time, using refe&shy;rence types will lead either to a pool of objects or, if without the pool of objects, to an uncont&shy;rolled garbage accu&shy;mu&shy;la&shy;tion on the heap. Some objects will turn into older gene&shy;ra&shy;tions, incre&shy;a&shy;sing the load on GC. Using value types in such places (if it’s possible) will give an increase in perfor&shy;mance because nothing will pass to the SOH. This will lessen the load on GC and the algo&shy;rithm will work faster;</p>
</li>
</ol>
<p >
Basing on what I’ve said, here is some advice on using struc&shy;tures:</p>
<ol>
<li>
<p >
When choosing collec&shy;tions you should avoid big arrays storing big struc&shy;tures. This includes data struc&shy;tures based on arrays. This can lead to a tran&shy;si&shy;tion to the Large Objects Heap and its frag&shy;men&shy;ta&shy;tion. It is wrong to think that if our struc&shy;ture has 4 fields of the byte type, it will take 4 bytes. We should unders&shy;tand that in 32-bit systems each struc&shy;ture field is aligned on 4 bytes boun&shy;da&shy;ries (each add&shy;ress field should be divided exactly by 4) and in 64-bit systems — on 8 bytes boun&shy;da&shy;ries. The size of an array should depend on the size of a struc&shy;ture and a plat&shy;form, running a program. In our example with 4 bytes – 85K / (from 4 to 8 bytes per field * the number of fields = 4) minus the size of an array header equals to about 2 600 ele&shy;ments per array depen&shy;ding on the plat&shy;form (this should be rounded down). That is not very much. It may have seemed that we could easily reach a magic cons&shy;tant of 20 000 ele&shy;ments</p>
</li>
<li>
<p >
Some&shy;times you use a big size struc&shy;ture as a source of data and place it as a field in a class, while having one copy repli&shy;cated to produce a thousand of instances. Then you expand each instance of a class for the size of a struc&shy;ture. It will lead to the swel&shy;ling of gene&shy;ra&shy;tion zero and tran&shy;si&shy;tion to gene&shy;ra&shy;tion one and even two. If the instances of a class have a short life period and you think the GC will collect them at gene&shy;ra&shy;tion zero – for 1 ms, you will be disap&shy;po&shy;inted. They are already in gene&shy;ra&shy;tion one and even two. This makes the diffe&shy;rence. If the GC collects gene&shy;ra&shy;tion zero for 1 ms, the gene&shy;ra&shy;tions one and two are collected very slowly that will lead to a decrease in effi&shy;ci&shy;ency;</p>
</li>
<li>
<p >
For the same reason you should avoid passing big struc&shy;tures through a series of method calls. If all ele&shy;ments call each other, these calls will take more space on the stack and bring your appli&shy;ca&shy;tion to death by Stack&shy;Overflow&shy;Exception. The next reason is perfor&shy;mance. The more copies there are the more slowly everything works.</p>
</li>
</ol>
<div class="paragraph-container">
<div class="paragraph-left-side">30</div>
<p >
That’s why the choice of a data type is not an obvious process. Often, this can refer to a prema&shy;ture opti&shy;mi&shy;za&shy;tion, which is not recom&shy;mended. However, if you know your situ&shy;a&shy;tion falls within above stated prin&shy;ciples, you can easily choose a value type.</p>
<div class="paragraph-right-side">30</div>
</div>
<h2 id="the-object-base-type-and-implementation-of-interfaces.boxing">The Object base type and implementation of interfaces. Boxing</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">31</div>
<p >
It seems we came through hell and high water and can nail any inter&shy;view, even the one for .NET CLR team. However, let's not rush to  micro&shy;soft.com and search for vacan&shy;cies. Now, we need to unders&shy;tand how value types inherit an object if they contain neither a refe&shy;rence to Sync&shy;Block&shy;Index, not a pointer to a virtual methods table. This will comp&shy;le&shy;tely explain our system of types and all pieces of a puzzle will find their places. However, we will need more than one sentence.</p>
<div class="paragraph-right-side">31</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">32</div>
<p >
Now, let's remember again how value types are allo&shy;cated in memory. They get the place in memory right where they are. Refe&shy;rence types get allo&shy;ca&shy;tion on the heap of small and large objects. They always give a refe&shy;rence to the place on the heap where the object is. Each value type has such methods as To&shy;String, Equals and Get&shy;Hash&shy;Code. They are virtual and over&shy;ri&shy;dable, but don’t allow to inherit a value type by over&shy;ri&shy;ding methods. If value types used over&shy;ri&shy;dable methods, they would need a virtual methods table to route calls. This would lead to the prob&shy;lems of passing struc&shy;tures to unma&shy;naged world: extra fields would go there. As a result, there are desc&shy;rip&shy;tions of value type methods somew&shy;here, but you cannot access them directly via a virtual methods table.</p>
<div class="paragraph-right-side">32</div>
</div>
<p >
This may bring the idea that the lack of inhe&shy;ri&shy;tance is arti&shy;fi&shy;cial:</p>
<ul>
<li>
<p >
there is inhe&shy;ri&shy;tance from an object, but not direct;</p>
</li>
<li>
<p >
there are To&shy;String, Equals and Get&shy;Hash&shy;Code inside a base type. In value types these methods have their own beh&shy;avior. This means, that methods are over&shy;ridden in rela&shy;tion to an <code>object</code>;</p>
</li>
<li>
<p >
more&shy;over, if you cast a type to an <code>object</code>, you have the full right to call To&shy;String, Equals and Get&shy;Hash&shy;Code;</p>
</li>
<li>
<p >
when calling an instance method for a value type, the method gets another struc&shy;ture that is a copy of an ori&shy;ginal. That means calling an instance method is like calling a static method: <code>Method(ref structInstance, newInternalFieldValue)</code>. Indeed, this call passes <code>this</code>, with one excep&shy;tion, how&shy;ever. A JIT should compile the body of a method, so it would be unne&shy;ces&shy;sary to offset struc&shy;ture fields, jumping over the pointer to a virtual methods table, which doesn’t exist in the struc&shy;ture. <em>It exists for value types in another place</em>.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">33</div>
<p >
Types are diffe&shy;rent in beh&shy;avior, but this diffe&shy;rence is not so big on the level of imple&shy;men&shy;ta&shy;tion in the CLR. We will talk about it a little later.</p>
<div class="paragraph-right-side">33</div>
</div>
<p >
Let's write the follo&shy;wing line in our program:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> obj = (<span style="color:Blue;">object</span>)10;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">34</div>
<p >
It will allow us to deal with number 10 using a base class. This is called boxing. That means we have a VMT to call such virtual methods as To&shy;String(), Equals and Get&shy;Hash&shy;Code. In rea&shy;lity boxing creates a copy of a value type, but not a pointer to an ori&shy;ginal. This is because we can store the ori&shy;ginal value everywhere: on the stack or as a field of a class. If we cast it to an object type, we can store a refe&shy;rence to this value as long as we want. When boxing happens:</p>
<div class="paragraph-right-side">34</div>
</div>
<ul>
<li>
<p >
the CLR allo&shy;cates space on the heap for a struc&shy;ture + Sync&shy;Block&shy;Index + VMT of a value type (to call To&shy;String, Get&shy;Hash&shy;Code, Equals);</p>
</li>
<li>
<p >
it copies an instance of a value type there.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">35</div>
<p >
Now, we’ve got a refe&shy;rence variant of a value type. A struc&shy;ture has got <strong>absolutely the same set of system fields as a reference type</strong>,
beco&shy;ming a fully-fledged refe&shy;rence type after boxing. The struc&shy;ture became a class. Let’s call it a .NET somer&shy;sault. This is a fair name.</p>
<div class="paragraph-right-side">35</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">36</div>
<p >
Just look at what happens if you use a struc&shy;ture which imple&shy;ments an inter&shy;face using the same inter&shy;face.</p>
<div class="paragraph-right-side">36</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Blue;">struct</span> Foo : IBoo
{
    <span style="color:Blue;">int</span> x;
    <span style="color:Blue;">void</span> Boo()
    {
        x = 666;
    }
}

IBoo boo = <span style="color:Blue;">new</span> Foo();

boo.Boo();
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">37</div>
<p >
When we create the Foo instance, its value goes to the stack in fact. Then we put this vari&shy;able into an inter&shy;face type vari&shy;able and the struc&shy;ture into a refe&shy;rence type vari&shy;able. Next, there is boxing and we have the object type as an output. But it is an inter&shy;face type vari&shy;able. That means we need type conver&shy;sion. So, the call happens in a way like this:</p>
<div class="paragraph-right-side">37</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
IBoo boo = (IBoo)(box_to_object)<span style="color:Blue;">new</span> Foo();
boo.Boo();
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">38</div>
<p >
Writing such code is not effec&shy;tive. You will have to change a copy instead of an ori&shy;ginal:</p>
<div class="paragraph-right-side">38</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Main()
{
    <span style="color:Blue;">var</span> foo = <span style="color:Blue;">new</span> Foo();
    foo.a = 1;
    Console.WriteLite(foo.a);   <span style="color:Green;">// -&gt; 1</span>

    IBoo boo = foo;
    boo.Boo();                  <span style="color:Green;">// looks like changing foo.a to 10</span>
    Console.WriteLite(foo.a);   <span style="color:Green;">// -&gt; 1</span>
}

<span style="color:Blue;">struct</span> Foo: IBoo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> a;
    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Boo()
    {
        a = 10;
    }
}

<span style="color:Blue;">interface</span> IBoo
{
    <span style="color:Blue;">void</span> Boo();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">39</div>
<p >
The first time we look at the code, we don’t have to know what we deal with in the code <em>other than our own</em> and see a cast to IBoo inter&shy;face. This makes us think Foo is a class and not a struc&shy;ture. Then there is no visual divi&shy;sion in struc&shy;tures and classes, which makes us think the
inter&shy;face modi&shy;fi&shy;ca&shy;tion results must get into foo, which doesn’t happen as boo is a copy of foo. That is misle&shy;a&shy;ding. In my opi&shy;nion, this code should get comments, so other deve&shy;lo&shy;pers could deal with it.</p>
<div class="paragraph-right-side">39</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">40</div>
<p >
The second thing relates to the previous thoughts that we can cast a type from an object to IBoo. This is another proof that a boxed value type is a refe&shy;rence variant of a value type. Or, all types in a system of types are refe&shy;rence types. We can just work with struc&shy;tures as with value types, passing their value enti&shy;rely. Dere&shy;fe&shy;ren&shy;cing a pointer to an object as you would say in the world of C++.</p>
<div class="paragraph-right-side">40</div>
</div>
<p >
You can object that if it was true, it would look like this:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> referenceToInteger = (IInt32)10;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">41</div>
<p >
We would get not just an object, but a typed refe&shy;rence for a boxed value type. It would destroy the whole idea of value types (i.e. integ&shy;rity of their value) allo&shy;wing for great opti&shy;mi&shy;za&shy;tion, based on their proper&shy;ties. Let’s take down this idea!</p>
<div class="paragraph-right-side">41</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">sealed</span> <span style="color:Blue;">class</span> Boxed&lt;T&gt;
{
    <span style="color:Blue;">public</span> T Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
     <span style="color:Blue;">public</span> <span style="color:Blue;">override</span> <span style="color:Blue;">bool</span> Equals(<span style="color:Blue;">object</span> obj)
     {
         <span style="color:Blue;">return</span> Value.Equals(obj);
     }

     [MethodImpl(MethodImplOptions.AggressiveInlining)]
     <span style="color:Blue;">public</span> <span style="color:Blue;">override</span> <span style="color:Blue;">string</span> ToString()

     {
         <span style="color:Blue;">return</span> Value.ToString();
     }

     [MethodImpl(MethodImplOptions.AggressiveInlining)]
     <span style="color:Blue;">public</span> <span style="color:Blue;">override</span> <span style="color:Blue;">int</span> GetHashCode()
     {
         <span style="color:Blue;">return</span> Value.GetHashCode();
     }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">42</div>
<p >
We’ve got a comp&shy;lete analog of boxing. However, we can change its contents by calling instance methods. These changes will affect all parts with a refe&shy;rence to this data struc&shy;ture.</p>
<div class="paragraph-right-side">42</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> typedBoxing = <span style="color:Blue;">new</span> Boxed&lt;<span style="color:Blue;">int</span>&gt; { Value = 10 };
<span style="color:Blue;">var</span> pureBoxing = (<span style="color:Blue;">object</span>)10;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">43</div>
<p >
The first variant isn’t very attrac&shy;tive. Instead of casting a type we create nonsense. The second line is much better, but the two lines are almost iden&shy;tical. The only diffe&shy;rence is that there is no memory clea&shy;ning with zeros during the usual boxing after allo&shy;ca&shy;ting memory on the heap. The neces&shy;sary struc&shy;ture takes the memory straight away whe&shy;reas the first variant needs clea&shy;ning. This makes it work longer than the usual boxing by 10%.</p>
<div class="paragraph-right-side">43</div>
</div>
<p >
Instead, we can call some methods for our boxed value.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">struct</span> Foo
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> x;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> ChangeTo(<span style="color:Blue;">int</span> newx)
    {
        x = newx;
    }
}
<span style="color:Blue;">var</span> boxed = <span style="color:Blue;">new</span> Boxed&lt;Foo&gt; { Value = <span style="color:Blue;">new</span> Foo { x = 5 } };
boxed.Value.ChangeTo(10);
<span style="color:Blue;">var</span> unboxed = boxed.Value;
</pre></div>
</div>
<p >
We’ve got a new inst&shy;rument. Let's think what we can do with it.</p>
<ul>
<li>
<p >
Our <code>Boxed&lt;T&gt;</code> type does the same as the usual type: allo&shy;cates memory on the heap, passes a value there and allows to get it, by doing a kind of unbox;</p>
</li>
<li>
<p >
If you lose a refe&shy;rence to a boxed struc&shy;ture, the GC will collect it;</p>
</li>
<li>
<p >
However, we can now work with a boxed type, i.e. calling its methods;</p>
</li>
<li>
<p >
Also, we can replace an instance of a value type in the SOH/LOH for another one. We couldn’t do it before, as we would have to do unbo&shy;xing, change struc&shy;ture to another one and do boxing back, giving a new refe&shy;rence to custo&shy;mers.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">44</div>
<p >
The main problem of boxing is crea&shy;ting traffic in memory. The traffic of unk&shy;nown number of objects, the part of which can survive up to gene&shy;ra&shy;tion one, where we get prob&shy;lems with garbage collec&shy;tion. There will be a lot of garbage and we could have avo&shy;ided it. But when we have the traffic of short-lived objects, the first solu&shy;tion is poo&shy;ling. This is an ideal end of .NET somer&shy;sault.</p>
<div class="paragraph-right-side">44</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">var</span> pool = <span style="color:Blue;">new</span> Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000);
<span style="color:Blue;">var</span> boxed = pool.Box(10);
boxed.Value=70;

<span style="color:Green;">// use boxed value here</span>

pool.Free(boxed);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">45</div>
<p >
Now boxing can work using a pool, which eli&shy;mi&shy;nates memory traffic while boxing. We can even make objects go back to life in fina&shy;li&shy;za&shy;tion method and put thems&shy;elves back into the pool. This might be useful when a boxed struc&shy;ture goes to asyn&shy;chronous code other than yours and you cannot unders&shy;tand when it became unne&shy;ces&shy;sary. In this case, it will return itself back to pool during GC.</p>
<div class="paragraph-right-side">45</div>
</div>
<p >
Let’s conc&shy;lude:</p>
<ul>
<li>
<p >
If boxing is acci&shy;dental and shouldn’t happen, don’t make it happen. It can lead to prob&shy;lems with perfor&shy;mance.</p>
</li>
<li>
<p >
If boxing is neces&shy;sary for the arch&shy;it&shy;ecture of a system, there may be vari&shy;ants. If the traffic of boxed struc&shy;tures is small and almost invi&shy;sible, you can use boxing. If the traffic is visible, you might want to do the poo&shy;ling of boxing, using one of the solu&shy;tions stated above. It spends some reso&shy;urces, but makes GC work without over&shy;load;</p>
</li>
</ul>
<p >
Ulti&shy;ma&shy;tely let’s look at a totally imprac&shy;tical code:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">static</span> <span style="color:Blue;">unsafe</span> <span style="color:Blue;">void</span> Main()
{
    <span style="color:Green;">// here we create boxed int</span>
    <span style="color:Blue;">object</span> boxed = 10;

    <span style="color:Green;">// here we get the address of a pointer to a VMT</span>
    <span style="color:Blue;">var</span> address = (<span style="color:Blue;">void</span>**)EntityPtr.ToPointerWithOffset(boxed);

    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Green;">// here we get a Virtual Methods Table address</span>
        <span style="color:Blue;">var</span> structVmt = <span style="color:Blue;">typeof</span>(SimpleIntHolder).TypeHandle.Value.ToPointer();

       <span style="color:Green;">// change the VMT address of the integer passed to Heap into a VMT SimpleIntHolder, turning Int into a structure</span>
       *address = structVmt;
    }

    <span style="color:Blue;">var</span> structure = (IGetterByInterface)boxed;

    Console.WriteLine(structure.GetByInterface());
}

<span style="color:Blue;">interface</span> IGetterByInterface
{
    <span style="color:Blue;">int</span> GetByInterface();
}

<span style="color:Blue;">struct</span> SimpleIntHolder : IGetterByInterface
{
    <span style="color:Blue;">public</span> <span style="color:Blue;">int</span> value;

    <span style="color:Blue;">int</span> IGetterByInterface.GetByInterface()
    {
        <span style="color:Blue;">return</span> value;
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">46</div>
<p >
The code uses a small function, which can get a pointer from a refe&shy;rence to an object. The library is ava&shy;ilable at <a href="https://github.com/mumusan/dotnetex/blob/master/libs/">github address</a>. This example shows that usual boxing turns int into a typed refe&shy;rence type. Let’s
look at the steps in the process:</p>
<div class="paragraph-right-side">46</div>
</div>
<ol>
<li>
<p >
Do boxing for an integer.</p>
</li>
<li>
<p >
Get the add&shy;ress of an obta&shy;ined object (the add&shy;ress of Int32 VMT)</p>
</li>
<li>
<p >
Get the VMT of a Simple&shy;Int&shy;Holder</p>
</li>
<li>
<p >
Replace the VMT of a boxed integer to the VMT of a struc&shy;ture.</p>
</li>
<li>
<p >
Make unbo&shy;xing into a struc&shy;ture type</p>
</li>
<li>
<p >
Display the field value on screen, getting the Int32, that was
boxed.</p>
</li>
</ol>
<div class="paragraph-container">
<div class="paragraph-left-side">47</div>
<p >
I do it via the inter&shy;face on purpose as I want to show that it will work
that way.</p>
<div class="paragraph-right-side">47</div>
</div>
<h3 id="nullablet">Nullable&lt;T&gt;</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">48</div>
<p >
It is worth menti&shy;o&shy;ning about the beh&shy;avior of boxing with Nullable value types. This fea&shy;ture of Nullable value types is very attrac&shy;tive as the boxing of a value type which is a sort of null returns null.</p>
<div class="paragraph-right-side">48</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span>? x = 5;
<span style="color:Blue;">int</span>? y = <span style="color:Blue;">null</span>;

<span style="color:Blue;">var</span> boxedX = (<span style="color:Blue;">object</span>)x; <span style="color:Green;">// -&gt; 5</span>
<span style="color:Blue;">var</span> boxedY = (<span style="color:Blue;">object</span>)y; <span style="color:Green;">// -&gt; null</span>
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">49</div>
<p >
This leads us to a pecu&shy;liar conc&shy;lu&shy;sion: as null doesn’t have a type, the
only way to get a type, diffe&shy;rent from the boxed one is the follo&shy;wing:</p>
<div class="paragraph-right-side">49</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span>? x = <span style="color:Blue;">null</span>;
<span style="color:Blue;">var</span> pseudoBoxed = (<span style="color:Blue;">object</span>)x;
<span style="color:Blue;">double</span>? y = (<span style="color:Blue;">double</span>?)pseudoBoxed;
</pre></div>
</div>
<p >
The code works just because you can cast a type to anything you like
with null.</p>
<h2 id="going-deeper-in-boxing">Going deeper in boxing</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">50</div>
<p >
As a final bit, I would like to tell you about <a href="http://referencesource.microsoft.com/#mscorlib/system/enum.cs,36729210e317a805">System.Enum type</a>. Logi&shy;cally this should be a value type as it’s a usual enu&shy;me&shy;ra&shy;tion: ali&shy;a&shy;sing numbers to names in a prog&shy;ram&shy;ming language. However, System.Enum is a refe&shy;rence type. All the enum data types, defined in your field as well as in .NET Frame&shy;work are inhe&shy;rited from System.Enum. It’s a class data type. More&shy;over, it’s an abstract class, inhe&shy;rited from <code>System.ValueType</code>.</p>
<div class="paragraph-right-side">50</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    [Serializable]
    [System.Runtime.InteropServices.ComVisible(<span style="color:Blue;">true</span>)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">abstract</span> <span style="color:Blue;">class</span> Enum : ValueType, IComparable, IFormattable, IConvertible
    {
        <span style="color:Green;">// ...</span>
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">51</div>
<p >
Does it mean that all enu&shy;me&shy;ra&shy;tions are allo&shy;cated on the SOH and when we use them, we over&shy;load the heap and GC? Actually no, as we just use them. Then, we suppose that there is a pool of enu&shy;me&shy;ra&shy;tions somew&shy;here and we just get their instances. No, again. You can use enu&shy;me&shy;ra&shy;tions in struc&shy;tures while marshaling. Enume&shy;ra&shy;tions are usual numbers.</p>
<div class="paragraph-right-side">51</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">52</div>
<p >
The truth is that CLR hacks data type struc&shy;ture when forming it if there is enum <a href="https://github.com/dotnet/coreclr/blob/4b49e4330441db903e6a5b6efab3e1dbb5b64ff3/src/vm/methodtablebuilder.cpp#L1425-L1445">turning a class into a value type</a>:</p>
<div class="paragraph-right-side">52</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Check to see if the class is a valuetype; but we don&#39;t want to mark System.Enum</span>
<span style="color:Green;">// as a ValueType. To accomplish this, the check takes advantage of the fact</span>
<span style="color:Green;">// that System.ValueType and System.Enum are loaded one immediately after the</span>
<span style="color:Green;">// other in that order, and so if the parent MethodTable is System.ValueType and</span>
<span style="color:Green;">// the System.Enum MethodTable is unset, then we must be building System.Enum and</span>
<span style="color:Green;">// so we don&#39;t mark it as a ValueType.</span>
<span style="color:Blue;">if</span>(HasParent() &amp;&amp;
    ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) ||
    GetParentMethodTable() == g_pEnumClass))
{
    bmtProp-&gt;fIsValueClass = <span style="color:Blue;">true</span>;
    HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(),
                                                            g_CompilerServicesUnsafeValueTypeAttribute,
                                                            NULL, NULL);

    IfFailThrow(hr);
    <span style="color:Blue;">if</span> (hr == S_OK)
    {
        SetUnsafeValueClass();
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">53</div>
<p >
Why doing this? In parti&shy;cular, because the idea of inhe&shy;ri&shy;tance — to do a custo&shy;mized enum, you, for example, need to specify the names of possible values. However, it is impos&shy;sible to inherit value types. So, deve&shy;lo&shy;pers designed it to be a refe&shy;rence type that can turn it into a value type when compiled.</p>
<div class="paragraph-right-side">53</div>
</div>
<h2 id="what-if-you-want-to-see-boxing-personally">What if you want to see boxing personally?</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">54</div>
<p >
Fortu&shy;na&shy;tely, you don’t have to use a disas&shy;sembler and get into the code jungle. We have the texts of the whole .NET plat&shy;form core and many of them are iden&shy;tical in terms of .NET Frame&shy;work CLR and Core&shy;CLR. You can click the links below and see the imple&shy;men&shy;ta&shy;tion of boxing right away:</p>
<div class="paragraph-right-side">54</div>
</div>
<ul>
<li>
<p >
There is a sepa&shy;rate group of opti&shy;mi&shy;za&shy;tions each of which uses a
specific type of a processor:</p>
<ul>
<li>
<p >
<em><a href="https://github.com/dotnet/coreclr/blob/master/src/vm/amd64/JitHelpers_InlineGetThread.asm#L86-L148">JIT_BoxFastMP_InlineGetThread</a></em>
(AMD64 - multip&shy;ro&shy;cessor or Server GC, implicit Thread Local Storage)</p>
</li>
<li>
<p >
<em><a href="https://github.com/dotnet/coreclr/blob/8cc7e35dd0a625a3b883703387291739a148e8c8/src/vm/amd64/JitHelpers_Slow.asm#L201-L271">JIT_BoxFastMP</a></em>
(AMD64 - multip&shy;ro&shy;cessor or Server GC)</p>
</li>
<li>
<p >
<em><a href="https://github.com/dotnet/coreclr/blob/8cc7e35dd0a625a3b883703387291739a148e8c8/src/vm/amd64/JitHelpers_Slow.asm#L485-L554">JIT_BoxFastUP</a></em>
(AMD64 - single processor or Work&shy;st&shy;ation GC)</p>
</li>
<li>
<p >
<em><a href="https://github.com/dotnet/coreclr/blob/38a2a69c786e4273eb1339d7a75f939c410afd69/src/vm/i386/jitinterfacex86.cpp#L756-L886">JIT_TrialAlloc::GenBox(..)</a></em>
(x86) connected through Jit&shy;Helpers</p>
</li>
</ul>
</li>
<li>
<p >
In general cases a JIT inlines a call of a helper function
<a href="https://github.com/dotnet/coreclr/blob/a14608efbad1bcb4e9d36a418e1e5ac267c083fb/src/jit/importer.cpp#L5212-L5221">Compiler::impImportAndPushBox(..)</a></p>
</li>
<li>
<p >
Generic-version uses less opti&shy;mized
<a href="https://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.cpp#L3734-L3783">MethodTable::Box(..)</a></p>
<ul>
<li>
<p >
Finally, [Copy&shy;Value&shy;Class&shy;Unchecked(..)] is called
(<a href="https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581">https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581</a>).
Its code shows why it’s better to choose struc&shy;tures with the size up to 8 bytes included.</p>
</li>
</ul>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">55</div>
<p >
Here, the only method is used for unbo&shy;xing:
<em><a href="https://github.com/dotnet/coreclr/blob/03bec77fb4efaa397248a2b9a35c547522221447/src/vm/jithelpers.cpp#L3603-L3626">JIT_Unbox(..)</a></em>, which is a wrapper around <em><a href="https://github.com/dotnet/coreclr/blob/03bec77fb4efaa397248a2b9a35c547522221447/src/vm/jithelpers.cpp#L3574-L3600">JIT_Unbox_Helper(..)</a></em>.</p>
<div class="paragraph-right-side">55</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">56</div>
<p >
Also, it is inte&shy;res&shy;ting that (<a href="https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right">https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right</a>), unbo&shy;xing doesn’t mean copying data to the heap. Boxing means passing a pointer to the heap while testing the compa&shy;ti&shy;bi&shy;lity of types. The IL opcode follo&shy;wing unbo&shy;xing will define the actions with this add&shy;ress. The data might be copied to a local vari&shy;able or the stack for calling a method. Othe&shy;rwise, we would have a double copying; first when copying from the heap to somew&shy;here, and then copying to the desti&shy;na&shy;tion place.</p>
<div class="paragraph-right-side">56</div>
</div>
<h3 id="the-ref-keyword">The ref keyword</h3>
<blockquote>
<p >
TODO</p>
</blockquote>
<h3 id="makeref-reftype-refvalue-arglist">**makeref, **reftype, **refvalue, **arglist</h3>
<blockquote>
<p >
TODO</p>
</blockquote>
<h3 id="implicit-boxing">Implicit boxing</h3>
<blockquote>
<p >
TODO</p>
</blockquote>
<h2 id="questions">Questions</h2>
<h3 id="why.net-clr-cant-do-pooling-for-boxing-itself">Why .NET CLR can’t do pooling for boxing itself?</h3>
<p >
If we talk to any Java deve&shy;loper, we will know two things:</p>
<ul>
<li>
<p >
All value types in Java are boxed, mea&shy;ning they are not essen&shy;ti&shy;ally value types. Inte&shy;gers are also boxed.</p>
</li>
<li>
<p >
For the reason of opti&shy;mi&shy;za&shy;tion all inte&shy;gers from -128 to 127 are taken from the pool of objects.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">57</div>
<p >
So, why this doesn’t happen in .NET CLR during boxing? It is simple. Because we can change the content of a boxed value type, that is we can do the follo&shy;wing:</p>
<div class="paragraph-right-side">57</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">object</span> x = 1;
x.GetType().GetField(<span style="color:#A31515;">&quot;m_value&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138);
Console.WriteLine(x); <span style="color:Green;">// -&gt; 138</span>
</pre></div>
</div>
<p >
Or like this (С++/CLI):</p>
<div class="lang-cpp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> ChangeValue(Object^ obj)
{
    Int32^ i = (Int32^)obj;
    *i = 138;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">58</div>
<p >
If we dealt with poo&shy;ling, then we would change all ones in appli&shy;ca&shy;tion to 138, which is not good.</p>
<div class="paragraph-right-side">58</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">59</div>
<p >
The next is the essence of value types in .NET. They deal with value, mea&shy;ning they work faster. Boxing is rare and addi&shy;tion of boxed numbers belongs to the world of fantasy and bad arch&shy;it&shy;ecture. This is not useful at all.</p>
<div class="paragraph-right-side">59</div>
</div>
<h3 id="why-it-is-not-possible-to-do-boxing-on-stack-instead-of-the-heap-when-you-call-a-method-that-takes-an-object-type-which-is-a-value-type-in-fact">Why it is not possible to do boxing on stack instead of the heap, when you call a method that takes an object type, which is a value type in fact?</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">60</div>
<p >
If the value type boxing is done on the stack and the refe&shy;rence will go to the heap, the refe&shy;rence inside the method can go somew&shy;here else, for example a method can put the refe&shy;rence in the field of a class. The method will then stop, and the method that made boxing will also stop. As a result, the refe&shy;rence will point to a dead space on the stack.</p>
<div class="paragraph-right-side">60</div>
</div>
<h3 id="why-it-is-not-possible-to-use-value-type-as-a-field">Why it is not possible to use Value Type as a field?</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">61</div>
<p >
Some&shy;times we want to use a struc&shy;ture as a field of another struc&shy;ture which uses the first one. Or simpler: use struc&shy;ture as a struc&shy;ture field. Don't ask me why this can be useful. It cannot. If you use a struc&shy;ture as its field or through depen&shy;dence with another struc&shy;ture, you create recur&shy;sion, which means infi&shy;nite size struc&shy;ture. However, .NET Frame&shy;work has some places where you can do it. An example is <code>System.Char</code>, <a href="http://referencesource.microsoft.com/#mscorlib/system/char.cs,02f2b1a33b09362d">which contains itself</a>:</p>
<div class="paragraph-right-side">61</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">struct</span> Char : IComparable, IConvertible
{

    <span style="color:Green;">// Member Variables</span>

    <span style="color:Blue;">internal</span> <span style="color:Blue;">char</span> m_value;

    <span style="color:Green;">//...</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">62</div>
<p >
All CLR primi&shy;tive types are designed this way. We, mere mortals, cannot imple&shy;ment this beh&shy;avior. More&shy;over, we don't need this: it is done to give primi&shy;tive types a spirit of OOP in CLR.</p>
<div class="paragraph-right-side">62</div>
</div>
<h2 id="references">References</h2>
<ul>
<li>
<p >
<a href="https://github.com/mumusan/dotnetex/blob/master/libs/">The library to get a pointer to an object</a></p>
</li>
</ul>

        </div>
        <footer>
            <div class="footer-container">
                <div class="footer-wrap">
                    <img src="../res/img/logo-w-noindex.svg">
                    <p>
                        <a class="footer-link" target="_blank" href="mailto:sidristij@clrium.ru"><i class="far fa-envelope" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://vk.com/clrium"><i class="fab fa-vk" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://youtube.com/clrium"><i class="fab fa-youtube" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://github.com/clrium"><i class="fab fa-github" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="skype:stanislav.sidristyi"><i class="fab fa-skype" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://t.me/clrium_group"><i class="fab fa-telegram" aria-hidden="true"></i></a>
                    </p>
                </div>
            </div>
        </footer>
    </div>
</body>
</html>