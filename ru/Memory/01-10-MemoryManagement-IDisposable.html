<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Platform Architecture</title>
</head>
<body>
    <script src="../../res/jquery.js"></script>
    <link rel="stylesheet" href="../../res/bootstrap.css">
    <link rel="stylesheet" href="../../res/awesome.css">
    <style>

body {
    font-family: PF Regal,Georgia,serif;
    font-size: 16pt;
    font-weight: 300;
    padding-top: 4em;
    background-color: #fdfdfd;
}

.book-title-container {
    width: 100%;
    text-align: center;
    margin: 73px 0 110px 0;
}

.book-title {
    font-size: 57pt;
    margin: 50px 0 70px 0;
    user-select: none;
}
.book-part-title-block {
    display: inline-block;
}
.book-part-title {
    font-size: 21pt;
    color: #656ab6;
    margin: 0 7px;
}

.book-part-title:hover {
    box-shadow: inset 0 -1px #007bff;
    text-decoration: none;
}

.book-superheading-title {
    font-size: 15pt;
    margin: 0 7px;
    color: #656ab6;
}

.article-container
{
    width: 62%;
}

strong {
    font-weight: 500;
}

p, li {
    margin: 0 0 1em;
    line-height: 1.5em;
    font-family: inherit;
}

ol, li {
    margin-top: 1em;
    margin-bottom: 1em;
}

ol {
    padding-left: 1.21em;
}

ul  {
    padding-left: 1em;
}

ol li, ul li {
    padding-left: 0.5em;	
    font-family: inherit;
    text-align: justify;
}

table {
    margin: 30px 0;
    width: 100%;
}

thead {
    background-color: aliceblue;
}

table th {
    font-weight: 400;
}

table td, table th {
    padding: 7px;
    border-top: solid darkgrey 1px;
    border-bottom: solid darkgrey 1px;
    border-right: dotted darkgray 1px;
    border-left: dotted darkgray 1px;
    font-size: smaller;
}

code, *[class*='lang-'] span, *[class*='lang-'] pre {
    font-family: JB Mono, monospace !important;
}

*[class*='lang-'] {
    padding: 0px 0px 25px 0px;
    font-size: 0.75em;
}


*[class*='lang-'] > div, pre > code {
    border-left-color: #eee;
    border-left-style: dotted;
    border-left-width: 3px;
    padding-left: 25px;
    display: block;
    padding-top: 20px;
    padding-bottom: 20px;
}

*[class*='lang-'] > div pre, pre > code pre {
    margin-bottom: 0;
}

p code:not(.highlight), li code:not(.highlight) {
    font-size: 0.7em;
    border: gainsboro;
    border-width: 1px;
    border-style: solid;
    padding: 3px;
    color: darkslateblue;
}

code.highlight {
    font-family: inherit !important;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
}

p code.highlight, li code.highlight {
    padding: 4px;
    background-color: #ffffa1;
}

.wide {
    width:140%;
}

p a, li a {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #b88b59;
}

p a:hover, li a:hover {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #0056b3;
}

blockquote h5 {
    background-color: aquamarine;
    margin: 16px 0 16px -20px;
    padding: 15px 30px 15px;
}

p img {
    width: 95%;
}

blockquote 
{
    padding-left: 0.4em;
    border-left: 0.5em solid rgba(0,0,0,.08);
    font-style: italic;
}

blockquote.big-quote, 
blockquote.breadcrumbs 
{
    background-color: transparent;
    padding: 0;
    border-left: none;
    font-style: normal;
}

blockquote.breadcrumbs, blockquote.breadcrumbs  p
{
    margin: 0;
    padding: 0;
}

blockquote p {
    padding: 1em 1em 1em 0.6em;
    font-family: inherit;
}

blockquote p code {
    font-family: consolas, monospace;
    font-size: 17px;
    padding: 4px 6px;
}

blockquote p em {
    font-weight: 400;
}

blockquote.big-quote > p {
    margin: 0.7em 0 0.7em 0;
    font-family: Charter;
    font-size: 2.5em;
    padding: 0;
    width: 130%;
    line-height: 1em;
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
    padding: 0;
    font-weight: 400;
    font-family: inherit;
}

h1 {
    font-size: 2.2em;
    font-family: Charter,Georgia,serif;
    font-weight: 300;
    margin: 1.8em 0 1.8em 0;
    text-align: center;
    width: 140%;
}

h2 {
    margin-top: 2em;
    font-family: Charter, Arial, Helvetica Neue, sans-serif;
    font-size: 1.25em;
    width: 70%;
}

h3 {
    margin: 1.5em 0 0 0;
    font-size: 1.3em;
    font-weight: 300;
    font-style: italic;
}

h4 {
    margin: 20px 0 10px 0;
    font-size: 16pt;
    font-weight: 500;
    font-style: italic;
}

/* Sidenotes */

.aside-container {
    position: relative;
}
.aside-container p {
    position: relative;
    top: 9px;
}

.aside-container > .aside-side-container {
    display: block;
    position: absolute;
    top: 12px;
    left: 96%;
    width: 34%;
    font-size: 12pt;
    line-height: 20px;
    margin-left: 100px;
    z-index: 1000;
}

.aside-container > .aside-side-container p {
    line-height: 24px;
    font-size: 13pt;
    margin: 0 0 13px 0;
}

.side-regular-block p {
    top: 0;
}

/* Music side player */
.aside-side-container .music-player {
    width: 100%;
    height: 400px;
}

/* media block after h1 */
.aside-container h1 + .aside-side-container.side-media-block h2 {
    margin: 7em 0 1em 0;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-weight: 600;
}

.aside-side-container > li {
    display: block;
    font-family: Charter;
}

.aside-side-container > li ul, .aside-side-container > li ol {
    padding-left: 30px;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.aside-side-container > li li {
    padding-left: 6px;
    margin: 0 0 6px;
    line-height: 22px;

    font-family: Charter;
}

.aside-side-container p {
    line-height: 25px;
    font-size: 13pt;
    margin: 0 0 15px 0;
}

.aside-side-container blockquote {
    border: aliceblue;
    border-left-style: solid;
}

/* Paragraphs numbering */
.paragraph-container {
    position: relative;
}
.paragraph-container p {
    position: relative;
    top: 9px;
}

.paragraph-container p, .aside-container > p {
    text-align: justify;
}

.paragraph-container > .paragraph-left-side, .paragraph-container > .paragraph-right-side  {
    font-family: JB Mono, consolas;
    display: block;
    position: absolute;
    top: 17px;
    font-size: 10pt;
    line-height: 20px;
    color: #86abc473;
    z-index: 1000;
}
.paragraph-container > .paragraph-left-side {
    display: none;
    left: -2.1cm;
    width: 35px;
    user-select: none;
}

.paragraph-container > .paragraph-right-side  {
    display: none;
    left: 100%;
    width: 35px;
    padding-left: 45px;
    user-select: none;
}

.article-container
{
    width: 70%;
}

/* X_MENU */
.menu-title {
    text-align: center;
    margin: 35px 50px 35px 50px;
    font-size: 24pt;
    font-family: Charter;
}

.menu-container ol {
    margin: 0;
    padding: 0;
}

.menu-container ol li {
    margin: 0;
    padding: 0;
}

.header {
    height: 2.5em;
    background-color: white;
    position: relative;
    z-index: 1500;
    width: 100%;
    display: flex;
    justify-content: space-between;
    transition: all 1s;
    top: 0;
    box-shadow: 1px -4px 20px rgba(0, 0, 0, .1);
}

.fixed {
    position: fixed !important;
}

.header > .menu {
    pointer-events: auto;
    float: right;
    height: 40px;
    font-family: Charter, 'Helvetica Neue', Arial, sans-serif;
    font-size: 1em;
    color: #fff;
    margin-top:40px;
    margin-right:40px;
}

.menu a {
    color: #fff;
}
.menu a:hover {
    text-decoration: none;
    color: #fff;
}

#menu__toggle {
    opacity: 0;
}

#menu__toggle:checked ~ .menu__btn > span {
    transform: rotate(45deg);
}
#menu__toggle:checked ~ .menu__btn > span::before {
    top: 0;
    transform: rotate(0);
    background-color: black
}
#menu__toggle:checked ~ .menu__btn > span::after {
    top: 0;
    transform: rotate(90deg);
    background-color: black
}
#menu__toggle:checked ~ .menu__box {
    visibility: visible;
    right: 0;
}

.menu__btn {
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    right: 0;
    width: 2.5em;
    height: 2.5em;
    cursor: pointer;
    z-index: 1;
    margin: 0;
    padding: 0.7em;
}

.menu__btn > span,
.menu__btn > span::before,
.menu__btn > span::after {
    display: block;
    position: absolute;

    width: 1.1em;
    height: 1px;

    background-color: black;

    transition-duration: .25s;
}
.menu__btn > span::before {
    content: '';
    top: -8px;
}
.menu__btn > span::after {
    content: '';
    top: 8px;
}

.menu__box {
    display: block;
    position: fixed;
    visibility: hidden;
    top: 0;
    right: -100%;

    width: 100%;
    height: 100%;

    margin: 0;
    padding: 80px 0;

    list-style: none;

    background-color: white;
    box-shadow: 1px 0px 6px rgba(0, 0, 0, .2);

    transition-duration: .25s;

    overflow-y: auto;
}
.menu__box li a:hover {
    text-decoration: none;
    color: inherit;
}
.menu__list {
    font-size: 0.9em;
    margin: 0 2em 0 2em;
}
.menu__list li {
    text-align: left;
}

/* X_HEADER */

.conflogo {
    margin: 0.5em 0 0 0.8em;
    font-size: 1.1em;
    font-family: Charter;
    user-select: none;
}

.invisible {
    display: none;
}

.header > .menu > div {
    display: inline;
    margin-left: 10px;
    margin-right: 10px;
}

.menu__header_current
{
    text-align: center;
    font-size: 2em;
    margin: 0 0 1em 0;
}

.menu__header_total
{
    text-align: center;
    font-size: 2.4em;
    margin: 1.7em 0 0.3em 0;
}
.menu__header_list 
{
    padding: 0;
    margin-top: 0;
    margin-left: 0;
    margin-right: 0;
}
.menu__header_list > li 
{
    display: inline-block;
    width: 100%;
    margin: 0;
    text-align: center;
    font-family: charter;
}
.menu__header_total_sub
{
    font-size: 1.4em;
    margin: 2em 0 1em 0;
}
.menu__header_total_sub2
{
    font-size: 1.1em;
    margin: 1.5em 0 0.6em 1em;
    text-align: left;
}
/* X_FOOTER */

footer {
    margin-top: 2em;
    background-color: black;
    height: 4em;
}

footer > div {
    box-shadow: 0px 2px 2px rgb(0, 0, 0);
}

.footer-container {
    height: 100%;
}

.footer-wrap {
    color: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 25px 0;
}

.footer-wrap p {
    margin: 0;
    padding: 0px;
    line-height: 1em;
}

.footer-container img {
    height: 1.6em;
    margin-top: auto;
    margin-bottom: auto;
}

.footer-link {
    color: white;
    margin: 0 7px;
    font-size: 1em;
    box-shadow: none;
}

.footer-link:hover {
    color: salmon;
    box-shadow: none;
}

/* MEDIA */
/* XXL */
@media (min-width: 1601px) {
    .book-container
    {
        max-width: 1200px;
        margin-left: auto;
        margin-right: auto;
    }
}

/* XL */
@media (max-width: 1600px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }
}

/* LG */
@media (max-width: 1400px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }

    blockquote.big-quote > p {
        font-size: 2em;
    }
}

/* > MD */
@media (min-width: 992px) {
    .hamburger-menu {
        display: none;
    }
}

/* MD */
@media (max-width: 991px) {
    
    h2 {
        width:80%;
    }

    .book-container
    {
        margin-left: 3cm;
        margin-right: 3cm;
    }
    
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    .book-title {
        font-size: 50pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 15pt;
    }                                     

    .article-container, h1 {
        width: 100%;
    }

    .aside-container p {
        top: 0;
    }

    .aside-container h1 + .aside-side-container.side-media-block h2 {
        display: none;
    }

    .wide {
        width: 100%;     
    }

    .side-regular-block {
        margin: 40px 10px;
        padding-left: 100px;
    }
    .aside-side-container .music-player {
        width: 100%;
        height: 100px;
    }
    .aside-side-container.side-media-block {
        padding: 17px 0;
    }
    .aside-side-container.side-media-block h2 {
        margin-top: 20px;
        font-size: 13pt;
        border: none;
    }

    .aside-container > .aside-side-container
    {
        position: relative;
        top: auto;
        left: auto;
        width: auto;
        height: auto;
        margin: 0;
        padding: 17px;
    }

    blockquote.big-quote > p {
        width: 100%;
        font-size: 2em;
    }

    .paragraph-container .paragraph-left-side {
        left: -55px;
    }

    body {
        font-size: 15pt;
    }

    p code:not(.highlight), li code:not(.highlight) {
        font-size: 11pt;
    }

    p, li {
        line-height: 30px;
    }
    
    li {
        margin: 0 0 10px 0;
    }

    .side-regular-block {
        border-radius: 5px;
        background-image: linear-gradient(180deg,hsla(0,0%,100%,0) 60%,#fff),linear-gradient(70deg,#dbedff 32%,#ebfff0);
        padding: 22px;
    }    

    .menu__list
    {
        margin-top: 0;
        margin-bottom: 0;
    }

    .menu__list, .menu__header_total_sub2
    {
        margin-left: auto;
        margin-right: auto;
        max-width: 800px;
        width: 80%;
    }

    .book-container 
    {
        position: absolute;
        padding: 0 3cm 0 3cm;
        overflow: scroll;
        overflow-x: auto;
        top: 2.5em;
        bottom: 0;
        width: 100%;
        margin: 0;
    }

    footer {
        margin-top: 2em;
        background-color: black;
        height: 4em;
    }

    footer > div {
        position: relative;
        margin: 0 -3cm;
        background: black;
        padding: 0 3cm;
    }
}

/* Smartphone horizontal - SM */
@media (max-width: 767px) {
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    h1 {
        margin: 1.8em 0em 1.8em 0.3em;
    }

    .book-title {
        font-size: 40pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 17pt;
    }

    .book-container {
        padding: 0 2.5cm;
    }
    ul {
        margin-left: 30px;
        margin-right: 30px;
        padding-left: 25px;
    }
    .paragraph-container > .paragraph-left-side {
	    display: block;
        top: 14px;
        font-size: 9pt;
    }
    .paragraph-container > .paragraph-right-side {
    	display: block;
        padding-left: 40px;
        top: 14px;
        font-size: 9pt;
    }
    .footer-container img {
        height: 1.3em;
    } 
}

@media (max-width: 630px) {
    .book-container {
        padding: 0 1.5cm;
    }
    .paragraph-container > .paragraph-left-side {
        left: -33px;
    }
    .paragraph-container > .paragraph-right-side {
        padding-left: 24px;
    }
}
/* Smartphone - XS */
@media (max-width: 575px) {
    .book-container {
        padding: 0 50px 0 30px;
    }
    ul {
        margin: 0;
        padding-left: 20px;
    }

    body {
        font-size: 13pt;
    }

    p code:not(.highlight), li code:not(.highlight) 
    {
        font-size: 10pt;
        padding: 3px;
    }
   
    p, li {
        line-height: 24px;
    }    
    
    .paragraph-container .paragraph-left-side 
    {
        display: none;        
    }
    .paragraph-container .paragraph-right-side 
    {
        padding-left: 21px;
        top: 14px;
	    font-size: 8pt;
    }
    .footer-container img {
        height: 1em;
    } 
    .menu__list {
        margin: 0 1em 0 1em;
    }
    .menu__header_total_sub2
    {
        margin: 1.5em 0 0.6em 1em;
    }
}

/* Fonts */

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-Bold.eot');
    src: local('../../res/fonts/PFRegalTextPro-Bold'),
        url('../../res/fonts/PFRegalTextPro-Bold.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-Bold.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-Medium.eot');
    src: local('../../res/fonts/PFRegalTextPro-Medium'),
        url('../../res/fonts/PFRegalTextPro-Medium.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-Medium.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-BlackItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-BlackItalic'),
        url('../../res/fonts/PFRegalTextPro-BlackItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-BlackItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-BlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-Black.eot');
    src: local('../../res/fonts/PFRegalTextPro-Black'),
        url('../../res/fonts/PFRegalTextPro-Black.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-Black.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-Black.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal UBlack';
    src: url('../../res/fonts/PFRegalTextPro-UBlack.eot');
    src: local('../../res/fonts/PFRegalTextPro-UBlack'),
        url('../../res/fonts/PFRegalTextPro-UBlack.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-UBlack.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-UBlack.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-MediumItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-MediumItalic'),
        url('../../res/fonts/PFRegalTextPro-MediumItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-MediumItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-MediumItalic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-UBlackItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-UBlackItalic'),
        url('../../res/fonts/PFRegalTextPro-UBlackItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-UBlackItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-UBlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-RegularAItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-RegularAItalic'),
        url('../../res/fonts/PFRegalTextPro-RegularAItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-RegularAItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-RegularAItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-BoldItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-BoldItalic'),
        url('../../res/fonts/PFRegalTextPro-BoldItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-BoldItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-BoldItalic.ttf') format('truetype');
    font-weight: bold;
    font-style: italic;
}

@font-face {
    font-family: 'Charter';
    src: url('../../res/fonts/charter-regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}

/*  Regular B */
@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-RegularBItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-RegularBItalic'),
        url('../../res/fonts/PFRegalTextPro-RegularBItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-RegularBItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-RegularBItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-RegularB.eot');
    src: local('../../res/fonts/PFRegalTextPro-RegularB'),
        url('../../res/fonts/PFRegalTextPro-RegularB.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-RegularB.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-RegularB.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Regular.eot');
    src: local('../../res/fonts/JetBrainsMono-Regular'),
        url('../../res/fonts/JetBrainsMono-Regular.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Regular.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Regular.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Italic.eot');
    src: local('../../res/fonts/JetBrainsMono-Italic'),
        url('../../res/fonts/JetBrainsMono-Italic.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Italic.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Italic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Medium.eot');
    src: local('../../res/fonts/JetBrainsMono-Medium'),
        url('../../res/fonts/JetBrainsMono-Medium.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Medium.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Medium-Italic.eot');
    src: local('../../res/fonts/JetBrainsMono-Medium-Italic'),
        url('../../res/fonts/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Medium-Italic.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Medium-Italic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}
@font-face {
    font-family: 'Font Awesome 5 Free';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("../../res/fonts/webfonts/fa-regular-400.eot");
    src: url("../../res/fonts/webfonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), 
         url("../../res/fonts/webfonts/fa-regular-400.woff2") format("woff2"), 
         url("../../res/fonts/webfonts/fa-regular-400.woff") format("woff"), 
         url("../../res/fonts/webfonts/fa-regular-400.ttf") format("truetype"), 
         url("../../res/fonts/webfonts/fa-regular-400.svg#fontawesome") format("svg"); 
    font-display: swap;
}
    
.fa {
    font-family: 'Font Awesome 5 Free';
    font-weight: 400;
    font-display: swap;
}
@font-face {
  font-family: 'Font Awesome 5 Brands';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../../res/fonts/fa-brands-400.eot");
  src: url("../../res/fonts/fa-brands-400.eot?#iefix") format("embedded-opentype"), url("../../res/fonts/fa-brands-400.woff2") format("woff2"), url("../../res/fonts/fa-brands-400.woff") format("woff"), url("../../res/fonts/fa-brands-400.ttf") format("truetype"), url("../../res/fonts/fa-brands-400.svg#fontawesome") format("svg"); 
}

.fab {
  font-family: 'Font Awesome 5 Brands';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../../res/fonts/fa-regular-400.eot");
  src: url("../../res/fonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), url("../../res/fonts/fa-regular-400.woff2") format("woff2"), url("../../res/fonts/fa-regular-400.woff") format("woff"), url("../../res/fonts/fa-regular-400.ttf") format("truetype"), url("../../res/fonts/fa-regular-400.svg#fontawesome") format("svg"); 
}

.far {
  font-family: 'Font Awesome 5 Free';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 900;
  font-display: auto;
  src: url("../../res/fonts/fa-solid-900.eot");
  src: url("../../res/fonts/fa-solid-900.eot?#iefix") format("embedded-opentype"), url("../../res/fonts/fa-solid-900.woff2") format("woff2"), url("../../res/fonts/fa-solid-900.woff") format("woff"), url("../../res/fonts/fa-solid-900.ttf") format("truetype"), url("../../res/fonts/fa-solid-900.svg#fontawesome") format("svg"); 
}
</style>  
    <div class="book-title-container d-none d-lg-block">
        <div class="book-title">Knowledge Base</div>
        <div class="book-part-title-block">pt.1 <a href="../..//ru/Memory/01-00-MemoryManagement-Intro.html" class="book-part-title">Управление памятью</a></div>
        <div class="book-part-title-block">pt.2 <a href="../..//ru/Execution/02-00-ExecutionFlow-Intro.html" class="book-part-title">Поток исполнения команд</a></div>
        <br><a href="#" class="book-superheading-title">Обоснование выбора</a>
        / <a href="#" class="book-superheading-title">Упрощенное описание</a>
        / <a href="#" class="book-superheading-title">Подробное описание</a>
    </div>
    <header class="header fixed d-block d-lg-none">
        <p class="conflogo">KB</p> 

        <!-- mobile-menu -->

        <div class="hamburger-menu">
            <input id="menu__toggle" type="checkbox" />
            <label class="menu__btn" for="menu__toggle">
              <span></span>
            </label>
        
            <div class="menu__box">
                <p class="menu__header_current">На странице</p>
                <ol class="menu__list">
                    <li><a href="#idisposable" onclick="$('#menu__toggle').click(); return true;">
IDisposable</a></li>
<li><a href="#idisposable-1" onclick="$('#menu__toggle').click(); return true;">
Вариации реализации IDisposable</a></li>
<li><a href="#safehandle-criticalhandle-safebuffer" onclick="$('#menu__toggle').click(); return true;">
SafeHandle / CriticalHandle / SafeBuffer / производные</a></li>
<li><a href="#section" onclick="$('#menu__toggle').click(); return true;">
Многопоточность</a></li>
<li><a href="#disposable-design-principle" onclick="$('#menu__toggle').click(); return true;">
Два уровня Disposable Design Principle</a></li>
<li><a href="#dispose" onclick="$('#menu__toggle').click(); return true;">
Как ещё используется Dispose</a></li>
<li><a href="#section-2" onclick="$('#menu__toggle').click(); return true;">
Итоги</a></li>
<li><a href="#section-5" onclick="$('#menu__toggle').click(); return true;">
Выгрузка домена и выход из приложения</a></li>
<li><a href="#section-6" onclick="$('#menu__toggle').click(); return true;">
Типичные ошибки реализации</a></li>
<li><a href="#section-7" onclick="$('#menu__toggle').click(); return true;">
Общие итоги</a></li>

                </ol>
                <p class="menu__header_total">Содержание</p>
                <ul class="menu__header_list">
                    <li>
                        <p class="menu__header_total_sub">
                            Управление памятью
                        </p>
                        <p class="menu__header_total_sub2">
                            Теоретические вопросы:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="../..//ru/Memory/01-00-MemoryManagement-Intro.html">
                                Общие слова
                            </a></p></li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-02-MemoryManagement-Basics.html">Введение в управление памятью</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-04-MemoryManagement-ThreadStack.html">Стек потока</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-06-MemoryManagement-EntitiesLifetime.html">Время жизни сущности</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-08-MemoryManagement-RefVsValueTypes.html">RefTypes, ValueTypes, Boxing &amp; Unboxing</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-10-MemoryManagement-IDisposable.html">Шаблон Disposable</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-12-MemoryManagement-Finalizer.html">Финализация</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-14-MemoryManagement-Results.html">Выводы</a></p>
                            </li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Практические вопросы:
                        </p>
                        <ol class="menu__list" start="9">
                            <li><p><a href="../..//ru/Memory/02-02-MemoryManagement-MemorySpan.html">
                                Memory&lt;T&gt;, Span&lt;T&gt;
                            </a></p></li>
                        </ol> 
                    </li>
                    <li>
                        <p class="menu__header_total_sub">
                            Поток исполнения команд
                        </p>
                        <p class="menu__header_total_sub2">
                            Многопоточность:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="../..//ru/Execution/1-Threads/1-OS/1-threadsScheduling.html">
                                Потоки и планирование потоков
                            </a></p></li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Искл­юч­ител­ьные си­ту­а­ции:
                        </p>
                        <ol class="menu__list" start="2">
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/1-Exceptions-Intro.html">
                                Введение в исключительные ситуации
                            </a></p></li>
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/2-Exceptions-Architecture.html">
                                Архитектура исключительной ситуации
                            </a></p></li>
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/3-Exceptions-Events.html">
                                События об исключительных ситуациях
                            </a></p></li>
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/4-Exceptions-Types.html">
                                Виды исключительных ситуаций
                            </a></p></li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
    </header>

    <div class="book-container">
        <div class="article-container">
            <!--<p class="d-xs-block d-sm-none">XS</p>
            <p class="d-none d-xs-block d-sm-none">SM</p>
            <p class="d-none d-sm-block d-md-none">MD</p>
            <p class="d-none d-lg-block d-xl-none">LG</p>
            <p class="d-none d-xl-block">XL</p> -->
            <blockquote class="breadcrumbs">
<p >
 <a href="../readme.html">Содержание</a> / <a href="./01-00-MemoryManagement-Intro.html">Основы управления памятью</a></p>
</blockquote>
<p >
<img src="./imgs/Disposable-Cover.png" alt="" /></p>
<h1 id="disposable-disposable-design-principle">Шаблон Disposable (Disposable Design Principle)</h1>
<div class="paragraph-container">
<div class="paragraph-left-side">01</div>
<p >
Сей&shy;час, навер&shy;ное, прак&shy;ти&shy;чески любой прог&shy;рам&shy;мист, кото&shy;рый раз&shy;ра&shy;ба&shy;ты&shy;вает на плат&shy;форме .NET, ска&shy;жет, что ничего проще этого пат&shy;терна нет. Что это извест&shy;ный из извест&shy;ней&shy;ших шаб&shy;ло&shy;нов, кото&shy;рые при&shy;ме&shy;ня&shy;ются на плат&shy;форме. Однако даже в самой прос&shy;той и извест&shy;ней&shy;шей проб&shy;лем&shy;ной области всегда най&shy;дется вто&shy;рое дно, а за ним еще ряд скры&shy;тых кар&shy;маш&shy;ков, в кото&shy;рые вы никогда не заг&shy;ля&shy;ды&shy;вали. Однако, как для тех, кто смот&shy;рит тему впер&shy;вые, так и для всех про&shy;чих (просто для того, чтобы каж&shy;дый из вас вспом&shy;нил основы (не про&shy;пус&shy;кайте эти абзацы (я слежу!))) - опи&shy;шем всё от самого начала и до самого конца.</p>
<div class="paragraph-right-side">01</div>
</div>
<h2 id="idisposable">IDisposable</h2>
<p >
Если спро&shy;сить, что такое IDis&shy;po&shy;sable, вы навер&shy;няка отве&shy;тите, что это</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">interface</span> IDisposable
{
    <span style="color:Blue;">void</span> Dispose();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">02</div>
<p >
Для чего же соз&shy;дан интер&shy;фейс? Ведь если у нас есть умный Garbage Collector, кото&shy;рый за нас чис&shy;тит всю память и делает так, чтобы мы вообще не заду&shy;мы&shy;ва&shy;лись о том, как её чис&shy;тить, то ста&shy;но&shy;вится не сов&shy;сем понятно, зачем её вообще зани&shy;маться этим воп&shy;ро&shy;сом. Однако есть нюансы. Сущес&shy;твует неко&shy;то&shy;рое заб&shy;луж&shy;де&shy;ние, что <code>IDisposable</code> сде&shy;лан, чтобы осво&shy;бож&shy;дать неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы. И это только часть правды. Чтобы одно&shy;мо&shy;мен&shy;тно понять, что это не так, дос&shy;та&shy;точно вспом&shy;нить при&shy;меры неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов. Явл&shy;яе&shy;тся ли неуп&shy;рав&shy;ля&shy;е&shy;мым класс <code>File</code>? Нет. Может быть, <code>DbContext</code>? И опять же - нет. Неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс - это то, что не вхо&shy;дит в сис&shy;тему типов .NET. То, что не было соз&shy;дано плат&shy;фор&shy;мой, и нахо&shy;дя&shy;ще&shy;еся вне её ско&shy;упа. Прос&shy;той при&shy;мер - это деск&shy;рип&shy;тор откры&shy;того файла в опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;теме. Деск&shy;рип&shy;тор - это неко&shy;то&shy;рое число, кото&shy;рое одноз&shy;начно иден&shy;ти&shy;фи&shy;ци&shy;рует откры&shy;тый опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;те&shy;мой файл. Не вами, а именно опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;те&shy;мой (вы только про&shy;сите, а откры&shy;вает его всё-таки опер&shy;ци&shy;он&shy;ная сис&shy;тема). Т.е. все управ&shy;ля&shy;ю&shy;щие струк&shy;туры (такие как коор&shy;ди&shy;наты файла на фай&shy;ло&shy;вой сис&shy;теме, его фраг&shy;менты в слу&shy;чае фраг&shy;мен&shy;та&shy;ции и про&shy;чая слу&shy;жеб&shy;ная инфор&shy;ма&shy;ция, номера цилин&shy;дра, головки, сек&shy;тора - в слу&shy;чае маг&shy;нит&shy;ного HDD) нахо&shy;дятся не внутри плат&shy;формы .NET, а внутри ОС. И единст&shy;венным неуп&shy;рав&shy;ля&shy;е&shy;мым ресур&shy;сом, кото&shy;рый ухо&shy;дит в плат&shy;форму .NET, явля&shy;ется Int&shy;Ptr - число. Это число в свою оче&shy;редь обо&shy;ра&shy;чи&shy;ва&shy;ется File&shy;Safe&shy;Handle, кото&shy;рый в свою оче&shy;редь обо&shy;ра&shy;чи&shy;ва&shy;ется клас&shy;сом File. Т.е. класс File сам по себе неуп&shy;рав&shy;ля&shy;е&shy;мым ресур&shy;сом не явля&shy;ется, но акку&shy;му&shy;ли&shy;рует в себе, исполь&shy;зуя допол&shy;ни&shy;тель&shy;ную прос&shy;лойку в виде Int&shy;Ptr, неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс – деск&shy;рип&shy;тор откры&shy;того файла. Как про&shy;ис&shy;хо&shy;дит чте&shy;ние из такого файла? Через ряд мето&shy;дов Win&shy;API или ОС Linux.</p>
<div class="paragraph-right-side">02</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">03</div>
<p >
Вто&shy;рым при&shy;ме&shy;ром неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов явля&shy;ются при&shy;ми&shy;тивы синх&shy;ро&shy;ни&shy;за&shy;ции в мно&shy;го&shy;по&shy;точ&shy;ных и муль&shy;тип&shy;ро&shy;цесс&shy;ных прог&shy;рам&shy;мах. Такие как мьют&shy;ексы, сема&shy;форы. Или же мас&shy;сивы дан&shy;ных, кото&shy;рые пере&shy;да&shy;ются через P/Invoke.</p>
<div class="paragraph-right-side">03</div>
</div>
<blockquote>
<p >
Стоит заме&shy;тить, что ОС не просто передаёт при&shy;ло&shy;же&shy;нию деск&shy;рип&shy;тор неуп&shy;рав&shy;ля&shy;е&shy;мого ресурса, но допол&shy;ни&shy;тельно сох&shy;ра&shy;няет его в таб&shy;лице откры&shy;тых деск&shy;рип&shy;то&shy;ров про&shy;цесса. Cохра&shy;няя при этом за собой воз&shy;мож&shy;ность кор&shy;рект&shy;ного зак&shy;ры&shy;тия этих ресур&shy;сов при завер&shy;ше&shy;нии работы при&shy;ло&shy;же&shy;ния. Т.е. дру&shy;гими сло&shy;вами при выходе из при&shy;ло&shy;же&shy;ния ресурсы зак&shy;рыты будут в любом слу&shy;чае. Однако время работы при&shy;ло&shy;же&shy;ния может быть раз&shy;ным и как резуль&shy;тат - можно полу&shy;чить заб&shy;ло&shy;ки&shy;ро&shy;ван&shy;ный надолго ресурс.</p>
</blockquote>
<div class="paragraph-container">
<div class="paragraph-left-side">04</div>
<p >
Хорошо. С неуп&shy;рав&shy;ля&shy;е&shy;мыми ресур&shy;сами разоб&shy;ра&shy;лись. Зачем же IDis&shy;po&shy;sable в этих слу&shy;чаях? Затем, что .NET Frame&shy;work поня&shy;тия не имеет о том, что про&shy;ис&shy;хо&shy;дит там, где его нет. Если вы откры&shy;ва&shy;ете файл при помощи функ&shy;ций ОС, .NET ничего об этом не узнаёт. Если вы выде&shy;лите учас&shy;ток памяти под собст&shy;венные нужды (нап&shy;ри&shy;мер, при помощи Virtual&shy;Alloc), .NET также ничего об этом не узнает. А если он ничего об этом не знает, он не осво&shy;бо&shy;дит память, кото&shy;рая была занята вызо&shy;вом Virtual&shy;Alloc. Или не зак&shy;роет файл, откры&shy;тый нап&shy;ря&shy;мую через вызов API ОС. Пос&shy;л&shy;едствия этого могут быть совер&shy;шенно раз&shy;ными и неп&shy;редс&shy;ка&shy;зу&shy;е&shy;мыми. Вы можете полу&shy;чить Out&shy;Of&shy;Memory, если выде&shy;ля&shy;ете слиш&shy;ком много памяти и не будете её осво&shy;бож&shy;дать (а, нап&shy;ри&shy;мер, по ста&shy;рой памяти будете просто обну&shy;лять ука&shy;за&shy;тель) либо заб&shy;ло&shy;ки&shy;ру&shy;ете на дол&shy;гое время файл на фай&shy;ло&shy;вой шаре, если он был отк&shy;рыт через сред&shy;ства ОС, но не был зак&shy;рыт. При&shy;мер с фай&shy;ло&shy;выми шарами осо&shy;бенно хорош, потому что бло&shy;ки&shy;ровка оста&shy;нется даже после зак&shy;ры&shy;тия сое&shy;ди&shy;не&shy;ния с сер&shy;ве&shy;ром - на сто&shy;роне IIS. А прав на осво&shy;бож&shy;де&shy;ние бло&shy;ки&shy;ровки у вас может не быть и придётся делать зап&shy;рос адми&shy;нист&shy;ра&shy;то&shy;рам на <code>iisreset</code> либо руч&shy;ное зак&shy;ры&shy;тие ресур&shy;сов при помощи спе&shy;ци&shy;а&shy;ли&shy;зи&shy;ро&shy;ван&shy;ного ПО. Таким обра&shy;зом, реше&shy;ние этой проб&shy;лемы может стать не три&shy;ви&shy;альной зада&shy;чей на удалённом сер&shy;вере.</p>
<div class="paragraph-right-side">04</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">05</div>
<p >
Во всех этих слу&shy;чаях необ&shy;хо&shy;дим уни&shy;вер&shy;саль&shy;ный и узна&shy;ва&shy;е&shy;мый <em>протокол взаимодействия</em> между сис&shy;те&shy;мой типов и прог&shy;рам&shy;мис&shy;том, кото&shy;рый одноз&shy;начно будет иден&shy;ти&shy;фи&shy;ци&shy;ро&shy;вать те типы, кото&shy;рые тре&shy;буют при&shy;ну&shy;ди&shy;тель&shy;ного зак&shy;ры&shy;тия. Этот <em>протокол</em> и есть интер&shy;фейс IDis&shy;po&shy;sable. И зву&shy;чит это при&shy;мерно так: если тип содер&shy;жит реа&shy;ли&shy;за&shy;цию интер&shy;фейса IDis&shy;po&shy;sable, то после того, как вы закон&shy;чите работу с его экземп&shy;ля&shy;ром, вы обя&shy;заны выз&shy;вать Dispose().</p>
<div class="paragraph-right-side">05</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">06</div>
<p >
И ровно по этой при&shy;чине есть два стан&shy;дарт&shy;ных пути его вызова. Ведь, как пра&shy;вило, вы либо создаёте экземп&shy;ляр сущ&shy;ности, чтобы быст&shy;ренько с ней пора&shy;бо&shy;тать в рам&shy;ках одного метода, либо в рам&shy;ках вре&shy;мени жизни экземп&shy;ляра этой сущ&shy;ности.</p>
<div class="paragraph-right-side">06</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">07</div>
<p >
Пер&shy;вый вари&shy;ант - это когда вы обо&shy;ра&shy;чи&shy;ва&shy;ете экземп&shy;ляр в <code>using(...){ ... }</code>. Т.е. вы прямо ука&shy;зы&shy;ва&shy;ете, что по окон&shy;ча&shy;нии блока using объ&shy;ект дол&shy;жен быть унич&shy;то&shy;жен. Т.е. дол&shy;жен быть выз&shy;ван Dispose(). Вто&shy;рой вари&shy;ант - унич&shy;то&shy;жить его по окон&shy;ча&shy;нии вре&shy;мени жизни объ&shy;екта, кото&shy;рый содер&shy;жит ссылку на тот, кото&shy;рый надо осво&shy;бо&shy;дить. Но ведь в .NET кроме метода фина&shy;ли&shy;за&shy;ции нет ничего, что наме&shy;кало бы на авто&shy;ма&shy;ти&shy;чес&shy;кое унич&shy;то&shy;же&shy;ние объ&shy;екта. Пра&shy;вильно? Но фина&shy;ли&shy;за&shy;ция нам сов&shy;сем не под&shy;хо&shy;дит по той при&shy;чине, что она будет неиз&shy;вес&shy;тно когда выз&shy;вана. А нам надо осво&shy;бож&shy;дать именно тогда, когда необ&shy;хо&shy;димо нам: сразу после того, как нам более не нужен, нап&shy;ри&shy;мер, откры&shy;тый файл. Именно поэ&shy;тому мы также дол&shy;жны реа&shy;ли&shy;зо&shy;вать IDis&shy;po&shy;sable у себя и в методе Dispose выз&shy;вать Dispose у всех, кем мы вла&shy;дели, чтобы осво&shy;бо&shy;дить и их тоже. Таким обра&shy;зом, мы соб&shy;лю&shy;даем <em>протокол</em>, и это очень важно. Ведь если кто-то начал соб&shy;лю&shy;дать некий про&shy;то&shy;кол, его дол&shy;жны соб&shy;лю&shy;дать все участ&shy;ники про&shy;цесса: иначе будут проб&shy;лемы.</p>
<div class="paragraph-right-side">07</div>
</div>
<h2 id="idisposable-1">Вариации реализации IDisposable</h2>
<p >
Давайте пойдём в реа&shy;ли&shy;за&shy;циях IDis&shy;po&shy;sable от прос&shy;того к слож&shy;ному.</p>
<div class="paragraph-container">
<div class="paragraph-left-side">08</div>
<p >
Пер&shy;вая и самая прос&shy;тая реа&shy;ли&shy;за&shy;ция, кото&shy;рая только может прийти в голову, - это просто взять и реа&shy;ли&shy;зо&shy;вать IDis&shy;po&shy;sable:</p>
<div class="paragraph-right-side">08</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> ResourceHolder : IDisposable
{
    DisposableResource _anotherResource = <span style="color:Blue;">new</span> DisposableResource();

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        _anotherResource.Dispose();
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">09</div>
<p >
Т.е. для начала мы создаём экземп&shy;ляр неко&shy;то&shy;рого ресурса, кото&shy;рый дол&shy;жен быть осво&shy;бождён: этот ресурс и осво&shy;бож&shy;да&shy;ется в методе Dispose(). Един&shy;ствен&shy;ное, чего здесь нет и что делает реа&shy;ли&shy;за&shy;цию не кон&shy;сис&shy;тент&shy;ной, - это воз&shy;мож&shy;ность даль&shy;ней&shy;шей работы с экземп&shy;ля&shy;ром класса после его раз&shy;ру&shy;ше&shy;ния мето&shy;дом <code>Dispose()</code>:</p>
<div class="paragraph-right-side">09</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> ResourceHolder : IDisposable
{
    <span style="color:Blue;">private</span> DisposableResource _anotherResource = <span style="color:Blue;">new</span> DisposableResource();
    <span style="color:Blue;">private</span> <span style="color:Blue;">bool</span> _disposed;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        <span style="color:Blue;">if</span>(_disposed) <span style="color:Blue;">return</span>;

        _anotherResource.Dispose();
        _disposed = <span style="color:Blue;">true</span>;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> CheckDisposed()
    {
        <span style="color:Blue;">if</span>(_disposed) {
            <span style="color:Blue;">throw</span> <span style="color:Blue;">new</span> ObjectDisposedException();
        }
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">10</div>
<p >
Вызов Check&shy;Disposed() необ&shy;хо&shy;димо вызы&shy;вать пер&shy;вым выра&shy;же&shy;нием во всех пуб&shy;лич&shy;ных мето&shy;дах класса. Однако, если для раз&shy;ру&shy;ше&shy;ния управ&shy;ля&shy;е&shy;мого ресурса, коим явля&shy;ется <code>DisposableResource</code>, полу&shy;чен&shy;ная струк&shy;тура класса <code>ResourceHolder</code> выг&shy;ля&shy;дит нор&shy;мально, то для слу&shy;чай инкап&shy;су&shy;ли&shy;ро&shy;ва&shy;ния неуп&shy;рав&shy;ля&shy;е&shy;мого ресурса - нет.</p>
<div class="paragraph-right-side">10</div>
</div>
<p >
Давайте при&shy;ду&shy;маем вари&shy;ант с неуп&shy;рав&shy;ля&shy;е&shy;мым ресур&shy;сом.</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> FileWrapper : IDisposable
{
    IntPtr _handle;

    <span style="color:Blue;">public</span> FileWrapper(<span style="color:Blue;">string</span> name)
    {
        _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        CloseHandle(_handle);
    }

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>, EntryPoint = <span style="color:#A31515;">&quot;CreateFile&quot;</span>, SetLastError = <span style="color:Blue;">true</span>)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> IntPtr CreateFile(String lpFileName,
        UInt32 dwDesiredAccess, UInt32 dwShareMode,
        IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition,
        UInt32 dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>, SetLastError=<span style="color:Blue;">true</span>)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">bool</span> CloseHandle(IntPtr hObject);
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">11</div>
<p >
Так какая раз&shy;ница в пове&shy;де&shy;нии двух пос&shy;лед&shy;них при&shy;ме&shy;ров? В пер&shy;вом вари&shy;анте у нас опи&shy;сано вза&shy;и&shy;мо&shy;д&shy;ействие управ&shy;ля&shy;е&shy;мого ресурса с дру&shy;гим управ&shy;ля&shy;е&shy;мым. Это озна&shy;чает, что в слу&shy;чае кор&shy;рект&shy;ной работы прог&shy;раммы ресурс будет осво&shy;бождён в любом слу&shy;чае. Ведь <code>DisposableResource</code> у нас - управ&shy;ля&shy;е&shy;мый, а зна&shy;чит, .NET CLR о нём прек&shy;расно знает и, в слу&shy;чае некор&shy;рект&shy;ного пове&shy;де&shy;ния осво&shy;бо&shy;дит из-под него память. Заметьте, что я наме&shy;ренно не делаю ника&shy;ких пред&shy;по&shy;ло&shy;же&shy;ний о том, что тип <code>DisposableResource</code> инкап&shy;су&shy;ли&shy;рует. Там может быть какая угодно логика и струк&shy;тура. Она может содер&shy;жать как управ&shy;ля&shy;е&shy;мые, так и неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы. <em>Нас это волновать не должно</em>. Нас же не про&shy;сят каж&shy;дый раз деком&shy;пи&shy;ли&shy;ро&shy;вать чужие биб&shy;ли&shy;о&shy;теки и смот&shy;реть, какие типы что исполь&shy;зуют: управ&shy;ля&shy;е&shy;мые или неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы. А если <em>наш тип</em> исполь&shy;зует неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс, мы не можем этого не знать. Это мы делаем в классе <code>FileWrapper</code>. Так что же про&shy;и&shy;зойдёт в этом слу&shy;чае?</p>
<div class="paragraph-right-side">11</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">12</div>
<p >
Если мы исполь&shy;зуем неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы, полу&shy;ча&shy;ется, что у нас опять же два вари&shy;анта: когда всё хорошо и метод Dispose выз&shy;вался (тогда всё хорошо) и когда что-то слу&shy;чи&shy;лось и метод Dispose отра&shy;бо&shy;тать не смог. Сразу ого&shy;во&shy;римся, почему этого может не про&shy;изойти:</p>
<div class="paragraph-right-side">12</div>
</div>
<ul>
<li>
<p >
Если мы исполь&shy;зуем <code>using(obj) { ... }</code>, то во внут&shy;рен&shy;нем блоке кода может воз&shy;ник&shy;нуть исклю&shy;че&shy;ние, кото&shy;рое перех&shy;ва&shy;ты&shy;ва&shy;ется бло&shy;ком <code>finally</code>, кото&shy;рый нам не видно (это син&shy;так&shy;си&shy;чес&shy;кий сахар C#). В этом блоке неявно вызы&shy;ваетcя Dispose. Однако есть слу&shy;чаи, когда этого не про&shy;ис&shy;хо&shy;дит. Нап&shy;ри&shy;мер, <code>StackOverflowException</code>, кото&shy;рый не перех&shy;ва&shy;ты&shy;ва&shy;ется ни <code>catch</code>, ни <code>finally</code>. Это всегда надо учи&shy;ты&shy;вать. Ведь если у вас некий поток уйдёт в рекур&shy;сию и в неко&shy;то&shy;рой точке выле&shy;тит по <code>StackOverflowException</code>, то те ресурсы, кото&shy;рые были зах&shy;ва&shy;чены и не были осво&shy;бож&shy;дены, забу&shy;дутся ран&shy;тай&shy;мом .NET. Ведь он поня&shy;тия не имеет, как осво&shy;бож&shy;дать неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы: они повис&shy;нут в памяти до тех пор, пока ОС не осво&shy;бо&shy;дит их сама (нап&shy;ри&shy;мер, при выходе из вашей прог&shy;раммы, а иногда и неоп&shy;ре&shy;делённое время уже после завер&shy;ше&shy;ния работы при&shy;ло&shy;же&shy;ния).</p>
</li>
<li>
<p >
Если мы вызы&shy;ваем Dispose() из дру&shy;гого Dispose(). Тогда может так полу&shy;читься, что опять же мы не смо&shy;жем до него дойти. И тут воп&shy;рос вовсе не в забыв&shy;чи&shy;вости автора при&shy;ло&shy;же&shy;ния: мол, забыл Dispose() выз&shy;вать. Нет. Опять же, воп&shy;рос в любых исклю&shy;че&shy;ниях. Но теперь речь идёт не только об исклю&shy;че&shy;ниях, обру&shy;ша&shy;ю&shy;щих поток при&shy;ло&shy;же&shy;ния. Тут уже речь идёт вообще о любых исклю&shy;че&shy;ниях, кото&shy;рые при&shy;ве&shy;дут к тому, что алго&shy;ритм не дойдёт до вызова внеш&shy;него Dispose(), кото&shy;рый вызо&shy;вет наш.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">13</div>
<p >
Во всех таких слу&shy;чаях воз&shy;ник&shy;нет ситу&shy;а&shy;ция под&shy;ве&shy;шен&shy;ных в воз&shy;духе неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов. Ведь Garbage Collector поня&shy;тия не имеет, что их нужно соб&shy;рать. Мак&shy;си&shy;мум что он сде&shy;лает - при оче&shy;ред&shy;ном про&shy;ходе поймёт, что на граф объ&shy;ек&shy;тов, содер&shy;жа&shy;щих наш объ&shy;ект типа <code>FileWrapper</code>, поте&shy;ряна пос&shy;лед&shy;няя ссылка и память перетрётся теми объ&shy;ек&shy;тами, на кото&shy;рые ссылки есть.</p>
<div class="paragraph-right-side">13</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">14</div>
<p >
Как же защи&shy;титься от подоб&shy;ного? Для этих слу&shy;чаев мы обя&shy;заны реа&shy;ли&shy;зо&shy;вать фина&shy;ли&shy;за&shy;тор объ&shy;екта. Фина&shy;ли&shy;за&shy;тор не слу&shy;чайно имеет именно такое наз&shy;ва&shy;ние. Это вовсе не дест&shy;рук&shy;тор, как может пока&shy;заться изна&shy;чально из-за схо&shy;жести объ&shy;яв&shy;ле&shy;ния фина&shy;ли&shy;за&shy;то&shy;ров в C# и дест&shy;рук&shy;то&shy;ров в C++. Фина&shy;ли&shy;за&shy;тор, в отли&shy;чии от дест&shy;рук&shy;тора, вызо&shy;вется <em>гарантированно</em>, тогда как дест&shy;рук&shy;тор может и не выз&shy;ваться (ровно как и <code>Dispose()</code>). Фина&shy;ли&shy;за&shy;тор вызы&shy;ва&shy;ется, когда запус&shy;ка&shy;ется Garbage Collec&shy;tion (пока этого зна&shy;ния дос&shy;та&shy;точно, но по факту всё нес&shy;колько слож&shy;нее), и пред&shy;наз&shy;на&shy;чен для гаран&shy;ти&shy;ро&shy;ван&shy;ного осво&shy;бож&shy;де&shy;ния зах&shy;ва&shy;чен&shy;ных ресур&shy;сов, если <em>что-то пошло не так</em>. И для слу&shy;чая осво&shy;бож&shy;де&shy;ния неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов мы <em>обязаны</em> реа&shy;ли&shy;зо&shy;вы&shy;вать фина&shy;ли&shy;за&shy;тор. Также, пов&shy;то&shy;рюсь, из-за того, что фина&shy;ли&shy;за&shy;тор вызы&shy;ва&shy;ется при запуске GC, в общем слу&shy;чае вы поня&shy;тия не име&shy;ете, когда это про&shy;и&shy;зойдёт.</p>
<div class="paragraph-right-side">14</div>
</div>
<p >
Давайте рас&shy;ши&shy;рим наш код:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> FileWrapper : IDisposable
{
    IntPtr _handle;

    <span style="color:Blue;">public</span> FileWrapper(<span style="color:Blue;">string</span> name)
    {
        _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        InternalDispose();
        GC.SuppressFinalize(<span style="color:Blue;">this</span>);
    }

    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> InternalDispose()
    {
        CloseHandle(_handle);
    }

    ~FileWrapper()
    {
        InternalDispose();
    }

    <span style="color:Gray;">///</span><span style="color:Green;"> other methods</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">15</div>
<p >
Мы уси&shy;лили при&shy;мер зна&shy;ни&shy;ями о про&shy;цессе фина&shy;ли&shy;за&shy;ции и тем самым обе&shy;зо&shy;па&shy;сили при&shy;ло&shy;же&shy;ние от потери инфор&shy;ма&shy;ции о ресур&shy;сах, если что-то пошло не так и Dispose() выз&shy;ван не будет. Допол&shy;ни&shy;тельно, мы сде&shy;лали вызов GC.Suppress&shy;Finalize для того, чтобы отклю&shy;чить фина&shy;ли&shy;за&shy;цию экземп&shy;ляра типа, если для него был выз&shy;ван Dispose(). Нам же не надо дважды осво&shy;бож&shy;дать один и тот же ресурс? Также это стоит сде&shy;лать по дру&shy;гой при&shy;чине: мы сни&shy;маем наг&shy;рузку с оче&shy;реди на фина&shy;ли&shy;за&shy;цию, уско&shy;ряя слу&shy;чай&shy;ный учас&shy;ток кода, в парал&shy;лели с кото&shy;рым будет в слу&shy;чай&shy;ном буду&shy;щем отра&shy;ба&shy;ты&shy;вать фина&shy;ли&shy;за&shy;ция.</p>
<div class="paragraph-right-side">15</div>
</div>
<p >
Теперь давайте ещё уси&shy;лим наш при&shy;мер:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> FileWrapper : IDisposable
{
    IntPtr _handle;
    <span style="color:Blue;">bool</span> _disposed;

    <span style="color:Blue;">public</span> FileWrapper(<span style="color:Blue;">string</span> name)
    {
        _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        <span style="color:Blue;">if</span>(_disposed) <span style="color:Blue;">return</span>;
        _disposed = <span style="color:Blue;">true</span>;

        InternalDispose();
        GC.SuppressFinalize(<span style="color:Blue;">this</span>);
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> CheckDisposed()
    {
        <span style="color:Blue;">if</span>(_disposed) {
            <span style="color:Blue;">throw</span> <span style="color:Blue;">new</span> ObjectDisposedException();
        }
    }

    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> InternalDispose()
    {
        CloseHandle(_handle);
    }

    ~FileWrapper()
    {
        InternalDispose();
    }

    <span style="color:Gray;">///</span><span style="color:Green;"> other methods</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">16</div>
<p >
Теперь наш при&shy;мер реа&shy;ли&shy;за&shy;ции типа, инкап&shy;су&shy;ли&shy;ру&shy;ю&shy;щего неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс, выг&shy;ля&shy;дит закон&shy;чен&shy;ным. Пов&shy;тор&shy;ный <code>Dispose()</code>, к сожа&shy;ле&shy;нию, явля&shy;ется де-факто стан&shy;дар&shy;том плат&shy;формы, и мы поз&shy;во&shy;ляем его выз&shy;вать. Замечу, что зачас&shy;тую люди допус&shy;кают пов&shy;тор&shy;ный вызов <code>Dispose()</code> для того, чтобы избе&shy;жать мороки с вызы&shy;ва&shy;ю&shy;щим кодом, и это не пра&shy;вильно. Однако поль&shy;зо&shy;ва&shy;тель вашей биб&shy;ли&shy;о&shy;теки с огляд&shy;кой на доку&shy;мен&shy;та&shy;цию MS может так не счи&shy;тать и допус&shy;кать мно&shy;жест&shy;вен&shy;ные вызовы Dispose(). Вызов же дру&shy;гих пуб&shy;лич&shy;ных мето&shy;дов в любом слу&shy;чае ломает целост&shy;ность объ&shy;екта. Если мы раз&shy;ру&shy;шили объ&shy;ект, зна&shy;чит с ним рабо&shy;тать более нельзя. Это в свою оче&shy;редь озна&shy;чает, что мы обя&shy;заны встав&shy;лять вызов <code>CheckDisposed</code> в начало каж&shy;дого пуб&shy;лич&shy;ного метода.</p>
<div class="paragraph-right-side">16</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">17</div>
<p >
Однако в этом коде сущес&shy;твует очень серьёзная проб&shy;лема, кото&shy;рая не даст ему рабо&shy;тать так, как заду&shy;мали мы. Если мы вспом&shy;ним, как отра&shy;ба&shy;ты&shy;вает про&shy;цесс сборки мусора, то заме&shy;тим одну деталь. При сборке мусора GC <em>в первую очередь</em> фина&shy;ли&shy;зи&shy;рует всё, что нап&shy;ря&shy;мую унас&shy;ле&shy;до&shy;вано от <em>Object</em>, после чего при&shy;ни&shy;ма&shy;ется за те объ&shy;екты, кото&shy;рые реа&shy;ли&shy;зуют <em>CriticalFinalizerObject</em>. У нас же полу&shy;ча&shy;ется, что оба класса, кото&shy;рые мы спр&shy;ое&shy;кт&shy;ир&shy;ов&shy;али, нас&shy;ле&shy;дуют Object: и это проб&shy;лема. Мы поня&shy;тия не имеем, в каком порядке мы уйдём на &laquo;пос&shy;лед&shy;нюю милю&raquo;. Тем не менее, более высо&shy;ко&shy;уров&shy;не&shy;вый объ&shy;ект может пытаться рабо&shy;тать с объ&shy;ек&shy;том, кото&shy;рый хра&shy;нит неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс - в своём фина&shy;ли&shy;за&shy;торе (хотя это уже зву&shy;чит как пло&shy;хая идея). Тут нам бы сильно при&shy;го&shy;дился поря&shy;док фина&shy;ли&shy;за&shy;ции. И для того чтобы его задать - мы дол&shy;жны унас&shy;ле&shy;до&shy;вать наш тип, инкап&shy;су&shy;ли&shy;ру&shy;ю&shy;щий unma&shy;naged ресурс, от <code>CriticalFinalizerObject</code>.</p>
<div class="paragraph-right-side">17</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">18</div>
<p >
Вто&shy;рая при&shy;чина имеет более глу&shy;бо&shy;кие корни. Предс&shy;тавьте себе, что вы поз&shy;во&shy;лили себе напи&shy;сать при&shy;ло&shy;же&shy;ние, кото&shy;рое не сильно забо&shy;тится о памяти. Алло&shy;ци&shy;рует в огром&shy;ных коли&shy;чест&shy;вах без кеши&shy;ро&shy;ва&shy;ния и про&shy;чих пре&shy;муд&shy;рос&shy;тей. Однажды такое при&shy;ло&shy;же&shy;ние зава&shy;лится с Out&shy;Of&shy;Memory&shy;Exception. А когда при&shy;ло&shy;же&shy;ние падает с этим исклю&shy;че&shy;нием, воз&shy;ни&shy;кают осо&shy;бые усло&shy;вия испол&shy;не&shy;ния кода: ему нельзя что-либо пытаться алло&shy;ци&shy;ро&shy;вать. Ведь это при&shy;ведёт к пов&shy;тор&shy;ному исклю&shy;че&shy;нию, даже если пре&shy;ды&shy;ду&shy;щее было пой&shy;мано. Это вовсе не обоз&shy;на&shy;чает, что мы не дол&shy;жны соз&shy;да&shy;вать новые экземп&shy;ляры объ&shy;ек&shy;тов. К этому исклю&shy;че&shy;нию может при&shy;вести обыч&shy;ный вызов метода. Нап&shy;ри&shy;мер, вызов метода фина&shy;ли&shy;за&shy;ции. Напомню, что методы ком&shy;пи&shy;ли&shy;ру&shy;ются тогда, когда они вызы&shy;ва&shy;ются в пер&shy;вый раз. И это обыч&shy;ное пове&shy;де&shy;ние. Как же убе&shy;речься от этой проб&shy;лемы? Дос&shy;та&shy;точно легко. Если вы унас&shy;ле&shy;ду&shy;ете объ&shy;ект от <em>CriticalFinalizerObject</em>, то <em>все</em> методы этого типа будут ком&shy;пи&shy;ли&shy;ро&shy;ваться сразу же, при заг&shy;рузке типа в память. Мало того, если вы поме&shy;тите методы атри&shy;бу&shy;том <em>[PrePrepareMethod]</em>, то они также будут пред&shy;ва&shy;ри&shy;тельно ском&shy;пи&shy;ли&shy;ро&shy;ваны и будут безо&shy;пас&shy;ными с точки зре&shy;ния вызова при нех&shy;ватке ресур&shy;сов.</p>
<div class="paragraph-right-side">18</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">19</div>
<p >
Почему это так важно? Зачем тра&shy;тить так много уси&shy;лий на тех, кто уйдёт в мир иной? А всё дело в том, что неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы могут повис&shy;нуть в сис&shy;теме очень надолго. Даже после того, как ваше при&shy;ло&shy;же&shy;ние завер&shy;шит работу. Даже после пере&shy;заг&shy;рузки ком&shy;пьютера: если поль&shy;зо&shy;ва&shy;тель отк&shy;рыл в вашем при&shy;ло&shy;же&shy;нии файл с сете&shy;вого диска, тот будет заб&shy;ло&shy;ки&shy;ро&shy;ван удалённым хос&shy;том и отпу&shy;щен либо по тайм-ауту, либо когда вы осво&shy;бо&shy;дите ресурс, зак&shy;рыв файл. Если ваше при&shy;ло&shy;же&shy;ние выле&shy;тит в момент откры&shy;того файла, то он не будет зак&shy;рыт даже после пере&shy;заг&shy;рузки. Придётся ждать дос&shy;та&shy;точно про&shy;дол&shy;жи&shy;тель&shy;ное время для того, чтобы удалённый хост отпус&shy;тил бы его. Плюс ко всему вам нельзя допус&shy;кать выб&shy;роса исклю&shy;че&shy;ний в фина&shy;ли&shy;за&shy;то&shy;рах - это при&shy;ведёт к уско&shy;рен&shy;ной гибели CLR и окон&shy;ча&shy;тель&shy;ному выб&shy;росу из при&shy;ло&shy;же&shy;ния: вызовы фина&shy;ли&shy;за&shy;то&shy;ров не обо&shy;ра&shy;чи&shy;ва&shy;ются <em>try .. catch</em>. Т.е. осво&shy;бож&shy;дая ресурс, вам надо быть уве&shy;рен&shy;ными в том, что он ещё может быть осво&shy;бождён. И пос&shy;лед&shy;ний не менее инте&shy;рес&shy;ный факт - если CLR осу&shy;щес&shy;твляет ава&shy;рий&shy;ную выг&shy;рузку домена, фина&shy;ли&shy;за&shy;торы типов, про&shy;из&shy;вод&shy;ных от <em>CriticalFinalizerObject</em>, также будут выз&shy;ваны, в отли&shy;чие от тех, кто нас&shy;ле&shy;до&shy;вался нап&shy;ря&shy;мую от <em>Object</em>.</p>
<div class="paragraph-right-side">19</div>
</div>
<h2 id="safehandle-criticalhandle-safebuffer">SafeHandle / CriticalHandle / SafeBuffer / производные</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">20</div>
<p >
У меня есть неко&shy;то&shy;рое ощу&shy;ще&shy;ние, что я для вас сей&shy;час отк&shy;рою ящик Пан&shy;доры. Давайте пого&shy;во&shy;рим про спе&shy;ци&shy;альные типы: Safe&shy;Handle, Critical&shy;Handle и их про&shy;из&shy;вод&shy;ные. И закон&shy;чим уже, нако&shy;нец, наш шаб&shy;лон типа, пре&shy;дос&shy;тав&shy;ля&shy;ю&shy;щего дос&shy;туп к unma&shy;naged ресурсу. Но перёд этим давайте поп&shy;ро&shy;буем пере&shy;чис&shy;лить всё, что к нам <em>обычно</em> идёт из unma&shy;naged мира:</p>
<div class="paragraph-right-side">20</div>
</div>
<ul>
<li>
<p >
Пер&shy;вое и самое ожи&shy;да&shy;е&shy;мое, что оттуда обычно идёт, - это деск&shy;рип&shy;торы (han&shy;dles). Для раз&shy;ра&shy;бот&shy;чика .NET это может быть абсо&shy;лютно пус&shy;тым сло&shy;вом, но это очень важ&shy;ная сос&shy;тав&shy;ля&shy;ю&shy;щая мира опе&shy;ра&shy;ци&shy;он&shy;ных сис&shy;тем. По своей сути handle - это 32-х либо 64-х раз&shy;ряд&shy;ное число, опре&shy;де&shy;ля&shy;ю&shy;щее откры&shy;тую сес&shy;сию вза&shy;и&shy;мо&shy;д&shy;ействия с опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;те&shy;мой. Т.е., нап&shy;ри&shy;мер, откры&shy;ва&shy;ете вы файл, чтобы с ним пора&shy;бо&shy;тать, а в ответ от Win&shy;Api-фун&shy;к&shy;ции полу&shy;чили деск&shy;рип&shy;тор. После чего, исполь&shy;зуя его, можете про&shy;дол&shy;жать рабо&shy;тать именно с ним: дела&shy;ете <em>Seek</em>, <em>Read</em>, <em>Write</em> опе&shy;ра&shy;ции. Вто&shy;рой при&shy;мер: откры&shy;ва&shy;ете сокет для работы с сетью. И опять же: опе&shy;ра&shy;ци&shy;он&shy;ная сис&shy;тема отдаст вам деск&shy;рип&shy;тор. В мире .NET деск&shy;рип&shy;торы хра&shy;нятся в типе <em>IntPtr</em>;</p>
</li>
<li>
<p >
Вто&shy;рое - это мас&shy;сивы дан&shy;ных. Сущес&shy;твует нес&shy;колько путей работы с неуп&shy;рав&shy;ля&shy;е&shy;мыми мас&shy;си&shy;вами: либо рабо&shy;тать с ним через unsafe код (клю&shy;че&shy;вое слово unsafe), либо исполь&shy;зо&shy;вать Safe&shy;Buffer, кото&shy;рый обернёт буфер дан&shy;ных удоб&shy;ным .NET-клас&shy;сом. Замечу, что хоть пер&shy;вый спо&shy;соб быс&shy;т&shy;рее (вы можете сильно опти&shy;ми&shy;зи&shy;ро&shy;вать циклы, нап&shy;ри&shy;мер), то вто&shy;рой спо&shy;соб - нам&shy;ного безо&shy;пас&shy;нее. Ведь он исполь&shy;зует Safe&shy;Handle как основу для работы;</p>
</li>
<li>
<p >
Строки. Со стро&shy;ками всё нес&shy;колько проще, потому что наша задача - опре&shy;де&shy;лить фор&shy;мат и коди&shy;ровку строки, кото&shy;рую мы заби&shy;раем. Далее строка копи&shy;ру&shy;ется к нам (класс string - immu&shy;table) и мы дальше ни о чём не думаем.</p>
</li>
<li>
<p >
Value&shy;Types, кото&shy;рые заби&shy;ра&shy;ются копи&shy;ро&shy;ва&shy;нием и о судьбе кото&shy;рых думать вообще нет ника&shy;кой необ&shy;хо&shy;ди&shy;мости.</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">21</div>
<p >
Safe&shy;Handle - это спе&shy;ци&shy;альный класс .NET CLR, кото&shy;рый нас&shy;ле&shy;дует Critical&shy;Finalizer&shy;Object и кото&shy;рый приз&shy;ван обер&shy;нуть деск&shy;рип&shy;торы опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;темы мак&shy;си&shy;мально безо&shy;пасно и удобно.</p>
<div class="paragraph-right-side">21</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

[SecurityCritical, SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode=<span style="color:Blue;">true</span>)]
<span style="color:Blue;">public</span> <span style="color:Blue;">abstract</span> <span style="color:Blue;">class</span> SafeHandle : CriticalFinalizerObject, IDisposable
{
    <span style="color:Blue;">protected</span> IntPtr handle;        <span style="color:Green;">// Дескриптор, пришедший от ОС</span>
    <span style="color:Blue;">private</span> <span style="color:Blue;">int</span> _state;             <span style="color:Green;">// Состояние (валидность, счётчик ссылок)</span>
    <span style="color:Blue;">private</span> <span style="color:Blue;">bool</span> _ownsHandle;       <span style="color:Green;">// Флаг возможности освободить handle. Может так получиться, что мы оборачиваем чужой handle и освобождать его не имеем права</span>
    <span style="color:Blue;">private</span> <span style="color:Blue;">bool</span> _fullyInitialized; <span style="color:Green;">// Экземпляр проинициализирован</span>

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
    <span style="color:Blue;">protected</span> SafeHandle(IntPtr invalidHandleValue, <span style="color:Blue;">bool</span> ownsHandle)
    {
    }

    <span style="color:Green;">// Финализатор по шаблону вызывает Dispose(false)</span>
    [SecuritySafeCritical]
    ~SafeHandle()
    {
        Dispose(<span style="color:Blue;">false</span>);
    }

    <span style="color:Green;">// Выставление hanlde может идти как вручную, так и при помощи p/invoke Marshal - автоматически</span>
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    <span style="color:Blue;">protected</span> <span style="color:Blue;">void</span> SetHandle(IntPtr handle)
    {
        <span style="color:Blue;">this</span>.handle = handle;
    }

    <span style="color:Green;">// Метод необходим для того, чтобы с IntPtr можно было бы работать напрямую. Используется</span>
    <span style="color:Green;">// для определения того, удалось ли создать дескриптор, сравнив его с одим из ранее</span>
    <span style="color:Green;">// определённых известных значений. Обратите внимание, что метод опасен по двум причинам:</span>
    <span style="color:Green;">//  - Если дескриптор отмечен как недопустимый с помощью SetHandleasInvalid, DangerousGetHandle</span>
    <span style="color:Green;">//    то всё равно вернёт исходное значение дескриптора.</span>
    <span style="color:Green;">//  - Возвращённый дескриптор может быть переиспользован в любом месте. Это может как минимум</span>
    <span style="color:Green;">//    означать, что он без обратной связи перестанет работать. В худшем случае при прямой передаче</span>
    <span style="color:Green;">//    IntPtr в другое место, он может уйти в ненадёжный код и стать вектором атаки на приложение</span>
    <span style="color:Green;">//    через подмену ресурса на одном IntPtr</span>
    [ResourceExposure(ResourceScope.None), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    <span style="color:Blue;">public</span> IntPtr DangerousGetHandle()
    {
        <span style="color:Blue;">return</span> handle;
    }

    <span style="color:Green;">// Ресурс закрыт (более не доступен для работы)</span>
    <span style="color:Blue;">public</span> <span style="color:Blue;">bool</span> IsClosed {
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        <span style="color:Blue;">get</span> { <span style="color:Blue;">return</span> (_state &amp; 1) == 1; }
    }

    <span style="color:Green;">// Ресурс не является доступным для работы. Вы можете переопределить свойство, изменив логику.</span>
    <span style="color:Blue;">public</span> <span style="color:Blue;">abstract</span> <span style="color:Blue;">bool</span> IsInvalid {
        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
        <span style="color:Blue;">get</span>;
    }

    <span style="color:Green;">// Закрытие ресурса через шаблон Close()</span>
    [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Close() {
        Dispose(<span style="color:Blue;">true</span>);
    }

    <span style="color:Green;">// Закрытие ресурса через шаблон Dispose()</span>
    [SecuritySafeCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose() {
        Dispose(<span style="color:Blue;">true</span>);
    }

    [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    <span style="color:Blue;">protected</span> <span style="color:Blue;">virtual</span> <span style="color:Blue;">void</span> Dispose(<span style="color:Blue;">bool</span> disposing)
    {
        <span style="color:Green;">// ...</span>
    }

    <span style="color:Green;">// Вы должны вызывать этот метод всякий раз, когда понимаете, что handle более не является рабочим.</span>
    <span style="color:Green;">// Если вы этого не сделаете, можете получить утечку</span>
    [SecurityCritical, ResourceExposure(ResourceScope.None)]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">void</span> SetHandleAsInvalid();

    <span style="color:Green;">// Переопределите данный метод, чтобы указать, каким образом необходимо освобождать</span>
    <span style="color:Green;">// ресурс. Необходимо быть крайне осторожным при написании кода, т.к. из него</span>
    <span style="color:Green;">// нельзя вызывать нескомпилированные методы, создавать новые объекты и бросать исключения.</span>
    <span style="color:Green;">// Возвращаемое значение -маркер успешности операции освобождения ресурсов.</span>
    <span style="color:Green;">// Причём если возвращаемое значение = false, будет брошено исключение</span>
    <span style="color:Green;">// SafeHandleCriticalFailure, которое в случае включённого SafeHandleCriticalFailure</span>
    <span style="color:Green;">// Managed Debugger Assistant войдёт в точку останова.</span>
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    <span style="color:Blue;">protected</span> <span style="color:Blue;">abstract</span> <span style="color:Blue;">bool</span> ReleaseHandle();


    <span style="color:Green;">// Работа со счётчиком ссылок. Будет объяснено далее по тексту</span>
    [SecurityCritical, ResourceExposure(ResourceScope.None)]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    <span style="color:Blue;">public</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">void</span> DangerousAddRef(<span style="color:Blue;">ref</span> <span style="color:Blue;">bool</span> success);
    <span style="color:Blue;">public</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">void</span> DangerousRelease();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">22</div>
<p >
Чтобы оце&shy;нить полез&shy;ность группы клас&shy;сов, про&shy;из&shy;вод&shy;ных от Safe&shy;Handle, дос&shy;та&shy;точно вспом&shy;нить, чем хороши все .NET типы: авто&shy;ма&shy;ти&shy;зи&shy;ро&shy;ван&shy;ностью уборки мусора. Т.о., обо&shy;ра&shy;чи&shy;вая неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс, Safe&shy;Handle наде&shy;ляет его такими же свой&shy;ствами, т.к. явля&shy;ется управ&shy;ля&shy;е&shy;мым. Плюс ко всему он содер&shy;жит внут&shy;рен&shy;ний счётчик внеш&shy;них ссы&shy;лок, кото&shy;рые не могут быть учтены CLR. Т.е. ссыл&shy;ками из unsafe кода. Вруч&shy;ную уве&shy;ли&shy;чи&shy;вать и умень&shy;шать счётчик нет почти ника&shy;кой необ&shy;хо&shy;ди&shy;мости: когда вы объ&shy;яв&shy;ля&shy;ете любой тип, про&shy;из&shy;вод&shy;ный от Safe&shy;Handle, как пара&shy;метр unsafe метода, то при входе в метод счётчик будет уве&shy;ли&shy;чен, а при выходе - уменьшён. Это свой&shy;ство вве&shy;дено по той при&shy;чине, что когда вы перешли в unsafe код, пере&shy;дав туда деск&shy;рип&shy;тор, то в дру&shy;гом потоке (если вы, конечно, рабо&shy;та&shy;ете с одним деск&shy;рип&shy;то&shy;ром из нес&shy;коль&shy;ких пото&shy;ков) обну&shy;лив ссылку на него, полу&shy;чите соб&shy;ран&shy;ный Safe&shy;Handle. Со счётчи&shy;ком же ссы&shy;лок всё проще: Safe&shy;Handle не будет соб&shy;ран, пока допол&shy;ни&shy;тельно не обну&shy;лится счётчик. Вот почему вруч&shy;ную менять счётчик не стоит. Либо это надо делать очень акку&shy;ратно: возв&shy;ра&shy;щая его, как только это ста&shy;но&shy;вится воз&shy;мож&shy;ным.</p>
<div class="paragraph-right-side">22</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">23</div>
<p >
Вто&shy;рое наз&shy;на&shy;че&shy;ние счётчика ссы&shy;лок - это зада&shy;ние порядка фина&shy;ли&shy;за&shy;ции <code>CriticalFinalizerObject</code>, кото&shy;рые друг на друга ссы&shy;ла&shy;ются. Если один Safe&shy;Handle-based тип ссы&shy;ла&shy;ется на дру&shy;гой Safe&shy;Handle-based тип, то в конст&shy;ру&shy;кторе ссы&shy;ла&shy;ю&shy;ще&shy;гося необ&shy;хо&shy;димо допол&shy;ни&shy;тельно уве&shy;ли&shy;чить счётчик ссы&shy;лок, а в методе Release&shy;Handle - умень&shy;шить. Таким обра&shy;зом, ваш объ&shy;ект не будет унич&shy;то&shy;жен, пока не будет унич&shy;то&shy;жен тот, на кото&shy;рый вы сос&shy;ла&shy;лись. Однако чтобы не путаться, стоит избе&shy;гать таких ситу&shy;а&shy;ций.</p>
<div class="paragraph-right-side">23</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">24</div>
<p >
Давайте напи&shy;шем финаль&shy;ный вари&shy;ант нашего класса, но теперь уже с пос&shy;лед&shy;ними зна&shy;ни&shy;ями о Safe&shy;Handlers:</p>
<div class="paragraph-right-side">24</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> FileWrapper : IDisposable
{
    SafeFileHandle _handle;
    <span style="color:Blue;">bool</span> _disposed;

    <span style="color:Blue;">public</span> FileWrapper(<span style="color:Blue;">string</span> name)
    {
        _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        <span style="color:Blue;">if</span>(_disposed) <span style="color:Blue;">return</span>;
        _disposed = <span style="color:Blue;">true</span>;
        _handle.Dispose();
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> CheckDisposed()
    {
        <span style="color:Blue;">if</span>(_disposed) {
            <span style="color:Blue;">throw</span> <span style="color:Blue;">new</span> ObjectDisposedException();
        }
    }

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>, EntryPoint = <span style="color:#A31515;">&quot;CreateFile&quot;</span>, SetLastError = <span style="color:Blue;">true</span>)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> SafeFileHandle CreateFile(String lpFileName,
        UInt32 dwDesiredAccess, UInt32 dwShareMode,
        IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition,
        UInt32 dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    <span style="color:Gray;">///</span><span style="color:Green;"> other methods</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">25</div>
<p >
Что его отли&shy;чает? Зная, что если в Dll&shy;Import методе в качес&shy;тве возв&shy;ра&shy;ща&shy;е&shy;мого зна&shy;че&shy;ния уста&shy;но&shy;вить <strong>любой</strong> (в том числе и свой) Safe&shy;Handle-based тип, то Marshal его кор&shy;рек&shy;тно соз&shy;даст и про&shy;и&shy;ни&shy;ци&shy;а&shy;ли&shy;зи&shy;рует, уста&shy;но&shy;вив счётчик исполь&shy;зо&shy;ва&shy;ний в 1, мы ста&shy;вим тип Safe&shy;File&shy;Handle в качес&shy;тве возв&shy;ра&shy;ща&shy;е&shy;мого для фун&shy;к&shy;ции ядра Create&shy;File. Полу&shy;чив его, мы будем при вызове Read&shy;File и Write&shy;File исполь&shy;зо&shy;вать именно его (т.к. при вызове счётчик опять же уве&shy;ли&shy;чится, а при выходе - умень&shy;шится, что даст нам гаран&shy;тию сущест&shy;во&shy;ва&shy;ния handle на всё время чте&shy;ния и записи в файл). Тип этот спр&shy;ое&shy;кт&shy;ир&shy;ован кор&shy;рек&shy;тно, а это зна&shy;чит, что он гаран&shy;ти&shy;ро&shy;ванно зак&shy;роет фай&shy;ло&shy;вый деск&shy;рип&shy;тор, даже когда про&shy;цесс ава&shy;рийно завер&shy;шит свою работу. А это зна&shy;чит, что нам не надо реа&shy;ли&shy;зо&shy;вы&shy;вать свой fina&shy;lizer и всё, что с ним свя&shy;зано. Наш тип зна&shy;чи&shy;тельно упро&shy;ща&shy;ется.</p>
<div class="paragraph-right-side">25</div>
</div>
<h3 id="finalizer">Срабатывание finalizer во время работы экземплярных методов</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">26</div>
<p >
В про&shy;цессе сборки мусора есть одна опти&shy;ми&shy;за&shy;ция, нап&shy;рав&shy;лен&shy;ная на то чтобы как можно раньше соб&shy;рать наи&shy;боль&shy;шее коли&shy;чес&shy;тво объ&shy;ек&shy;тов. Давайте расс&shy;мот&shy;рим сле&shy;ду&shy;ю&shy;щий код:</p>
<div class="paragraph-right-side">26</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>

<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> SampleMethod()
{
    <span style="color:Blue;">var</span> obj = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();
    obj.ToString();
    
    <span style="color:Green;">// ...</span>
    <span style="color:Green;">// Если в этой точке сработает GC, obj с некоторой степенью вероятности будет собрана</span>
    <span style="color:Green;">// т.к. она более не используется</span>
    <span style="color:Green;">// ...</span>
    
    Console.ReadLine();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">27</div>
<p >
С одной сто&shy;роны код выг&shy;ля&shy;дит дос&shy;та&shy;точно безо&shy;пасно и не сразу ста&shy;но&shy;вится ясно, почему это дол&shy;жно нас хоть как-то касаться. Однако дос&shy;та&shy;точно вспом&shy;нить, что сущес&shy;твуют классы, обо&shy;ра&shy;чи&shy;ва&shy;ю&shy;щие собой неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы как сразу при&shy;хо&shy;дит пони&shy;ма&shy;ние, что если класс будет спр&shy;ое&shy;кт&shy;ир&shy;ован не кор&shy;рек&shy;тно, то вполне можно полу&shy;чить исклю&shy;че&shy;ние из unma&shy;naged мира, кото&shy;рое будет гово&shy;рить о том, что handle, кото&shy;рый был полу&shy;чен ранее уже не акти&shy;вен:</p>
<div class="paragraph-right-side">27</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Пример абсолютно не правильной реализации </span>
<span style="color:Blue;">void</span> Main()
{
    <span style="color:Blue;">var</span> inst = <span style="color:Blue;">new</span> SampleClass();
    inst.ReadData(); 
    <span style="color:Green;">// далее inst не используется</span>
}

<span style="color:Blue;">public</span> <span style="color:Blue;">sealed</span> <span style="color:Blue;">class</span> SampleClass : CriticalFinalizerObject, IDisposable
{
    <span style="color:Blue;">private</span> IntPtr _handle;

    <span style="color:Blue;">public</span> SampleClass()
    {
        _handle = CreateFile(<span style="color:#A31515;">&quot;test.txt&quot;</span>, 0, 0, IntPtr.Zero, 0, 0, IntPtr.Zero);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        <span style="color:Blue;">if</span> (_handle != IntPtr.Zero)
        {
            CloseHandle(_handle);
            _handle = IntPtr.Zero;
        }
    }

    ~SampleClass()
    {
        Console.WriteLine(<span style="color:#A31515;">&quot;Finalizing instance.&quot;</span>);
        Dispose();
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">unsafe</span> <span style="color:Blue;">void</span> ReadData()
    {
        Console.WriteLine(<span style="color:#A31515;">&quot;Calling GC.Collect...&quot;</span>);
        
        <span style="color:Green;">// я специально перевёл на локальную переменную чтобы</span>
        <span style="color:Green;">// не задействовать this после GC.Collect();</span>
        <span style="color:Blue;">var</span> handle = _handle;

        <span style="color:Green;">// Имитация полного GC.Collect</span>
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();

        Console.WriteLine(<span style="color:#A31515;">&quot;Finished doing something.&quot;</span>);
        <span style="color:Blue;">var</span> overlapped = <span style="color:Blue;">new</span> NativeOverlapped();

        <span style="color:Green;">// Делаем не важно что</span>
        ReadFileEx(handle, <span style="color:Blue;">new</span> <span style="color:Blue;">byte</span>[] { }, 0, <span style="color:Blue;">ref</span> overlapped, (a, b, c) =&gt; {;});
    }

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>, SetLastError = <span style="color:Blue;">true</span>, CharSet = CharSet.Auto, BestFitMapping = <span style="color:Blue;">false</span>)]
    <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> IntPtr CreateFile(String lpFileName, <span style="color:Blue;">int</span> dwDesiredAccess, <span style="color:Blue;">int</span> dwShareMode,
    IntPtr securityAttrs, <span style="color:Blue;">int</span> dwCreationDisposition, <span style="color:Blue;">int</span> dwFlagsAndAttributes, IntPtr hTemplateFile);

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>, SetLastError = <span style="color:Blue;">true</span>)]
    <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">bool</span> ReadFileEx(IntPtr hFile, [Out] <span style="color:Blue;">byte</span>[] lpBuffer, <span style="color:Blue;">uint</span> nNumberOfBytesToRead,
    [In] <span style="color:Blue;">ref</span> NativeOverlapped lpOverlapped, IOCompletionCallback lpCompletionRoutine);

    [DllImport(<span style="color:#A31515;">&quot;kernel32.dll&quot;</span>, SetLastError = <span style="color:Blue;">true</span>)]
    <span style="color:Blue;">static</span> <span style="color:Blue;">extern</span> <span style="color:Blue;">bool</span> CloseHandle(IntPtr hObject);
}    
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">28</div>
<p >
Сог&shy;ла&shy;си&shy;тесь: этот код выг&shy;ля&shy;дит более-менее при&shy;лично. Во вся&shy;ком слу&shy;чае, явно он никак не сооб&shy;щает, что есть какая-то проб&shy;лема. А проб&shy;лема есть и при том очень серьёзная. Воз&shy;можна попытка зак&shy;ры&shy;тия файла фина&shy;ли&shy;за&shy;то&shy;ром класса во время чте&shy;ния из файла. Что прак&shy;ти&shy;чески гаран&shy;ти&shy;ро&shy;ванно при&shy;ведёт к ошибке. Причём пос&shy;кольку в дан&shy;ном слу&shy;чае ошибка будет именно возв&shy;ра&shy;щена (<code>IntPtr == -1</code>), то мы этого не уви&shy;дим, <code>_handle</code> будет обнулён, даль&shy;ней&shy;ший <code>Dispose</code> не зак&shy;роет файл, а мы полу&shy;чим утечку ресурса. Для реше&shy;ния этой проб&shy;лемы необ&shy;хо&shy;димо поль&shy;зо&shy;ваться <code>SafeHandle</code>, <code>CriticalHandle</code>, <code>SafeBuffer</code> и их про&shy;из&shy;вод&shy;ными, кото&shy;рые кроме того, что имеют счётчики исполь&shy;зо&shy;ва&shy;ния в unma&shy;naged мире, так ещё и эти счётчики авто&shy;ма&shy;ти&shy;чески уве&shy;ли&shy;чи&shy;ва&shy;ются при пере&shy;даче в unma&shy;naged методы и умень&shy;ша&shy;ются - при выходе из него.</p>
<div class="paragraph-right-side">28</div>
</div>
<h2 id="section">Многопоточность</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">29</div>
<p >
Теперь пого&shy;во&shy;рим про тон&shy;кий лёд. В пре&shy;ды&shy;ду&shy;щих час&shy;тях расс&shy;каза об IDis&shy;po&shy;sable мы про&shy;го&shy;во&shy;рили одну очень важ&shy;ную кон&shy;цеп&shy;цию, кото&shy;рая лежит не только в основе про&shy;ек&shy;ти&shy;ро&shy;ва&shy;ния Dispo&shy;sable типов, но и в про&shy;ек&shy;ти&shy;ро&shy;ва&shy;нии любого типа: кон&shy;цеп&shy;ция целост&shy;ности объ&shy;екта. Это зна&shy;чит, что в любой момент вре&shy;мени объ&shy;ект нахо&shy;дится в строго опре&shy;делённом сос&shy;то&shy;я&shy;нии, и любое действие над ним пере&shy;во&shy;дит его сос&shy;то&shy;я&shy;ние в одно из зара&shy;нее опре&shy;делённых - при про&shy;ек&shy;ти&shy;ро&shy;ва&shy;нии типа этого объ&shy;екта. Дру&shy;гими сло&shy;вами - ника&shy;кое действие над объ&shy;ек&shy;том не дол&shy;жно иметь воз&shy;мож&shy;ность пере&shy;вести его сос&shy;то&shy;я&shy;ние в то, кото&shy;рое не было опре&shy;де&shy;лено. Из этого выте&shy;кает проб&shy;лема в спр&shy;ое&shy;кт&shy;ир&shy;ова&shy;нных ранее типах: они не пото&shy;ко&shy;бе&shy;зо&shy;пас&shy;ный. Есть потен&shy;ци&shy;альная воз&shy;мож&shy;ность вызова пуб&shy;лич&shy;ных мето&shy;дов этих типов в то время, как идёт раз&shy;ру&shy;ше&shy;ние объ&shy;екта. Давайте решим эту проб&shy;лему и решим, стоит ли вообще её решать</p>
<div class="paragraph-right-side">29</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> FileWrapper : IDisposable
{
    IntPtr _handle;
    <span style="color:Blue;">bool</span> _disposed;
    <span style="color:Blue;">object</span> _disposingSync = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();

    <span style="color:Blue;">public</span> FileWrapper(<span style="color:Blue;">string</span> name)
    {
        _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Seek(<span style="color:Blue;">int</span> position)
    {
        <span style="color:Blue;">lock</span>(_disposingSync)
        {
            CheckDisposed();
            <span style="color:Green;">// Seek API call</span>
        }
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        <span style="color:Blue;">lock</span>(_disposingSync)
        {
            <span style="color:Blue;">if</span>(_disposed) <span style="color:Blue;">return</span>;
            _disposed = <span style="color:Blue;">true</span>;
        }
        InternalDispose();
        GC.SuppressFinalize(<span style="color:Blue;">this</span>);
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> CheckDisposed()
    {
        <span style="color:Blue;">lock</span>(_disposingSync)
        {
            <span style="color:Blue;">if</span>(_disposed) {
                <span style="color:Blue;">throw</span> <span style="color:Blue;">new</span> ObjectDisposedException();
            }
        }
    }

    <span style="color:Blue;">private</span> <span style="color:Blue;">void</span> InternalDispose()
    {
        CloseHandle(_handle);
    }

    ~FileWrapper()
    {
        InternalDispose();
    }

    <span style="color:Gray;">///</span><span style="color:Green;"> other methods</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">30</div>
<p >
Уста&shy;новка кри&shy;ти&shy;чес&shy;кой сек&shy;ции на код про&shy;верки <code>_disposed</code> в Dispose() и по факту - уста&shy;новка кри&shy;ти&shy;чес&shy;кой сек&shy;ции на весь код пуб&shy;лич&shy;ных мето&shy;дов. Это решит нашу проб&shy;лему однов&shy;ре&shy;мен&shy;ного входа в пуб&shy;лич&shy;ный метод экземп&shy;ляра типа и в метод его раз&shy;ру&shy;ше&shy;ния, однако соз&shy;даст тай&shy;мер замед&shy;лен&shy;ного действия для ряда дру&shy;гих проб&shy;лем:</p>
<div class="paragraph-right-side">30</div>
</div>
<ul>
<li>
<p >
Интен&shy;сив&shy;ная работа с мето&shy;дами экземп&shy;ляра типа, а также работа по соз&shy;да&shy;нию и раз&shy;ру&shy;ше&shy;нию объ&shy;ек&shy;тов при&shy;ведёт к силь&shy;ному про&shy;се&shy;да&shy;нию по про&shy;из&shy;во&shy;ди&shy;тель&shy;ности. Всё дело в том, что взя&shy;тие бло&shy;ки&shy;ровки зани&shy;мает неко&shy;то&shy;рое время. Это время необ&shy;хо&shy;димо для алло&shy;ка&shy;ции таб&shy;лиц Sync&shy;Block&shy;Index, про&shy;ве&shy;рок на теку&shy;щий поток и много чего ещё (мы расс&shy;мот&shy;рим всё это отдельно - в раз&shy;деле про мно&shy;го&shy;по&shy;точ&shy;ность). Т.е. полу&shy;ча&shy;ется, что ради &laquo;пос&shy;лед&shy;ней мили&raquo; жизни объ&shy;екта мы будем пла&shy;тить про&shy;из&shy;во&shy;ди&shy;тель&shy;ностью всё время его жизни!</p>
</li>
<li>
<p >
Допол&shy;ни&shy;тель&shy;ный memory traffic для объ&shy;ек&shy;тов синх&shy;ро&shy;ни&shy;за&shy;ции</p>
</li>
<li>
<p >
Допол&shy;ни&shy;тель&shy;ные шаги для обхода графа объ&shy;ек&shy;тов при GC</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">31</div>
<p >
Вто&shy;рое, и на мой взгляд, самоё важ&shy;ное. Мы допус&shy;каем ситу&shy;а&shy;цию однов&shy;ре&shy;мен&shy;ного раз&shy;ру&shy;ше&shy;ния объ&shy;екта с воз&shy;мож&shy;ностью пора&shy;бо&shy;тать с ним ещё разок. На что мы вообще дол&shy;жны наде&shy;яться в дан&shy;ном слу&shy;чае? Что не выст&shy;ре&shy;лит? Ведь если сна&shy;чала отра&shy;бо&shy;тает Dispose, то даль&shy;ней&shy;шее обра&shy;ще&shy;ние с мето&shy;дами объ&shy;екта обя&shy;зано при&shy;вести к <code>ObjectDisposedException</code>. Отсюда воз&shy;ни&shy;кает прос&shy;той вывод: синх&shy;ро&shy;ни&shy;за&shy;цию между вызо&shy;вами Dispose() и осталь&shy;ными пуб&shy;лич&shy;ными мето&shy;дами типа необ&shy;хо&shy;димо деле&shy;ги&shy;ро&shy;вать обслу&shy;жи&shy;ва&shy;ю&shy;щей сто&shy;роне. Т.е. тому коду, кото&shy;рый соз&shy;дал экземп&shy;ляр класса <code>FileWrapper</code>. Ведь только соз&shy;да&shy;ю&shy;щая сто&shy;рона в курсе, что она соби&shy;ра&shy;ется делать с экземп&shy;ля&shy;ром класса и когда она соби&shy;ра&shy;ется его раз&shy;ру&shy;шать.</p>
<div class="paragraph-right-side">31</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">32</div>
<p >
С дру&shy;гой сто&shy;роны по тре&shy;бо&shy;ва&shy;ниям к архи&shy;тек&shy;туре клас&shy;сов, реа&shy;ли&shy;зу&shy;ю&shy;щих IDis&shy;po&shy;sable вызов Dispose дол&shy;жен выки&shy;ды&shy;вать только кри&shy;ти&shy;чес&shy;кие ошибки (такие как <code>OutOfMemoryException</code>, но не IOExc&shy;ep&shy;tion, нап&shy;ри&shy;мер). Это в част&shy;ности зна&shy;чит, что если Dispose вызо&shy;вется более чем из одного потока однов&shy;ре&shy;менно, то может про&shy;изойти ситу&shy;а&shy;ция, когда раз&shy;ру&shy;ше&shy;ние сущ&shy;ности будет про&shy;ис&shy;хо&shy;дить однов&shy;ре&shy;менно из двух пото&shy;ков (прос&shy;ко&shy;чим про&shy;верку <code>if(_disposed) return;</code>). Тут зави&shy;сит от ситу&shy;а&shy;ции: если осво&shy;бож&shy;де&shy;ние ресур&shy;сов <em>может</em> идти нес&shy;колько раз, то ника&shy;ких допол&shy;ни&shy;тель&shy;ных про&shy;ве&shy;рок не пот&shy;ре&shy;бу&shy;ется. Если же нет, необ&shy;хо&shy;дима защита:</p>
<div class="paragraph-right-side">32</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Я намеренно не привожу весь шаблон, т.к. пример будет большим</span>
<span style="color:Green;">// и не покажет сути</span>
<span style="color:Blue;">class</span> Disposable : IDisposable
{
    <span style="color:Blue;">private</span> <span style="color:Blue;">volatile</span> <span style="color:Blue;">int</span> _disposed;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        <span style="color:Blue;">if</span>(Interlocked.CompareExchange(<span style="color:Blue;">ref</span> _disposed, 1, 0) == 0)
        {
            <span style="color:Green;">// dispose</span>
        }
    }
}
</pre></div>
</div>
<h2 id="disposable-design-principle">Два уровня Disposable Design Principle</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">33</div>
<p >
Какой самый попу&shy;ляр&shy;ный шаб&shy;лон реа&shy;ли&shy;за&shy;ции <code>IDisposable</code> можно встр&shy;етить в кни&shy;гах по .NET раз&shy;ра&shy;ботке и во Все&shy;мир&shy;ной Пау&shy;тине? Какой шаб&shy;лон ждут от вас люди в ком&shy;па&shy;ниях, когда вы идёте собе&shy;се&shy;до&shy;ваться на потен&shy;ци&shy;ально новое место работы? Веро&shy;ят&shy;нее всего этот:</p>
<div class="paragraph-right-side">33</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> Disposable : IDisposable
{
    <span style="color:Blue;">bool</span> _disposed;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
    {
        Dispose(<span style="color:Blue;">true</span>);
        GC.SuppressFinalize(<span style="color:Blue;">this</span>);
    }

    <span style="color:Blue;">protected</span> <span style="color:Blue;">virtual</span> <span style="color:Blue;">void</span> Dispose(<span style="color:Blue;">bool</span> disposing)
    {
        <span style="color:Blue;">if</span>(disposing)
        {
            <span style="color:Green;">// освобождаем управляемые ресурсы</span>
        }
        <span style="color:Green;">// освобождаем неуправляемые ресурсы</span>
    }

    <span style="color:Blue;">protected</span> <span style="color:Blue;">void</span> CheckDisposed()
    {
        <span style="color:Blue;">if</span>(_disposed)
        {
            <span style="color:Blue;">throw</span> <span style="color:Blue;">new</span> ObjectDisposedException();
        }
    }

    ~Disposable()
    {
        Dispose(<span style="color:Blue;">false</span>);
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">34</div>
<p >
Что здесь не так и почему мы ранее в этой книге никогда так не писали? На самом деле шаб&shy;лон хоро&shy;ший и без лиш&shy;них слов охва&shy;ты&shy;вает все жиз&shy;нен&shy;ные ситу&shy;а&shy;ции. Но его исполь&shy;зо&shy;ва&shy;ние пов&shy;се&shy;мес&shy;тно, на мой взгляд, не явля&shy;ется пра&shy;ви&shy;лом хоро&shy;шего тона: ведь реальных неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов мы в прак&shy;тике почти никогда не видим, и в этом слу&shy;чае пол&shy;шаб&shy;лона рабо&shy;тает в холос&shy;тую. Мало того, он нару&shy;шает прин&shy;цип раз&shy;де&shy;ле&shy;ния ответст&shy;вен&shy;ности. Ведь он однов&shy;ре&shy;менно управ&shy;ляет и управ&shy;ля&shy;е&shy;мыми ресур&shy;сами и неуп&shy;рав&shy;ля&shy;е&shy;мыми. На мой скром&shy;ный взгляд, это совер&shy;шенно не пра&shy;вильно. Давайте взгл&shy;янем на нес&shy;колько иной под&shy;ход. <em>Disposable Design Principle</em>. Если коротко, то суть в сле&shy;ду&shy;ю&shy;щем:</p>
<div class="paragraph-right-side">34</div>
</div>
<p >
Dispo&shy;sing раз&shy;де&shy;ля&shy;ется на два уровня клас&shy;сов:</p>
<ul>
<li>
<p >
Типы Level 0 нап&shy;ря&shy;мую инкап&shy;су&shy;ли&shy;руют неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы</p>
<ul>
<li>
<p >
Они явля&shy;ются либо абстр&shy;ак&shy;тными, либо запа&shy;ко&shy;ван&shy;ными</p>
</li>
<li>
<p >
Все методы дол&shy;жны быть поме&shy;чены:</p>
<ul>
<li>
<p >
Pre&shy;Prepare&shy;Method, чтобы метод был ском&shy;пи&shy;ли&shy;ро&shy;ван вместе с заг&shy;руз&shy;кой типа</p>
</li>
<li>
<p >
Security&shy;Safe&shy;Critical, чтобы выс&shy;та&shy;вить защиту на вызов из кода, рабо&shy;та&shy;ю&shy;щего под огра&shy;ни&shy;че&shy;ни&shy;ями</p>
</li>
<li>
<p >
Reliability&shy;Contract(Consis&shy;tency.Will&shy;Not&shy;Corrupt&shy;State, Cer.Success / May&shy;Fail)] чтобы выс&shy;та&shy;вить CER на метод и все его дочер&shy;ние вызовы</p>
</li>
</ul>
</li>
<li>
<p >
Могут ссы&shy;латься на типы нуле&shy;вого уровня, но дол&shy;жны уве&shy;ли&shy;чи&shy;вать счётчик ссы&shy;ла&shy;ющихся объ&shy;ек&shy;тов, чтобы гаран&shy;ти&shy;ро&shy;вать поря&shy;док выхода на &laquo;пос&shy;лед&shy;нюю милю&raquo;</p>
</li>
</ul>
</li>
<li>
<p >
Типы Level 1 инкап&shy;су&shy;ли&shy;руют только управ&shy;ля&shy;е&shy;мые ресурсы</p>
<ul>
<li>
<p >
Нас&shy;ле&shy;ду&shy;ются только от типов Level 1 либо реа&shy;ли&shy;зуют IDis&shy;po&shy;sable нап&shy;ря&shy;мую</p>
</li>
<li>
<p >
Не имеют права нас&shy;ле&shy;до&shy;вать типы Level 0 или Critical&shy;Finalizer&shy;Object</p>
</li>
<li>
<p >
Могут инкап&shy;су&shy;ли&shy;ро&shy;вать управ&shy;ля&shy;е&shy;мые типы Level 1 или Level 0</p>
</li>
<li>
<p >
Реа&shy;ли&shy;зуют IDis&shy;po&shy;sable.Dispose путём раз&shy;ру&shy;ше&shy;ния инкап&shy;су&shy;ли&shy;ро&shy;ван&shy;ных объ&shy;ек&shy;тов в порядке: сна&shy;чала типы Level 0, потом типы Level 1</p>
</li>
<li>
<p >
Т.к. они не имеют неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов - то не реа&shy;ли&shy;зуют fina&shy;lizer</p>
</li>
<li>
<p >
Дол&shy;жно содер&shy;жать protected свой&shy;ство, даю&shy;щее дос&shy;туп к Level 0 типам.</p>
</li>
</ul>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">35</div>
<p >
Именно поэ&shy;тому я с самого начала ввёл раз&shy;де&shy;ле&shy;ние на два типа: на содер&shy;жа&shy;щий управ&shy;ля&shy;е&shy;мый ресурс и содер&shy;жа&shy;щий неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс. Они дол&shy;жны рабо&shy;тать совер&shy;шенно по-раз&shy;ному.</p>
<div class="paragraph-right-side">35</div>
</div>
<h2 id="dispose">Как ещё используется Dispose</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">36</div>
<p >
Иде&shy;о&shy;ло&shy;ги&shy;чески IDis&shy;po&shy;sable был соз&shy;дан для осво&shy;бож&shy;де&shy;ния неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов. Но как и для мно&shy;гих дру&shy;гих шаб&shy;ло&shy;нов ока&shy;за&shy;лось, что он очень поле&shy;зен и для дру&shy;гих задач. Нап&shy;ри&shy;мер, для осво&shy;бож&shy;де&shy;ния ссы&shy;лок на управ&shy;ля&shy;е&shy;мые ресурсы. Зву&shy;чит как-то не очень полезно: осво&shy;бож&shy;дать управ&shy;ля&shy;е&shy;мые ресурсы. Ведь нам же объ&shy;яс&shy;нили, что управ&shy;ля&shy;е&shy;мые ресурсы - они на то и управ&shy;ля&shy;е&shy;мые, чтобы мы расс&shy;ла&shy;би&shy;лись и смот&shy;рели в сто&shy;рону раз&shy;ра&shy;бот&shy;чи&shy;ков C/C++ с едва замет&shy;ной ухмыл&shy;кой. Однако всё не сов&shy;сем так. Мы всегда можем полу&shy;чить ситу&shy;а&shy;цию, когда мы теряем ссылку на объ&shy;ект и думаем, что всё хорошо: GC соберёт мусор, а вместе с ним и наш объ&shy;ект. Однако, выяс&shy;ня&shy;ется, что память растёт, мы лезем в прог&shy;рамму ана&shy;лиза памяти и видим, что на самом деле этот объ&shy;ект удер&shy;жи&shy;ва&shy;ется чем-то ещё. Всё дело в том, что как в плат&shy;форме .NET, так и в архи&shy;тек&shy;туре внеш&shy;них клас&shy;сов может при&shy;сутс&shy;твовать логика неяв&shy;ного зах&shy;вата ссылки на вашу сущ&shy;ность. После чего, ввиду не явности зах&shy;вата, прог&shy;рам&shy;мист может про&shy;пус&shy;тить необ&shy;хо&shy;ди&shy;мость её осво&shy;бож&shy;де&shy;ния и полу&shy;чить на выходе утечку памяти.</p>
<div class="paragraph-right-side">36</div>
</div>
<h3 id="events">Делегаты, events</h3>
<p >
Взгл&shy;янем на сле&shy;ду&shy;ю&shy;щий син&shy;те&shy;ти&shy;чес&shy;кий при&shy;мер:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">class</span> Secondary
{
    Action _action;

    <span style="color:Blue;">void</span> SaveForUseInFuture(Action action)
    {
        _action = action;
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> CallAction()
    {
        _action();
    }
}

<span style="color:Blue;">class</span> Primary
{
    Secondary _foo = <span style="color:Blue;">new</span> Secondary();

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> PlanSayHello()
    {
        _foo.SaveForUseInFuture(Strategy);
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> SayHello()
    {
        _foo.CallAction();
    }

    <span style="color:Blue;">void</span> Strategy()
    {
        Console.WriteLine(<span style="color:#A31515;">&quot;Hello!&quot;</span>);
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">37</div>
<p >
Какая проб&shy;лема здесь демонс&shy;тр&shy;ир&shy;уется? Класс Secon&shy;dary хра&shy;нит деле&shy;гат типа <code>Action</code> в поле <code>_action</code>, кото&shy;рый при&shy;ни&shy;ма&shy;ется в методе <code>SaveForUseInFuture</code>. Далее в классе <code>Primary</code> метод <code>PlanSayHello</code> отдаёт в <code>Secondary</code> сиг&shy;на&shy;туру метода <code>Strategy</code>. Забавно, но если вы здесь будете отда&shy;вать ста&shy;ти&shy;чес&shy;кий метод или метод экземп&shy;ляра, то сам вызов <code>SaveForUseInFuture</code> никак не изме&shy;нится: просто <em>неявно</em> будет или не будет отда&shy;ваться ссылка на экземп&shy;ляр класса <code>Primary</code>. Т.е. внешне выг&shy;ля&shy;дит, что вы отдали ука&shy;за&shy;ние, какой метод стоит вызы&shy;вать. На самом деле помимо сиг&shy;на&shy;туры метода деле&shy;гат стр&shy;ои&shy;тся на основе ука&shy;за&shy;теля на экземп&shy;ляр класса. Вызы&shy;ва&shy;ю&shy;щая сто&shy;рона же дол&shy;жна пони&shy;мать, для какого экземп&shy;ляра класса она дол&shy;жна будет выз&shy;вать метод <code>Strategy</code>! Т.е. экземп&shy;ляр класса <code>Secondary</code> неявно полу&shy;чил в удер&shy;жа&shy;ние ука&shy;за&shy;тель на экземп&shy;ляр класса <code>Primary</code>, хотя явно это не ука&shy;зано. Для нас это дол&shy;жно озна&shy;чать только одно: если мы отда&shy;дим ука&shy;за&shy;тель <code>_foo</code> куда-то ещё, а на <code>Primary</code> поте&shy;ряем ссылку, то GC <strong>не соберёт</strong> объ&shy;ект <code>Primary</code>, т.к. его будет удер&shy;жи&shy;вать <code>Secondary</code>. Как избе&shy;жать таких неп&shy;ри&shy;ят&shy;ных ситу&shy;а&shy;ций? Необ&shy;хо&shy;дим детер&shy;ми&shy;ни&shy;ро&shy;ван&shy;ный под&shy;ход к осво&shy;бож&shy;де&shy;нию ссылки на нас. И тут к нам на помощь при&shy;хо&shy;дит меха&shy;низм, кото&shy;рый прек&shy;расно под&shy;хо&shy;дит для наших целей: <code>IDisposable</code></p>
<div class="paragraph-right-side">37</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Для простоты указана упрощённая версия реализации</span>
<span style="color:Blue;">class</span> Secondary : IDisposable
{
    Action _action;

    <span style="color:Blue;">public</span> <span style="color:Blue;">event</span> Action&lt;Secondary&gt; OnDisposed;

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> SaveForUseInFuture(Action action)
    {
        _action = action;
    }

    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> CallAction()
    {
        _action?.Invoke();
    }

    <span style="color:Blue;">void</span> Dispose()
    {
        _action = <span style="color:Blue;">null</span>;
        OnDisposed?.Invoke(<span style="color:Blue;">this</span>);
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">38</div>
<p >
Теперь при&shy;мер выг&shy;ля&shy;дит при&shy;ем&shy;лемо: если экземп&shy;ляр класса пере&shy;да&shy;дут трет&shy;ьей сто&shy;роне, но при этом в про&shy;цессе работы будет поте&shy;ряна ссылка на деле&shy;гат <code>_action</code>, то мы его обну&shy;лим, а третья сто&shy;рона будет изве&shy;щена о раз&shy;ру&shy;ше&shy;нии экземп&shy;ляра класса и затрёт ссылку на него, отпра&shy;вив в мир иной.</p>
<div class="paragraph-right-side">38</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">39</div>
<p >
Вто&shy;рая опас&shy;ность кода, рабо&shy;та&shy;ю&shy;щего на деле&shy;га&shy;тах, кро&shy;ется в меха&shy;низме работы <code>event</code>. Давайте пос&shy;мот&shy;рим, во что они раз&shy;во&shy;ра&shy;чи&shy;ва&shy;ются:</p>
<div class="paragraph-right-side">39</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
 <span style="color:Green;">// закрытое поле обработчика</span>
<span style="color:Blue;">private</span> Action&lt;Secondary&gt; _event;

<span style="color:Green;">// методы add/remove помечены как [MethodImpl(MethodImplOptions.Synchronized)],</span>
<span style="color:Green;">// что аналогично lock(this)</span>
<span style="color:Blue;">public</span> <span style="color:Blue;">event</span> Action&lt;Secondary&gt; OnDisposed {
    add { <span style="color:Blue;">lock</span>(<span style="color:Blue;">this</span>) { _event += value; } }
    remove { <span style="color:Blue;">lock</span>(<span style="color:Blue;">this</span>) { _event -= value; } }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">40</div>
<p >
Меха&shy;низм сооб&shy;ще&shy;ний в C# скры&shy;вает внут&shy;рен&shy;нее устрой&shy;ство event'ов и удер&shy;жи&shy;вает все объ&shy;екты, кото&shy;рые под&shy;пи&shy;са&shy;лись на обнов&shy;ле&shy;ния через <code>event</code>. Если что-то пойдёт не так, ссылка на чужой объ&shy;ект оста&shy;нется в <code>OnDisposed</code> и будет его удер&shy;жи&shy;вать. Полу&shy;ча&shy;ется стран&shy;ная ситу&shy;а&shy;ция: архи&shy;тек&shy;турно мы имеем поня&shy;тие &laquo;источ&shy;ник собы&shy;тий&raquo;, кото&shy;рое по своей логике не дол&shy;жно что-либо удер&shy;жи&shy;вать. По факту мы имеем неяв&shy;ное удер&shy;жи&shy;ва&shy;ние объ&shy;ек&shy;тов, под&shy;пи&shy;сав&shy;шихся на обнов&shy;ле&shy;ния. При этом не имеем воз&shy;мож&shy;ности что-либо менять внутри этого мас&shy;сива деле&shy;га&shy;тов: хоть сущ&shy;ность и явля&shy;ется частью нас, нам на это прав не давали. Един&shy;ствен&shy;ное что мы можем - это зате&shy;реть весь спи&shy;сок пол&shy;ностью, прис&shy;воив источ&shy;нику собы&shy;тий null. Вто&shy;рой спо&shy;соб - явно реа&shy;ли&shy;зо&shy;вать методы <code>add</code>/<code>remove</code> чтобы ввести управ&shy;ле&shy;ние над кол&shy;лек&shy;цией деле&shy;га&shy;тов.</p>
<div class="paragraph-right-side">40</div>
</div>
<blockquote>
<p >
Кстати, тут воз&shy;ни&shy;кает ещё одна неяв&shy;ная ситу&shy;а&shy;ция: может пока&shy;заться, что если вы прис&shy;во&shy;ите источ&shy;нику собы&shy;тий null, то даль&shy;ней&shy;шая под&shy;писка на собы&shy;тия при&shy;ведёт к <code>NullReferenceException</code>. И на мой скром&shy;ный взгляд это было бы логич&shy;нее. Однако это не так: если внеш&shy;ний код под&shy;пи&shy;шется на собы&shy;тия, после того как источ&shy;ник собы&shy;тий будет очи&shy;щен, FCL соз&shy;даст новый экземп&shy;ляр класса Action и поло&shy;жит его в <code>OnDisposed</code>. Эта неяс&shy;ность в языке C# может запу&shy;тать прог&shy;рам&shy;миста: работа с обнулёнными полями дол&shy;жна вызы&shy;вать в вас не чувство спо&shy;к&shy;ойствия, а ско&shy;рее тре&shy;вогу. Тут же демонс&shy;тр&shy;ир&shy;уется под&shy;ход, когда излиш&shy;няя расс&shy;лаб&shy;лен&shy;ность может при&shy;вести прог&shy;рам&shy;миста к утеч&shy;кам памяти.</p>
</blockquote>
<h3 id="section-1">Лямбды, замыкания</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">41</div>
<p >
Осо&shy;бая опас&shy;ность нас подс&shy;те&shy;ре&shy;гает при исполь&shy;зо&shy;ва&shy;нии такого син&shy;так&shy;си&shy;чес&shy;кого сахара как лям&shy;бды.</p>
<div class="paragraph-right-side">41</div>
</div>
<blockquote class="big-quote">
<p >
 Я бы хотел зат&shy;ро&shy;нуть воп&shy;рос син&shy;так&shy;си&shy;чес&shy;кого сахара в целом. На мой взгляд, его стоит исполь&shy;зо&shy;вать дос&shy;та&shy;точно акку&shy;ратно и только если вы абсо&shy;лютно точно зна&shy;ете, к чему это при&shy;ведёт. При&shy;меры с лям&shy;бда-выра&shy;же&shy;ни&shy;ями: замы&shy;ка&shy;ния, замы&shy;ка&shy;ния в Expre&shy;ss&shy;ions и мно&shy;жес&shy;тво дру&shy;гих бед, кото&shy;рые можно на себя нав&shy;лечь.</p>
</blockquote>
<div class="paragraph-container">
<div class="paragraph-left-side">42</div>
<p >
Ну, ска&shy;жите себе чес&shy;тно: да, я знаю, что лям&shy;бда-выра&shy;же&shy;ние создаёт замы&shy;ка&shy;ние и тянет за собой риск утечки ресур&shy;сов. Но оно ведь такое&hellip; лако&shy;нич&shy;ное&hellip; при&shy;ят&shy;ное&hellip; как можно удер&shy;жаться и не пос&shy;та&shy;вить лям&shy;бду вместо выде&shy;ле&shy;ния целого метода, кото&shy;рый будет опи&shy;сан отдельно от точки исполь&shy;зо&shy;ва&shy;ния? А вот надо на самом деле не повес&shy;тись на эту про&shy;во&shy;ка&shy;цию, хотя и не каж&shy;дый может.</p>
<div class="paragraph-right-side">42</div>
</div>
<p >
Давайте расс&shy;мот&shy;рим при&shy;мер:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
button.Clicked += () =&gt; service.SendMessageAsync(MessageType.Deploy);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">43</div>
<p >
Сог&shy;ла&shy;си&shy;тесь, эта строчка выг&shy;ля&shy;дит очень безо&shy;пасно. Но она в себе таит боль&shy;шую проб&shy;лему: теперь пере&shy;мен&shy;ная <code>button</code> неявно ссы&shy;ла&shy;ется на <code>service</code> и удер&shy;жи&shy;вает его. Даже если мы решим, что <code>service</code> нам более не нужен, <code>button</code> так счи&shy;тать не может: кнопка будет удер&shy;жи&shy;вать ссылку, пока сама будет жива.</p>
<div class="paragraph-right-side">43</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">44</div>
<p >
Один из путей реше&shy;ния - вос&shy;поль&shy;зо&shy;ваться шаб&shy;ло&shy;ном соз&shy;да&shy;ния <code>IDisposable</code> из любого <code>Action</code> (<code>System.Reactive.Disposables</code>):</p>
<div class="paragraph-right-side">44</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Создаём из лямбды делегат</span>
Action action = () =&gt; service.SendMessageAsync(MessageType.Deploy);

<span style="color:Green;">// Подписываемся</span>
button.Clicked += action;

<span style="color:Green;">// Создаём отписку</span>
<span style="color:Blue;">var</span> subscription = Disposable.Create(() =&gt; button.Clicked -= action);

<span style="color:Green;">// где-то, где надо отписаться</span>
subscription.Dispose();
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">45</div>
<p >
Полу&shy;чи&shy;лось, сог&shy;ла&shy;си&shy;тесь, нес&shy;колько мно&shy;гос&shy;ловно, и при этом теря&shy;ется весь смысл исполь&shy;зо&shy;ва&shy;ния лям&shy;бда-выра&shy;же&shy;ний. Гораздо проще и безо&shy;пас&shy;нее в плане неяв&shy;ных зах&shy;ва&shy;тов пере&shy;мен&shy;ных будет исполь&shy;зо&shy;ва&shy;ние обыч&shy;ных при&shy;ват&shy;ных мето&shy;дов.</p>
<div class="paragraph-right-side">45</div>
</div>
<h3 id="threadabort">Защита от ThreadAbort</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">46</div>
<p >
Когда раз&shy;ра&shy;ба&shy;ты&shy;ва&shy;ется биб&shy;ли&shy;о&shy;тека для внеш&shy;него раз&shy;ра&shy;бот&shy;чика, вы никак не можете гаран&shy;ти&shy;ро&shy;вать, как она себя поведёт в чужом при&shy;ло&shy;же&shy;нии. Иногда остаётся только дога&shy;ды&shy;ваться, что такого с нашей биб&shy;ли&shy;о&shy;те&shy;кой сде&shy;лал чужой прог&shy;рам&shy;мист, что появился тот или иной резуль&shy;тат её работы. Один из при&shy;ме&shy;ров - работа в мно&shy;го&shy;по&shy;точ&shy;ной среде, когда воп&shy;рос целост&shy;ности очис&shy;тки ресур&shy;сов может встать дос&shy;та&shy;точно остро. Причём, если при напи&shy;са&shy;нии кода <code>Dispose()</code> метода сами мы можем дать гаран&shy;тии на отс&shy;утствие исклю&shy;чи&shy;тель&shy;ных ситу&shy;а&shy;ций, то мы не можем гаран&shy;ти&shy;ро&shy;вать, что прямо во время работы метода <code>Dispose()</code> не выле&shy;тит <code>ThreadAbortException</code>, кото&shy;рый отклю&shy;чит наш поток испол&shy;не&shy;ния. Тут стоит вспом&shy;нить тот факт, что когда бро&shy;са&shy;ется <code>ThreadAbortException</code>, то в любом слу&shy;чае выпол&shy;ня&shy;ются все catch/finally блоки (в конце catch/finally Thread&shy;Abort бро&shy;са&shy;ется дальше). Таким обра&shy;зом, чтобы что-то сде&shy;лать гаран&shy;ти&shy;ро&shy;ванно (гаран&shy;ти&shy;ро&shy;вав нераз&shy;рыв&shy;ность при помощи Thread.Abort), надо обер&shy;нуть кри&shy;тич&shy;ный учас&shy;ток в <code>try { ... } finally { ... }</code>. В этом слу&shy;чае даже если бро&shy;сят Thread&shy;Abort, код будет выпол&shy;нен.</p>
<div class="paragraph-right-side">46</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Dispose()
{
    <span style="color:Blue;">if</span>(_disposed) <span style="color:Blue;">return</span>;

    _someInstance.Unsubscribe(<span style="color:Blue;">this</span>);
    _disposed = <span style="color:Blue;">true</span>;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">47</div>
<p >
может быть обор&shy;ван в любой точке при помощи <code>Thread.Abort</code>. Это в част&shy;ности при&shy;ведёт к тому, что объ&shy;ект будет час&shy;тично раз&shy;ру&shy;шен и поз&shy;во&shy;лит рабо&shy;тать с собой в даль&shy;ней&shy;шем. Тогда как сле&shy;ду&shy;ю&shy;щий код:</p>
<div class="paragraph-right-side">47</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Dispose()
{
    <span style="color:Blue;">if</span>(_disposed) <span style="color:Blue;">return</span>;

    <span style="color:Green;">// Защита от ThreadAbortException</span>
    <span style="color:Blue;">try</span> {}
    <span style="color:Blue;">finally</span>
    {
        _someInstance.Unsubscribe(<span style="color:Blue;">this</span>);
        _disposed = <span style="color:Blue;">true</span>;
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">48</div>
<p >
защищён от такого пре&shy;ры&shy;ва&shy;ния и выпол&shy;нится гаран&shy;ти&shy;ро&shy;ванно и кор&shy;рек&shy;тно, даже если <code>Thread.Abort</code> воз&shy;ник&shy;нет между опе&shy;ра&shy;цией вызова метода <code>Unsubscribe</code> и испол&shy;не&shy;ния его инстр&shy;укций.</p>
<div class="paragraph-right-side">48</div>
</div>
<h2 id="section-2">Итоги</h2>
<h3 id="section-3">Плюсы</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">49</div>
<p >
Итак, мы узнали много нового про этот прос&shy;тей&shy;ший шаб&shy;лон. Давайте опре&shy;де&shy;лим его плюсы:</p>
<div class="paragraph-right-side">49</div>
</div>
<ol>
<li>
<p >
Основ&shy;ным плю&shy;сом шаб&shy;лона явля&shy;ется воз&shy;мож&shy;ность детер&shy;ми&shy;ни&shy;ро&shy;ван&shy;ного осво&shy;бож&shy;де&shy;ния ресур&shy;сов: тогда, когда это необ&shy;хо&shy;димо</p>
</li>
<li>
<p >
Вве&shy;де&shy;ние обще&shy;из&shy;вест&shy;ного спо&shy;соба узнать, что конк&shy;рет&shy;ный тип тре&shy;бует раз&shy;ру&shy;ше&shy;ния его экземп&shy;ля&shy;ров в конце исполь&shy;зо&shy;ва&shy;ния</p>
</li>
<li>
<p >
При гра&shy;мот&shy;ной реа&shy;ли&shy;за&shy;ции шаб&shy;лона работа спр&shy;ое&shy;кт&shy;ир&shy;ова&shy;нн&shy;ого типа ста&shy;нет безо&shy;пас&shy;ной с точки зре&shy;ния исполь&shy;зо&shy;ва&shy;ния сто&shy;рон&shy;ними ком&shy;по&shy;нен&shy;тами, а также с точки зре&shy;ния выг&shy;рузки и раз&shy;ру&shy;ше&shy;ния ресур&shy;сов при обру&shy;ше&shy;нии про&shy;цесса (нап&shy;ри&shy;мер, из-за нех&shy;ватки памяти)</p>
</li>
</ol>
<h3 id="section-4">Минусы</h3>
<p >
Мину&shy;сов шаб&shy;лона я вижу нам&shy;ного больше, чем плю&shy;сов:</p>
<ol>
<li>
<p >
С одной сто&shy;роны полу&shy;ча&shy;ется, что любой тип, реа&shy;ли&shy;зу&shy;ю&shy;щий этот шаб&shy;лон, отдаёт тем самым команду всем, кто его будет исполь&shy;зо&shy;вать: исполь&shy;зуя меня, вы при&shy;ни&shy;ма&shy;ете пуб&shy;лич&shy;ную оферту. Причём так неявно это сооб&shy;щает, что, как и в слу&shy;чае пуб&shy;лич&shy;ных оферт, поль&shy;зо&shy;ва&shy;тель типа не всегда в курсе, что у типа есть этот интер&shy;фейс. При&shy;хо&shy;дится, нап&shy;ри&shy;мер, сле&shy;до&shy;вать подс&shy;каз&shy;кам IDE (ста&shy;вить точку, наби&shy;рать Dis.. и про&shy;ве&shy;рять, есть ли метод в отфил&shy;ьтр&shy;ованном списке чле&shy;нов класса). И если Dispose заме&shy;чен, реа&shy;ли&shy;зо&shy;вы&shy;вать шаб&shy;лон у себя. Иногда это может слу&shy;читься не сразу, и тогда реа&shy;ли&shy;за&shy;цию шаб&shy;лона придётся про&shy;тя&shy;ги&shy;вать через сис&shy;тему типов, кото&shy;рая учас&shy;твует в фун&shy;кци&shy;о&shy;нале. Хоро&shy;ший при&shy;мер: а вы знали что <code>IEnumerator&lt;T&gt;</code> тянет за собой <code>IDisposable</code>?</p>
</li>
<li>
<p >
Зачас&shy;тую, когда про&shy;ек&shy;ти&shy;ру&shy;ется некий интер&shy;фейс, встаёт необ&shy;хо&shy;ди&shy;мость вставки IDis&shy;po&shy;sable в сис&shy;тему интер&shy;фей&shy;сов типа: когда один из интер&shy;фей&shy;сов вынуж&shy;ден нас&shy;ле&shy;до&shy;вать IDis&shy;po&shy;sable. На мой взгляд, это вно&shy;сит &laquo;кривь&raquo; в те интер&shy;фейсы, кото&shy;рые мы спр&shy;ое&shy;кт&shy;ир&shy;ов&shy;али. Ведь когда про&shy;ек&shy;ти&shy;ру&shy;ется интер&shy;фейс, вы прежде всего про&shy;ек&shy;ти&shy;ру&shy;ете некий про&shy;то&shy;кол вза&shy;и&shy;мо&shy;д&shy;ействия. Тот набор действий, кото&shy;рые можно сде&shy;лать <em>с чем-либо</em>, скры&shy;ва&shy;ющимся под интер&shy;фей&shy;сом. Метод Dispose() - метод раз&shy;ру&shy;ше&shy;ния экземп&shy;ляра класса. Это вхо&shy;дит в раз&shy;рез с сущ&shy;ностью <em>протокол взаимодействия</em>. Это по сути - под&shy;роб&shy;ности реа&shy;ли&shy;за&shy;ции, кото&shy;рые про&shy;со&shy;чи&shy;лись в интер&shy;фейс;</p>
</li>
<li>
<p >
Нес&shy;мотря на детер&shy;ми&shy;ни&shy;ро&shy;ван&shy;ность, Dispose() не озна&shy;чает пря&shy;мого раз&shy;ру&shy;ше&shy;ния объ&shy;екта. Объект всё ещё будет сущест&shy;во&shy;вать после его <em>разрушения</em>. Просто в дру&shy;гом сос&shy;то&shy;я&shy;нии. И чтобы это стало прав&shy;дой, вы обя&shy;заны вызы&shy;вать Check&shy;Disposed() в начале каж&shy;дого пуб&shy;лич&shy;ного метода. Это выг&shy;ля&shy;дит как хоро&shy;ший такой кос&shy;тыль, кото&shy;рый отдали нам со сло&shy;вами: "пло&shy;дите и разм&shy;но&shy;жайте!";</p>
</li>
<li>
<p >
Есть ещё мало&shy;ве&shy;ро&shy;ят&shy;ная воз&shy;мож&shy;ность полу&shy;чить тип, кото&shy;рый реа&shy;ли&shy;зует <code>IDisposable</code> через <em>explicit</em> реа&shy;ли&shy;за&shy;цию. Или полу&shy;чить тип, реа&shy;ли&shy;зу&shy;ю&shy;щий IDis&shy;po&shy;sable без воз&shy;мож&shy;ности опре&shy;де&shy;лить, кто его дол&shy;жен раз&shy;ру&shy;шать: сто&shy;рона, кото&shy;рая выдала, или вы сами. Это поро&shy;дило анти&shy;пат&shy;терн мно&shy;жест&shy;вен&shy;ного вызова Dispose(), кото&shy;рый, по сути, поз&shy;во&shy;ляет раз&shy;ре&shy;шать раз&shy;ру&shy;шен&shy;ный объ&shy;ект;</p>
</li>
<li>
<p >
Пол&shy;ная реа&shy;ли&shy;за&shy;ция сложна. Причём она раз&shy;лична для управ&shy;ля&shy;е&shy;мых и неуп&shy;рав&shy;ля&shy;е&shy;мых ресур&shy;сов. В этом плане попытка облег&shy;чить жизнь раз&shy;ра&shy;бот&shy;чи&shy;кам через GC выг&shy;ля&shy;дит нем&shy;ного нелепо. Можно, конечно, вво&shy;дить некий тип Disposable&shy;Object, кото&shy;рый реа&shy;ли&shy;зует весь шаб&shy;лон, отдав <code>virtual void Dispose()</code> метод для пере&shy;оп&shy;ре&shy;де&shy;ле&shy;ния, но это не решит дру&shy;гих проб&shy;лем, свя&shy;зан&shy;ных с шаб&shy;ло&shy;ном;</p>
</li>
<li>
<p >
Реа&shy;ли&shy;за&shy;ция метода <code>Dispose()</code> как пра&shy;вило идёт в конце файла, тогда как <code>сtor</code> объ&shy;яв&shy;ля&shy;ется в начале. При моди&shy;фи&shy;ка&shy;ции класса и вводе новых ресур&shy;сов можно легко оши&shy;биться и забыть заре&shy;гист&shy;ри&shy;ро&shy;вать dispo&shy;sing для них.</p>
</li>
<li>
<p >
Нако&shy;нец, исполь&shy;зо&shy;ва&shy;ние шаб&shy;лона на гра&shy;фах объ&shy;ек&shy;тов, кото&shy;рые пол&shy;ностью либо час&shy;тично его реа&shy;ли&shy;зуют, - та ещё морока в опре&shy;де&shy;ле&shy;нии порядка <em>разрушения</em> в мно&shy;го&shy;по&shy;точ&shy;ной среде. Я прежде всего имею ввиду ситу&shy;а&shy;ции, когда Dispose() может начаться с раз&shy;ных кон&shy;цов графа. И в таких ситу&shy;а&shy;циях лучше всего вос&shy;поль&shy;зо&shy;ваться дру&shy;гими шаб&shy;ло&shy;нами. Нап&shy;ри&shy;мер, шаб&shy;ло&shy;ном Life&shy;time.</p>
</li>
<li>
<p >
Жела&shy;ние раз&shy;ра&shy;бот&shy;чи&shy;ков плат&shy;формы сде&shy;лать управ&shy;ле&shy;ние памятью авто&shy;ма&shy;ти&shy;чес&shy;кой вместе с реа&shy;ли&shy;ями: при&shy;ло&shy;же&shy;ния очень часто вза&shy;и&shy;мо&shy;дей&shy;ствуют с неуп&shy;рав&shy;ля&shy;е&shy;мым кодом + необ&shy;хо&shy;димо конт&shy;ро&shy;ли&shy;ро&shy;вать осво&shy;бож&shy;де&shy;ние ссы&shy;лок на объ&shy;екты, чтобы их соб&shy;рал Garbage Collector, вно&shy;сит огром&shy;ное коли&shy;чес&shy;тво пута&shy;ницы в пони&shy;ма&shy;ние воп&shy;ро&shy;сов: "как пра&shy;вильно реа&shy;ли&shy;зо&shy;вать шаб&shy;лон? и есть ли шаб&shy;лон вообще?". Воз&shy;можно вызов <code>delete obj; delete[] arr;</code> был бы проще?</p>
</li>
</ol>
<h2 id="section-5">Выгрузка домена и выход из приложения</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">50</div>
<p >
Если вы сюда дошли, зна&shy;чит, вы стали как мини&shy;мум уве&shy;рен&shy;нее в успеш&shy;ности пос&shy;ле&shy;ду&shy;ю&shy;щих собе&shy;се&shy;до&shy;ва&shy;ний. Однако мы обсу&shy;дили ещё не все воп&shy;росы, свя&shy;зан&shy;ные с этим, каза&shy;лось бы, прос&shy;тым шаб&shy;ло&shy;ном. Пос&shy;лед&shy;ним воп&shy;ро&shy;сом у нас идёт воп&shy;рос: отли&shy;ча&shy;ется ли пове&shy;де&shy;ние при&shy;ло&shy;же&shy;ния при прос&shy;том GC, GC во время выг&shy;рузки домена и GC во время выхода из при&shy;ло&shy;же&shy;ния? Про&shy;це&shy;дуры <code>Dispose()</code> этот воп&shy;рос каса&shy;ется, только если по каса&shy;тель&shy;ной&hellip; Но <code>Dispose()</code> и фина&shy;ли&shy;за&shy;ция идут рука об руку, и редко когда мы можем видеть реа&shy;ли&shy;за&shy;ции класса, в кото&shy;ром есть фина&shy;ли&shy;за&shy;ция, но нет метода <code>Dispose()</code>. Потому давайте дого&shy;во&shy;римся так: саму фина&shy;ли&shy;за&shy;цию мы опи&shy;шем в раз&shy;деле, пос&shy;вящённом фина&shy;ли&shy;за&shy;ции, а здесь лишь доба&shy;вим нес&shy;колько важ&shy;ных пунк&shy;тов.</p>
<div class="paragraph-right-side">50</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">51</div>
<p >
Когда выг&shy;ру&shy;жа&shy;ется домен при&shy;ло&shy;же&shy;ния, то выг&shy;ру&shy;жа&shy;ются как сборки, кото&shy;рые были заг&shy;ру&shy;жены в домен, так и все объ&shy;екты, кото&shy;рые были соз&shy;даны в рам&shy;ках выг&shy;ру&shy;жа&shy;е&shy;мого домена. Это зна&shy;чит, что, по сути, про&shy;ис&shy;хо&shy;дит очи&shy;ще&shy;ние (сборка GC) этих объ&shy;ек&shy;тов, и для них будут выз&shy;ваны фина&shy;ли&shy;за&shy;торы. Если наша логика фина&shy;ли&shy;за&shy;тора ждёт фина&shy;ли&shy;за&shy;ции дру&shy;гих объ&shy;ек&shy;тов, чтобы быть унич&shy;то&shy;жен&shy;ным в пра&shy;виль&shy;ном порядке, то воз&shy;можно стоит обра&shy;тить вни&shy;ма&shy;ние на свой&shy;ство <code>Environment.HasShutdownStarted</code>, обоз&shy;на&shy;ча&shy;ю&shy;щее, что при&shy;ло&shy;же&shy;ние в дан&shy;ный момент нахо&shy;дится в сос&shy;то&shy;я&shy;нии выг&shy;рузки из памяти, и метод <code>AppDomain.CurrentDomain.IsFinalizingForUnload()</code>, кото&shy;рый гово&shy;рит о том, что дан&shy;ный домен выг&shy;ру&shy;жа&shy;ется, что и явля&shy;ется при&shy;чи&shy;ной фина&shy;ли&shy;за&shy;ции. Ведь если нас&shy;ту&shy;пили эти собы&shy;тия, то в целом ста&shy;но&shy;вится всё равно, в каком порядке мы дол&shy;жны фина&shy;ли&shy;зи&shy;ро&shy;вать ресурсы. Задер&shy;жи&shy;вать выг&shy;рузку домена и при&shy;ло&shy;же&shy;ния мы не можем: наша задача всё сде&shy;лать мак&shy;си&shy;мально быс&shy;тро.</p>
<div class="paragraph-right-side">51</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">52</div>
<p >
Вот так эта задача реша&shy;ется в рам&shy;ках класса <a href="http://referencesource.microsoft.com/#mscorlib/system/reflection/loaderallocator.cs,25551b0f6db5f579">LoaderAllocatorScout</a></p>
<div class="paragraph-right-side">52</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Assemblies and LoaderAllocators will be cleaned up during AppDomain shutdown in</span>
<span style="color:Green;">// unmanaged code</span>
<span style="color:Green;">// So it is ok to skip reregistration and cleanup for finalization during appdomain shutdown.</span>
<span style="color:Green;">// We also avoid early finalization of LoaderAllocatorScout due to AD unload when the object was inside DelayedFinalizationList.</span>
<span style="color:Blue;">if</span> (!Environment.HasShutdownStarted &amp;&amp;
    !AppDomain.CurrentDomain.IsFinalizingForUnload())
{
    <span style="color:Green;">// Destroy returns false if the managed LoaderAllocator is still alive.</span>
    <span style="color:Blue;">if</span> (!Destroy(m_nativeLoaderAllocator))
    {
        <span style="color:Green;">// Somebody might have been holding a reference on us via weak handle.</span>
        <span style="color:Green;">// We will keep trying. It will be hopefully released eventually.</span>
        GC.ReRegisterForFinalize(<span style="color:Blue;">this</span>);
    }
}
</pre></div>
</div>
<h2 id="section-6">Типичные ошибки реализации</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">53</div>
<p >
Итак, как я вам пока&shy;зал, общего, уни&shy;вер&shy;саль&shy;ного шаб&shy;лона для реа&shy;ли&shy;за&shy;ции IDis&shy;po&shy;sable не сущес&shy;твует. Мало того, неко&shy;то&shy;рая уве&shy;рен&shy;ность в авто&shy;ма&shy;тизме управ&shy;ле&shy;ния памятью зас&shy;тав&shy;ляет людей путаться и при&shy;ни&shy;мать запу&shy;тан&shy;ные реше&shy;ния в реа&shy;ли&shy;за&shy;ции шаб&shy;лона. Так, нап&shy;ри&shy;мер, весь .NET Frame&shy;work про&shy;ни&shy;зан ошиб&shy;ками в его реа&shy;ли&shy;за&shy;ции. И чтобы не быть голос&shy;лов&shy;ными, расс&shy;мот&shy;рим эти ошибки именно на при&shy;мере .NET Frame&shy;work. Все реа&shy;ли&shy;за&shy;ции дос&shy;тупны по ссылке: <a href="http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs,1f55292c3174123d,references">IDisposable Usages</a></p>
<div class="paragraph-right-side">53</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">54</div>
<p >
<strong>Класс FileEntry</strong> <a href="http://referencesource.microsoft.com/#mscorlib/system/deployment/cmsinterop.cs,eeedb7095d7d3053,references">cmsinterop.cs</a></p>
<div class="paragraph-right-side">54</div>
</div>
<blockquote>
<p >
Этот код явно напи&shy;сан в спешке, чтобы по-быст&shy;рому зак&shy;рыть задачу. Автор явно что-то хотел сде&shy;лать, но потом пере&shy;ду&shy;мал и оста&shy;вил кри&shy;вое реше&shy;ние</p>
</blockquote>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">internal</span> <span style="color:Blue;">class</span> FileEntry : IDisposable
{
    <span style="color:Green;">// Other fields</span>
    <span style="color:Green;">// ...</span>
    [MarshalAs(UnmanagedType.SysInt)] <span style="color:Blue;">public</span> IntPtr HashValue;
    <span style="color:Green;">// ...</span>

    ~FileEntry()
    {
        Dispose(<span style="color:Blue;">false</span>);
    }

    <span style="color:Green;">// Реализация скрыта и затрудняет вызов *правильной* версии метода</span>
    <span style="color:Blue;">void</span> IDisposable.Dispose() { <span style="color:Blue;">this</span>.Dispose(<span style="color:Blue;">true</span>); }

    <span style="color:Green;">// Метод публичный: это серьёзная ошибка, позволяющая некорректно разрушить</span>
    <span style="color:Green;">// экземпляр класса. Мало того, снаружи этот метод НЕ вызывается</span>
    <span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose(<span style="color:Blue;">bool</span> fDisposing)
    {
        <span style="color:Blue;">if</span> (HashValue != IntPtr.Zero)
        {
            Marshal.FreeCoTaskMem(HashValue);
            HashValue = IntPtr.Zero;
        }

        <span style="color:Blue;">if</span> (fDisposing)
        {
            <span style="color:Blue;">if</span>( MuiMapping != <span style="color:Blue;">null</span>)
            {
                MuiMapping.Dispose(<span style="color:Blue;">true</span>);
                MuiMapping = <span style="color:Blue;">null</span>;
            }

            System.GC.SuppressFinalize(<span style="color:Blue;">this</span>);
        }
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">55</div>
<p >
<strong>Класс SemaphoreSlim</strong> <a href="https://github.com/dotnet/coreclr/blob/cbcdbd25e74ff9d963eafa202dd63504ca537f7e/src/mscorlib/src/System/Threading/SemaphoreSlim.cs">System/Threading/SemaphoreSlim.cs</a></p>
<div class="paragraph-right-side">55</div>
</div>
<blockquote>
<p >
Эта ошибка в топе оши&shy;бок .NET Frame&shy;work каса&shy;тельно IDis&shy;po&shy;sable: Suppress&shy;Finalize для класса, где нет фина&shy;ли&shy;за&shy;тора. Встр&shy;еч&shy;ае&shy;тся очень часто.</p>
</blockquote>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
{
    Dispose(<span style="color:Blue;">true</span>);

    <span style="color:Green;">// У класса нет финализатора - нет никакой необходимости в GC.SuppressFinalize</span>
    GC.SuppressFinalize(<span style="color:Blue;">this</span>);
}

<span style="color:Green;">// Реализация шаблона подразумевает наличие финализатора. А его нет.</span>
<span style="color:Green;">// Можно было обойтись одним public virtual void Dispose()</span>
<span style="color:Blue;">protected</span> <span style="color:Blue;">virtual</span> <span style="color:Blue;">void</span> Dispose(<span style="color:Blue;">bool</span> disposing)
{
    <span style="color:Blue;">if</span> (disposing)
    {
        <span style="color:Blue;">if</span> (m_waitHandle != <span style="color:Blue;">null</span>)
        {
            m_waitHandle.Close();
            m_waitHandle = <span style="color:Blue;">null</span>;
        }
        m_lockObj = <span style="color:Blue;">null</span>;
        m_asyncHead = <span style="color:Blue;">null</span>;
        m_asyncTail = <span style="color:Blue;">null</span>;
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">56</div>
<p >
<strong>Вызов Close+Dispose</strong> <a href="https://github.com/alexguirre/NativeWatcher/blob/7208d463c41a709f29c60264bc518c6c0c5713cc/NativeWatcher/Forms/FormsManager.cs">Код некоторого проекта NativeWatcher</a></p>
<div class="paragraph-right-side">56</div>
</div>
<blockquote>
<p >
Иногда люди вызы&shy;вают и Close, и Dispose. Но это не явля&shy;ется пра&shy;виль&shy;ным (хотя ошибка не вызо&shy;вется, так как пов&shy;тор&shy;ный Dispose не при&shy;во&shy;дит к гене&shy;ра&shy;ции исклю&shy;че&shy;ния). Воп&shy;рос в том, что Close - это ещё один шаб&shy;лон, и введён для того, чтобы людям было понят&shy;нее. Но стало непо&shy;нят&shy;нее.</p>
</blockquote>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">void</span> Dispose()
{
    <span style="color:Blue;">if</span> (MainForm != <span style="color:Blue;">null</span>)
    {
        MainForm.Close();
        MainForm.Dispose();
    }
    MainForm = <span style="color:Blue;">null</span>;
}
</pre></div>
</div>
<h2 id="section-7">Общие итоги</h2>
<ol>
<li>
<p >
IDis&shy;po&shy;sable явля&shy;ется стан&shy;дар&shy;том плат&shy;формы и от качес&shy;тва его реа&shy;ли&shy;за&shy;ции зави&shy;сит качес&shy;тво всего при&shy;ло&shy;же&shy;ния. Мало того, от этого в неко&shy;то&shy;рых ситу&shy;а&shy;циях зави&shy;сит безо&shy;пас&shy;ность вашего при&shy;ло&shy;же&shy;ния, кото&shy;рое может быть под&shy;верг&shy;нуто ата&shy;кам через неуп&shy;рав&shy;ля&shy;е&shy;мые ресурсы</p>
</li>
<li>
<p >
Реа&shy;ли&shy;за&shy;ция IDis&shy;po&shy;sable дол&shy;жна быть мак&shy;си&shy;мально про&shy;из&shy;во&shy;ди&shy;тель&shy;ной. Осо&shy;бенно это каса&shy;ется сек&shy;ции фина&shy;ли&shy;за&shy;ции, кото&shy;рая рабо&shy;тает в парал&shy;лели со всем осталь&shy;ным кодом, наг&shy;ру&shy;жая Garbage Collector</p>
</li>
<li>
<p >
При реа&shy;ли&shy;за&shy;ции IDis&shy;po&shy;sable сле&shy;дует избе&shy;гать идей синх&shy;ро&shy;ни&shy;за&shy;ции вызова Dispose() с пуб&shy;лич&shy;ными мето&shy;дами класса. Раз&shy;ру&shy;ше&shy;ние не может идти однов&shy;ре&shy;менно с исполь&shy;зо&shy;ва&shy;нием: это надо учи&shy;ты&shy;вать при про&shy;ек&shy;ти&shy;ро&shy;ва&shy;нии типа, кото&shy;рый будет исполь&shy;зо&shy;вать IDis&shy;po&shy;sable объ&shy;ект</p>
</li>
<li>
<p >
Однако стоит защи&shy;тить однов&shy;ре&shy;мен&shy;ный вызов <code>Dispose()</code> из двух пото&shy;ков: это сле&shy;дует из утверж&shy;де&shy;ния, что Dispose() не дол&shy;жен вызы&shy;вать оши&shy;бок</p>
</li>
<li>
<p >
Реа&shy;ли&shy;за&shy;ция обёрток над неуп&shy;рав&shy;ля&shy;е&shy;мыми ресур&shy;сами дол&shy;жна идти отдельно от осталь&shy;ных типов. Т.е. если вы обо&shy;ра&shy;чи&shy;ва&shy;ете неуп&shy;рав&shy;ля&shy;е&shy;мый ресурс, на это дол&shy;жен быть выде&shy;лен отдель&shy;ный тип: с фина&shy;ли&shy;за&shy;цией, унас&shy;ле&shy;до&shy;ван&shy;ный от <code>SafeHandle / CriticalHandle / CriticalFinalizerObject</code>. Это раз&shy;де&shy;ле&shy;ние ответст&shy;вен&shy;ности при&shy;ведёт к улуч&shy;шен&shy;ной под&shy;дер&shy;жке сис&shy;темы типов и упро&shy;ще&shy;нию про&shy;ек&shy;ти&shy;ро&shy;ва&shy;ния сис&shy;темы раз&shy;ру&shy;ше&shy;ния экземп&shy;ля&shy;ров типов через Dispose(): исполь&shy;зу&shy;ю&shy;щим типам не надо реа&shy;ли&shy;зо&shy;вы&shy;вать фина&shy;ли&shy;за&shy;тор.</p>
</li>
<li>
<p >
В целом шаб&shy;лон не явля&shy;ется удоб&shy;ным как в исполь&shy;зо&shy;ва&shy;нии, так и в под&shy;дер&shy;жке кода. Воз&shy;можно, сле&shy;дует перейти на Inver&shy;sion of Control про&shy;цесса раз&shy;ру&shy;ше&shy;ния сос&shy;то&shy;я&shy;ния объ&shy;ек&shy;тов через шаб&shy;лон <code>Lifetime</code>, речь о кото&shy;ром пойдёт в сле&shy;ду&shy;ю&shy;щей части.</p>
</li>
</ol>

        </div>
        <footer>
            <div class="footer-container">
                <div class="footer-wrap">
                    <img src="../../res/img/logo-w-noindex.svg">
                    <p>
                        <a class="footer-link" target="_blank" href="mailto:sidristij@clrium.ru"><i class="far fa-envelope" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://vk.com/clrium"><i class="fab fa-vk" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://youtube.com/clrium"><i class="fab fa-youtube" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://github.com/clrium"><i class="fab fa-github" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="skype:stanislav.sidristyi"><i class="fab fa-skype" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://t.me/clrium_group"><i class="fab fa-telegram" aria-hidden="true"></i></a>
                    </p>
                </div>
            </div>
        </footer>
    </div>
</body>
</html>