<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Platform Architecture</title>
</head>
<body>
    <script src="../../res/jquery.js"></script>
    <link rel="stylesheet" href="../../res/bootstrap.css">
    <link rel="stylesheet" href="../../res/awesome.css">
    <style>

body {
    font-family: PF Regal,Georgia,serif;
    font-size: 16pt;
    font-weight: 300;
    padding-top: 4em;
    background-color: #fdfdfd;
}

.book-title-container {
    width: 100%;
    text-align: center;
    margin: 73px 0 110px 0;
}

.book-title {
    font-size: 57pt;
    margin: 50px 0 70px 0;
    user-select: none;
}
.book-part-title-block {
    display: inline-block;
}
.book-part-title {
    font-size: 21pt;
    color: #656ab6;
    margin: 0 7px;
}

.book-part-title:hover {
    box-shadow: inset 0 -1px #007bff;
    text-decoration: none;
}

.book-superheading-title {
    font-size: 15pt;
    margin: 0 7px;
    color: #656ab6;
}

.article-container
{
    width: 62%;
}

strong {
    font-weight: 500;
}

p, li {
    margin: 0 0 1em;
    line-height: 1.5em;
    font-family: inherit;
}

ol, li {
    margin-top: 1em;
    margin-bottom: 1em;
}

ol {
    padding-left: 1.21em;
}

ul  {
    padding-left: 1em;
}

ol li, ul li {
    padding-left: 0.5em;	
    font-family: inherit;
    text-align: justify;
}

table {
    margin: 30px 0;
    width: 100%;
}

thead {
    background-color: aliceblue;
}

table th {
    font-weight: 400;
}

table td, table th {
    padding: 7px;
    border-top: solid darkgrey 1px;
    border-bottom: solid darkgrey 1px;
    border-right: dotted darkgray 1px;
    border-left: dotted darkgray 1px;
    font-size: smaller;
}

code, *[class*='lang-'] span, *[class*='lang-'] pre {
    font-family: JB Mono, monospace !important;
}

*[class*='lang-'] {
    padding: 0px 0px 25px 0px;
    font-size: 0.75em;
}


*[class*='lang-'] > div, pre > code {
    border-left-color: #eee;
    border-left-style: dotted;
    border-left-width: 3px;
    padding-left: 25px;
    display: block;
    padding-top: 20px;
    padding-bottom: 20px;
}

*[class*='lang-'] > div pre, pre > code pre {
    margin-bottom: 0;
}

p code:not(.highlight), li code:not(.highlight) {
    font-size: 0.7em;
    color: darkslateblue;
}

/* style for manual selecting */
.box {
    padding: 3px;
    border: gainsboro;
    border-width: 1px;
    border-style: solid;
}

code.highlight {
    font-family: inherit !important;
    font-size: inherit;
    font-weight: inherit;
    color: inherit;
}

p code.highlight, li code.highlight {
    padding: 4px;
    background-color: #ffffa1;
}

.wide {
    width:140%;
}

p a, li a {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #b88b59;
}

p a:hover, li a:hover {
    text-decoration: none;
    color: inherit;
    box-shadow: inset 0 -1px #0056b3;
}

blockquote h5 {
    background-color: aquamarine;
    margin: 16px 0 16px -20px;
    padding: 15px 30px 15px;
}

p img {
    width: 95%;
}

blockquote 
{
    padding-left: 0.4em;
    border-left: 0.5em solid rgba(0,0,0,.08);
    font-style: italic;
}

blockquote.big-quote, 
blockquote.breadcrumbs 
{
    background-color: transparent;
    padding: 0;
    border-left: none;
    font-style: normal;
}

blockquote.breadcrumbs, blockquote.breadcrumbs  p
{
    margin: 0;
    padding: 0;
}

blockquote p {
    padding: 1em 1em 1em 0.6em;
    font-family: inherit;
}

blockquote p code {
    font-family: consolas, monospace;
    font-size: 17px;
    padding: 4px 6px;
}

blockquote p em {
    font-weight: 400;
}

blockquote.big-quote > p {
    margin: 0.7em 0 0.7em 0;
    font-family: Charter;
    font-size: 2.5em;
    padding: 0;
    width: 130%;
    line-height: 1em;
}

h1, h2, h3, h4, h5, h6 {
    margin: 0;
    padding: 0;
    font-weight: 400;
    font-family: inherit;
    hyphens: none;
}

h1 {
    font-size: 2.2em;
    font-family: Charter,Georgia,serif;
    font-weight: 300;
    margin: 1.8em 0 1.8em 0;
    text-align: center;
    width: 140%;
}

h2 {
    padding-top: 1.5em;
    padding-left: 1.5em;
    padding-right: 1.5em;
    margin-bottom: 0.5em;
    font-family: Charter, Arial, Helvetica Neue, sans-serif;
    font-size: 1.4em;
    text-align: center;
}

h3 {
    padding-top: 1.2em;
    font-family: Charter, Arial, Helvetica Neue, sans-serif;
    font-size: 1.15em;
    width: 70%;
}

h4 {
    padding: 1em 0 0 0;
    font-size: 1.2em;
    font-weight: 300;
    font-style: italic;
}

h5 {
    padding: 0.6em 0 0 0;
    font-weight: 300;
    font-size: 1.1em;
}

/* Sidenotes */

.aside-container {
    position: relative;
}
.aside-container p {
    position: relative;
    top: 9px;
}

.aside-container > .aside-side-container {
    display: block;
    position: absolute;
    top: 12px;
    left: 96%;
    width: 34%;
    font-size: 12pt;
    line-height: 20px;
    margin-left: 100px;
    z-index: 1000;
}

.aside-container > .aside-side-container p {
    line-height: 24px;
    font-size: 13pt;
    margin: 0 0 13px 0;
}

.side-regular-block p {
    top: 0;
}

/* Music side player */
.aside-side-container .music-player {
    width: 100%;
    height: 400px;
}

/* media block after h1 */
.aside-container h1 + .aside-side-container.side-media-block h2 {
    margin: 7em 0 1em 0;
    font-family: Proxima Nova,Arial,Helvetica Neue,sans-serif;
    font-weight: 600;
}

.aside-side-container > li {
    display: block;
    font-family: Charter;
}

.aside-side-container > li ul, .aside-side-container > li ol {
    padding-left: 30px;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
.aside-side-container > li li {
    padding-left: 6px;
    margin: 0 0 6px;
    line-height: 22px;

    font-family: Charter;
}

.aside-side-container p {
    line-height: 25px;
    font-size: 13pt;
    margin: 0 0 15px 0;
}

.aside-side-container blockquote {
    border: aliceblue;
    border-left-style: solid;
}

/* Paragraphs numbering */
.paragraph-container {
    position: relative;
}
.paragraph-container p {
    position: relative;
    top: 9px;
}

.paragraph-container p, .aside-container > p {
    text-align: justify;
}

.paragraph-container > .paragraph-left-side, .paragraph-container > .paragraph-right-side  {
    font-family: JB Mono, consolas;
    display: block;
    position: absolute;
    top: 17px;
    font-size: 10pt;
    line-height: 20px;
    color: #86abc473;
    z-index: 1000;
}
.paragraph-container > .paragraph-left-side {
    display: none;
    left: -2.1cm;
    width: 35px;
    user-select: none;
}

.paragraph-container > .paragraph-right-side  {
    display: none;
    left: 100%;
    width: 35px;
    padding-left: 45px;
    user-select: none;
}

.article-container
{
    width: 70%;
}

/* X_MENU */
.menu-title {
    text-align: center;
    margin: 35px 50px 35px 50px;
    font-size: 24pt;
    font-family: Charter;
}

.menu-container ol {
    margin: 0;
    padding: 0;
}

.menu-container ol li {
    margin: 0;
    padding: 0;
}

.header {
    height: 2.5em;
    background-color: white;
    position: relative;
    z-index: 1500;
    width: 100%;
    display: flex;
    justify-content: space-between;
    transition: all 1s;
    top: 0;
    box-shadow: 1px -4px 20px rgba(0, 0, 0, .1);
}

.fixed {
    position: fixed !important;
}

.header > .menu {
    pointer-events: auto;
    float: right;
    height: 40px;
    font-family: Charter, 'Helvetica Neue', Arial, sans-serif;
    font-size: 1em;
    color: #fff;
    margin-top:40px;
    margin-right:40px;
}

.menu a {
    color: #fff;
}
.menu a:hover {
    text-decoration: none;
    color: #fff;
}

#menu__toggle {
    opacity: 0;
}

#menu__toggle:checked ~ .menu__btn > span {
    transform: rotate(45deg);
}
#menu__toggle:checked ~ .menu__btn > span::before {
    top: 0;
    transform: rotate(0);
    background-color: black
}
#menu__toggle:checked ~ .menu__btn > span::after {
    top: 0;
    transform: rotate(90deg);
    background-color: black
}
#menu__toggle:checked ~ .menu__box {
    visibility: visible;
    right: 0;
}

.menu__btn {
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    right: 0;
    width: 2.5em;
    height: 2.5em;
    cursor: pointer;
    z-index: 1;
    margin: 0;
    padding: 0.7em;
}

.menu__btn > span,
.menu__btn > span::before,
.menu__btn > span::after {
    display: block;
    position: absolute;

    width: 1.1em;
    height: 1px;

    border-bottom: 1px black solid;

    transition-duration: .25s;
}
.menu__btn > span::before {
    content: '';
    top: -7px;
}
.menu__btn > span::after {
    content: '';
    top: 7px;
}

.menu__box {
    display: block;
    position: fixed;
    visibility: hidden;
    top: 0;
    right: -100%;

    width: 100%;
    height: 100%;

    margin: 0;
    padding: 80px 0;

    list-style: none;

    background-color: white;
    box-shadow: 1px 0px 6px rgba(0, 0, 0, .2);

    transition-duration: .25s;

    overflow-y: auto;
}
.menu__box li a:hover {
    text-decoration: none;
    color: inherit;
}
.menu__list {
    font-size: 0.9em;
    margin: 0 2em 0 2em;
}
.menu__list li {
    text-align: left;
}

/* X_HEADER */

.conflogo {
    margin: 0.5em 0 0 0.8em;
    font-size: 1.1em;
    font-family: Charter;
    user-select: none;
}

.invisible {
    display: none;
}

.header > .menu > div {
    display: inline;
    margin-left: 10px;
    margin-right: 10px;
}

.menu__header_current
{
    text-align: center;
    font-size: 2em;
    margin: 0 0 1em 0;
}

.menu__header_total
{
    text-align: center;
    font-size: 2.4em;
    margin: 1.7em 0 0.3em 0;
}
.menu__header_list 
{
    padding: 0;
    margin-top: 0;
    margin-left: 0;
    margin-right: 0;
}
.menu__header_list > li 
{
    display: inline-block;
    width: 100%;
    margin: 0;
    text-align: center;
    font-family: charter;
}
.menu__header_total_sub
{
    font-size: 1.4em;
    margin: 2em 0 1em 0;
}
.menu__header_total_sub2
{
    font-size: 1.1em;
    margin: 1.5em 0 0.6em 1em;
    text-align: left;
}
/* X_FOOTER */

footer {
    margin-top: 2em;
    background-color: black;
    height: 4em;
}

footer > div {
    box-shadow: 0px 2px 2px rgb(0, 0, 0);
}

.footer-container {
    height: 100%;
}

.footer-wrap {
    color: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 25px 0;
}

.footer-wrap p {
    margin: 0;
    padding: 0px;
    line-height: 1em;
}

.footer-container img {
    height: 1.6em;
    margin-top: auto;
    margin-bottom: auto;
}

.footer-link {
    color: white;
    margin: 0 7px;
    font-size: 1em;
    box-shadow: none;
}

.footer-link:hover {
    color: salmon;
    box-shadow: none;
}

/* MEDIA */
/* XXL */
@media (min-width: 1601px) {
    .book-container
    {
        max-width: 1200px;
        margin-left: auto;
        margin-right: auto;
    }
}

/* XL */
@media (max-width: 1600px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }
}

/* LG */
@media (max-width: 1400px) {
    .book-container
    {
        margin-left: 4cm;
        margin-right: 4cm;
    }

    blockquote.big-quote > p {
        font-size: 2em;
    }
}

/* > MD */
@media (min-width: 992px) {
    .hamburger-menu {
        display: none;
    }
}

/* MD */
@media (max-width: 991px) {
    
    h3 {
        width:80%;
    }

    .book-container
    {
        margin-left: 3cm;
        margin-right: 3cm;
    }
    
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    .book-title {
        font-size: 50pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 15pt;
    }                                     

    .article-container, h1 {
        width: 100%;
    }

    .aside-container p {
        top: 0;
    }

    .aside-container h1 + .aside-side-container.side-media-block h2 {
        display: none;
    }

    .wide {
        width: 100%;     
    }

    .side-regular-block {
        margin: 40px 10px;
        padding-left: 100px;
    }
    .aside-side-container .music-player {
        width: 100%;
        height: 100px;
    }
    .aside-side-container.side-media-block {
        padding: 17px 0;
    }
    .aside-side-container.side-media-block h2 {
        margin-top: 20px;
        font-size: 13pt;
        border: none;
    }

    .aside-container > .aside-side-container
    {
        position: relative;
        top: auto;
        left: auto;
        width: auto;
        height: auto;
        margin: 0;
        padding: 17px;
    }

    blockquote.big-quote > p {
        width: 100%;
        font-size: 2em;
    }

    .paragraph-container .paragraph-left-side {
        left: -55px;
    }

    body {
        font-size: 15pt;
    }

    p code:not(.highlight), li code:not(.highlight) {
        font-size: 11pt;
    }

    p, li {
        line-height: 30px;
    }
    
    li {
        margin: 0 0 10px 0;
    }

    .side-regular-block {
        border-radius: 5px;
        background-image: linear-gradient(180deg,hsla(0,0%,100%,0) 60%,#fff),linear-gradient(70deg,#dbedff 32%,#ebfff0);
        padding: 22px;
    }    

    .menu__list
    {
        margin-top: 0;
        margin-bottom: 0;
    }

    .menu__list, .menu__header_total_sub2
    {
        margin-left: auto;
        margin-right: auto;
        max-width: 800px;
        width: 80%;
    }

    .book-container 
    {
        position: absolute;
        padding: 0 3cm 0 3cm;
        overflow: scroll;
        overflow-x: auto;
        top: 2.5em;
        bottom: 0;
        width: 100%;
        margin: 0;
    }

    footer {
        margin-top: 2em;
        background-color: black;
        height: 4em;
    }

    footer > div {
        position: relative;
        margin: 0 -3cm;
        background: black;
        padding: 0 3cm;
    }
}

/* Smartphone horizontal - SM */
@media (max-width: 767px) {
    .book-title-container {
        margin: 73px 0 110px 0;
    }

    h1 {
        margin: 1.8em 0em 1.8em 0.3em;
    }

    .book-title {
        font-size: 40pt;
        margin: 50px 0 70px 0;
    }

    .book-part-title {
        font-size: 19pt;
    }

    .book-part-title:hover {
        box-shadow: inset 0 -1px #007bff;
    }

    .book-superheading-title {
        font-size: 17pt;
    }

    .book-container {
        padding: 0 2.5cm;
    }
    ul {
        margin-left: 30px;
        margin-right: 30px;
        padding-left: 25px;
    }
    .paragraph-container > .paragraph-left-side {
	    display: block;
        top: 14px;
        font-size: 9pt;
    }
    .paragraph-container > .paragraph-right-side {
    	display: block;
        padding-left: 40px;
        top: 14px;
        font-size: 9pt;
    }
    .footer-container img {
        height: 1.3em;
    } 
}

@media (max-width: 630px) {
    .book-container {
        padding: 0 1.5cm;
    }
    .paragraph-container > .paragraph-left-side {
        left: -33px;
    }
    .paragraph-container > .paragraph-right-side {
        padding-left: 24px;
    }
}
/* Smartphone - XS */
@media (max-width: 575px) {
    .book-container {
        padding: 0 50px 0 30px;
    }
    ul {
        margin: 0;
        padding-left: 20px;
    }

    body {
        font-size: 13pt;
    }

    p code:not(.highlight), li code:not(.highlight) 
    {
        font-size: 10pt;
        padding: 3px;
    }

    *[class*='lang-'] > div, pre > code {
        padding-left: 15px;
        padding-top: 15px;
        padding-bottom: 15px;
    }
    
    ol li, ul li {
        padding-left: 0.2em;	
    }
    
    p, li {
        line-height: 24px;
    }    
    
    .paragraph-container .paragraph-left-side 
    {
        display: none;        
    }
    .paragraph-container .paragraph-right-side 
    {
        padding-left: 21px;
        top: 14px;
	    font-size: 8pt;
    }
    .footer-container img {
        height: 1em;
    } 
    .menu__list {
        margin: 0 1em 0 1em;
    }
    .menu__header_total_sub2
    {
        margin: 1.5em 0 0.6em 1em;
    }
}

/* Fonts */

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-Bold.eot');
    src: local('../../res/fonts/PFRegalTextPro-Bold'),
        url('../../res/fonts/PFRegalTextPro-Bold.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-Bold.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-Medium.eot');
    src: local('../../res/fonts/PFRegalTextPro-Medium'),
        url('../../res/fonts/PFRegalTextPro-Medium.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-Medium.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-BlackItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-BlackItalic'),
        url('../../res/fonts/PFRegalTextPro-BlackItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-BlackItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-BlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-Black.eot');
    src: local('../../res/fonts/PFRegalTextPro-Black'),
        url('../../res/fonts/PFRegalTextPro-Black.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-Black.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-Black.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal UBlack';
    src: url('../../res/fonts/PFRegalTextPro-UBlack.eot');
    src: local('../../res/fonts/PFRegalTextPro-UBlack'),
        url('../../res/fonts/PFRegalTextPro-UBlack.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-UBlack.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-UBlack.ttf') format('truetype');
    font-weight: 900;
    font-style: normal;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-MediumItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-MediumItalic'),
        url('../../res/fonts/PFRegalTextPro-MediumItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-MediumItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-MediumItalic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-UBlackItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-UBlackItalic'),
        url('../../res/fonts/PFRegalTextPro-UBlackItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-UBlackItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-UBlackItalic.ttf') format('truetype');
    font-weight: 900;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-RegularAItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-RegularAItalic'),
        url('../../res/fonts/PFRegalTextPro-RegularAItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-RegularAItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-RegularAItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-BoldItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-BoldItalic'),
        url('../../res/fonts/PFRegalTextPro-BoldItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-BoldItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-BoldItalic.ttf') format('truetype');
    font-weight: bold;
    font-style: italic;
}

@font-face {
    font-family: 'Charter';
    src: url('../../res/fonts/charter-regular.woff2') format('woff2');
    font-weight: normal;
    font-style: normal;
}

/*  Regular B */
@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-RegularBItalic.eot');
    src: local('../../res/fonts/PFRegalTextPro-RegularBItalic'),
        url('../../res/fonts/PFRegalTextPro-RegularBItalic.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-RegularBItalic.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-RegularBItalic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'PF Regal';
    src: url('../../res/fonts/PFRegalTextPro-RegularB.eot');
    src: local('../../res/fonts/PFRegalTextPro-RegularB'),
        url('../../res/fonts/PFRegalTextPro-RegularB.woff2') format('woff2'),
        url('../../res/fonts/PFRegalTextPro-RegularB.woff') format('woff'),
        url('../../res/fonts/PFRegalTextPro-RegularB.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Regular.eot');
    src: local('../../res/fonts/JetBrainsMono-Regular'),
        url('../../res/fonts/JetBrainsMono-Regular.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Regular.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Regular.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Italic.eot');
    src: local('../../res/fonts/JetBrainsMono-Italic'),
        url('../../res/fonts/JetBrainsMono-Italic.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Italic.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Italic.ttf') format('truetype');
    font-weight: 300;
    font-style: italic;
}

@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Medium.eot');
    src: local('../../res/fonts/JetBrainsMono-Medium'),
        url('../../res/fonts/JetBrainsMono-Medium.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Medium.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
}
@font-face {
    font-family: 'JB Mono';
    src: url('../../res/fonts/JetBrainsMono-Medium-Italic.eot');
    src: local('../../res/fonts/JetBrainsMono-Medium-Italic'),
        url('../../res/fonts/JetBrainsMono-Medium-Italic.woff2') format('woff2'),
        url('../../res/fonts/JetBrainsMono-Medium-Italic.woff') format('woff'),
        url('../../res/fonts/JetBrainsMono-Medium-Italic.ttf') format('truetype');
    font-weight: 500;
    font-style: italic;
}
@font-face {
    font-family: 'Font Awesome 5 Free';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url("../../res/fonts/webfonts/fa-regular-400.eot");
    src: url("../../res/fonts/webfonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), 
         url("../../res/fonts/webfonts/fa-regular-400.woff2") format("woff2"), 
         url("../../res/fonts/webfonts/fa-regular-400.woff") format("woff"), 
         url("../../res/fonts/webfonts/fa-regular-400.ttf") format("truetype"), 
         url("../../res/fonts/webfonts/fa-regular-400.svg#fontawesome") format("svg"); 
    font-display: swap;
}
    
.fa {
    font-family: 'Font Awesome 5 Free';
    font-weight: 400;
    font-display: swap;
}
@font-face {
  font-family: 'Font Awesome 5 Brands';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../../res/fonts/fa-brands-400.eot");
  src: url("../../res/fonts/fa-brands-400.eot?#iefix") format("embedded-opentype"), url("../../res/fonts/fa-brands-400.woff2") format("woff2"), url("../../res/fonts/fa-brands-400.woff") format("woff"), url("../../res/fonts/fa-brands-400.ttf") format("truetype"), url("../../res/fonts/fa-brands-400.svg#fontawesome") format("svg"); 
}

.fab {
  font-family: 'Font Awesome 5 Brands';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 400;
  font-display: auto;
  src: url("../../res/fonts/fa-regular-400.eot");
  src: url("../../res/fonts/fa-regular-400.eot?#iefix") format("embedded-opentype"), url("../../res/fonts/fa-regular-400.woff2") format("woff2"), url("../../res/fonts/fa-regular-400.woff") format("woff"), url("../../res/fonts/fa-regular-400.ttf") format("truetype"), url("../../res/fonts/fa-regular-400.svg#fontawesome") format("svg"); 
}

.far {
  font-family: 'Font Awesome 5 Free';
  font-weight: 400; 
}

@font-face {
  font-family: 'Font Awesome 5 Free';
  font-style: normal;
  font-weight: 900;
  font-display: auto;
  src: url("../../res/fonts/fa-solid-900.eot");
  src: url("../../res/fonts/fa-solid-900.eot?#iefix") format("embedded-opentype"), url("../../res/fonts/fa-solid-900.woff2") format("woff2"), url("../../res/fonts/fa-solid-900.woff") format("woff"), url("../../res/fonts/fa-solid-900.ttf") format("truetype"), url("../../res/fonts/fa-solid-900.svg#fontawesome") format("svg"); 
}
</style>  
    <div class="book-title-container d-none d-lg-block">
        <div class="book-title">Knowledge Base</div>
        <div class="book-part-title-block">pt.1 <a href="../..//ru/Memory/01-00-MemoryManagement-Intro.html" class="book-part-title">Управление памятью</a></div>
        <div class="book-part-title-block">pt.2 <a href="../..//ru/Execution/02-00-ExecutionFlow-Intro.html" class="book-part-title">Поток исполнения команд</a></div>
        <br><a href="#" class="book-superheading-title">Обоснование выбора</a>
        / <a href="#" class="book-superheading-title">Упрощенное описание</a>
        / <a href="#" class="book-superheading-title">Подробное описание</a>
    </div>
    <header class="header fixed d-block d-lg-none">
        <p class="conflogo">KB</p> 

        <!-- mobile-menu -->

        <div class="hamburger-menu">
            <input id="menu__toggle" type="checkbox" />
            <label class="menu__btn" for="menu__toggle">
              <span></span>
            </label>
        
            <div class="menu__box">
                <p class="menu__header_current">На странице</p>
                <ol class="menu__list">
                    <li><a href="#x86" onclick="$('#menu__toggle').click(); return true;">
Базовая структура, платформа x86</a></li>
<li><a href="#x86-1" onclick="$('#menu__toggle').click(); return true;">
Немного про исключения на платформе x86</a></li>
<li><a href="#x64-amd64-in-progress" onclick="$('#menu__toggle').click(); return true;">
Базовые сведения про платформы x64, AMD64 </a></li>
<li><a href="#x64-amd64-in-progress-1" onclick="$('#menu__toggle').click(); return true;">
Исключения на платформах x64, AMD64 </a></li>
<li><a href="#section-1" onclick="$('#menu__toggle').click(); return true;">
Совсем немного про несовершенство стека потока</a></li>
<li><a href="#section-2" onclick="$('#menu__toggle').click(); return true;">
Большой пример: клонирование потока на платформе х86</a></li>
<li><a href="#stackalloc-1" onclick="$('#menu__toggle').click(); return true;">
Выводы к stackalloc</a></li>

                </ol>
                <p class="menu__header_total">Содержание</p>
                <ul class="menu__header_list">
                    <li>
                        <p class="menu__header_total_sub">
                            Управление памятью
                        </p>
                        <p class="menu__header_total_sub2">
                            Теоретические вопросы:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="../..//ru/Memory/01-00-MemoryManagement-Intro.html">
                                Общие слова
                            </a></p></li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-02-MemoryManagement-Basics.html">Введение в управление памятью</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-04-MemoryManagement-ThreadStack.html">Стек потока</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-06-MemoryManagement-EntitiesLifetime.html">Время жизни сущности</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-08-MemoryManagement-RefVsValueTypes.html">RefTypes, ValueTypes, Boxing &amp; Unboxing</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-10-MemoryManagement-IDisposable.html">Шаблон IDisposable</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-12-MemoryManagement-Finalizer.html">Финализация</a></p>
                            </li>
                            <li>
                                <p>
                                <a href="../..//ru/Memory/01-14-MemoryManagement-Results.html">Выводы</a></p>
                            </li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Практические вопросы:
                        </p>
                        <ol class="menu__list" start="9">
                            <li><p><a href="../..//ru/Memory/02-02-MemoryManagement-MemorySpan.html">
                                Memory&lt;T&gt;, Span&lt;T&gt;
                            </a></p></li>
                        </ol> 
                    </li>
                    <li>
                        <p class="menu__header_total_sub">
                            Поток исполнения команд
                        </p>
                        <p class="menu__header_total_sub2">
                            Многопоточность:
                        </p>
                        <ol class="menu__list">
                            <li><p><a href="../..//ru/Execution/1-Threads/1-OS/1-threadsScheduling.html">
                                Потоки и планирование потоков
                            </a></p></li>
                        </ol>
                        <p class="menu__header_total_sub2">
                            Искл­юч­ител­ьные си­ту­а­ции:
                        </p>
                        <ol class="menu__list" start="2">
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/1-Exceptions-Intro.html">
                                Введение в исключительные ситуации
                            </a></p></li>
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/2-Exceptions-Architecture.html">
                                Архитектура исключительной ситуации
                            </a></p></li>
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/3-Exceptions-Events.html">
                                События об исключительных ситуациях
                            </a></p></li>
                            <li><p><a href="../..//ru/Execution/2-ExceptionalFlow/4-Exceptions-Types.html">
                                Виды исключительных ситуаций
                            </a></p></li>
                        </ol>
                    </li>
                </ul>
            </div>
        </div>
    </header>

    <div class="book-container">
        <div class="article-container">
            <!--<p class="d-xs-block d-sm-none">XS</p>
            <p class="d-none d-xs-block d-sm-none">SM</p>
            <p class="d-none d-sm-block d-md-none">MD</p>
            <p class="d-none d-lg-block d-xl-none">LG</p>
            <p class="d-none d-xl-block">XL</p> -->
            <h1 id="section">Стек потока</h1>
<h2 id="x86">Базо&shy;вая струк&shy;тура, плат&shy;форма x86</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">01</div>
<p>Сущес&shy;твует область памяти, про кото&shy;рую редко захо&shy;дит раз&shy;го&shy;вор. Однако эта область явля&shy;ется, воз&shy;можно, основ&shy;ной в работе при&shy;ло&shy;же&shy;ния. Самой часто исполь&shy;зу&shy;е&shy;мой, дос&shy;та&shy;точно огра&shy;ни&shy;чен&shy;ной с момен&shy;таль&shy;ным выде&shy;ле&shy;нием и осво&shy;бож&shy;де&shy;нием памяти. Область эта назы&shy;ва&shy;ется &laquo;стек потока&raquo;. Причём пос&shy;кольку ука&shy;за&shy;тель на него коди&shy;ру&shy;ется по своей сути регист&shy;рами про&shy;цес&shy;сора, кото&shy;рые вхо&shy;дят в кон&shy;текст потока, то в рам&shy;ках испол&shy;не&shy;ния любого потока стек потока свой. Зачем он необ&shy;хо&shy;дим?</p>
<div class="paragraph-right-side">01</div>
</div>
<p>Итак, раз&shy;берём эле&shy;мен&shy;тар&shy;ный при&shy;мер кода:</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Method1()
{
    Method2(123);
}

<span style="color:Blue;">void</span> Method2(<span style="color:Blue;">int</span> arg)
{
    <span style="color:Green;">// ...</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">02</div>
<p>В дан&shy;ном коде не про&shy;ис&shy;хо&shy;дит ничего при&shy;ме&shy;ча&shy;тель&shy;ного, однако не будем его про&shy;пус&shy;кать, а нао&shy;бо&shy;рот: пос&shy;мот&shy;рим на него мак&shy;си&shy;мально вни&shy;ма&shy;тельно. Когда любой <code>Method1</code> вызы&shy;вает любой <code>Method2</code>, то абсо&shy;лютно любой такой вызов (и не только в .NET, но и в дру&shy;гих плат&shy;фор&shy;мах) осу&shy;щес&shy;твляет сле&shy;ду&shy;ю&shy;щие опе&shy;ра&shy;ции:</p>
<div class="paragraph-right-side">02</div>
</div>
<ol>
<li>Пер&shy;вое, что делает код, ском&shy;пи&shy;ли&shy;ро&shy;ван&shy;ный JIT'ом: он сох&shy;ра&shy;няет пара&shy;метры метода в стек (начи&shy;ная с трет&shy;ьего). При этом пер&shy;вые два пере&shy;да&shy;ются через регис&shy;тры. Тут важно пом&shy;нить, что пер&shy;вым пара&shy;мет&shy;ром экземп&shy;ляр&shy;ных мето&shy;дов передаётся ука&shy;за&shy;тель на тот объ&shy;ект, с кото&shy;рым рабо&shy;тает метод. Т.е. ука&shy;за&shy;тель <code>this</code>. Так что в этих (почти всех) слу&shy;чаях для регист&shy;ров остаётся всего один пара&shy;метр, а для всех осталь&shy;ных  &mdash;  стек;</li>
<li>Далее ком&shy;пи&shy;ля&shy;тор ста&shy;вит инстр&shy;укцию вызова метода <code>call</code>, кото&shy;рая поме&shy;щает в стек адрес возв&shy;рата из метода: адрес сле&shy;ду&shy;ю&shy;щей за <code>call</code> инстр&shy;ук&shy;цией. Таким обра&shy;зом любой метод знает, куда ему необ&shy;хо&shy;димо вер&shy;нуться, чтобы вызы&shy;ва&shy;ю&shy;щий код смог про&shy;дол&shy;жить работу;</li>
<li>После того как все пара&shy;метры пере&shy;даны, а метод выз&shy;ван, нам надо как-то понять, как стек восс&shy;та&shy;но&shy;вить в слу&shy;чае выхода из метода, если мы не хотим забо&shy;титься о подсчёте зани&shy;ма&shy;е&shy;мых нами в стеке бай&shy;тов. Для этого мы сох&shy;ра&shy;няем зна&shy;че&shy;ние регис&shy;тра EBP, кото&shy;рый всегда хра&shy;нит ука&shy;за&shy;тель на начало теку&shy;щего кадра стека (т.е. учас&shy;тка, где хра&shy;нится инфор&shy;ма&shy;ция для конк&shy;рет&shy;ного выз&shy;ван&shy;ного метода). Сох&shy;ра&shy;няя при каж&shy;дом вызове зна&shy;че&shy;ние этого регис&shy;тра, мы тем самым фак&shy;ти&shy;чески создаём однос&shy;вяз&shy;ный спи&shy;сок сте&shy;ко&shy;вых кад&shy;ров. Но прошу заме&shy;тить, что по факту они идут чётко друг за дру&shy;гом, без каких-либо про&shy;бе&shy;лов. Однако для упро&shy;ще&shy;ния осво&shy;бож&shy;де&shy;ния памяти из-под кадра и для отладки при&shy;ло&shy;же&shy;ния (отлад&shy;чик исполь&shy;зует эти ука&shy;за&shy;тели, чтобы отоб&shy;ра&shy;зить Stack Trace&shy;) стр&shy;ои&shy;тся однос&shy;вяз&shy;ный спи&shy;сок;</li>
<li>Пос&shy;лед&shy;нее, что надо сде&shy;лать при вызове метода,  &mdash;  выде&shy;лить учас&shy;ток памяти под локаль&shy;ные пере&shy;мен&shy;ные. Пос&shy;кольку ком&shy;пи&shy;ля&shy;тор зара&shy;нее знает, сколько её пона&shy;до&shy;бится, то делает он это сразу, сдви&shy;гая ука&shy;за&shy;тель на вер&shy;шину стека (SP/ESP/RSP) на необ&shy;хо&shy;ди&shy;мое коли&shy;чес&shy;тво байт;</li>
<li>И нако&shy;нец, на пятом этапе выпол&shy;ня&shy;ется код метода, полез&shy;ные опе&shy;ра&shy;ции;</li>
<li>Когда про&shy;ис&shy;хо&shy;дит выход из метода, то вер&shy;шина стека восс&shy;та&shy;нав&shy;ли&shy;ва&shy;ется из EBP  &mdash;  места, где хра&shy;нится начало теку&shy;щего сте&shy;ко&shy;вого кадра;</li>
<li>Далее, пос&shy;лед&shy;ним эта&shy;пом осу&shy;щес&shy;тв&shy;ляется выход из метода через инстр&shy;укцию <code>ret</code>. Она заби&shy;рает со стека адрес возв&shy;рата, забот&shy;ливо остав&shy;лен&shy;ный ранее инстр&shy;ук&shy;цией <code>call</code> и делает <code>jmp</code> по этому адресу.</li>
</ol>
<p>Те же самые про&shy;цессы можно пос&shy;мот&shy;реть на изоб&shy;ра&shy;же&shy;нии:</p>
<p><img src="./imgs/ThreadStack/AnyMethodCall.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">03</div>
<p>Также замечу, что стек &laquo;растёт&raquo;, начи&shy;ная со стар&shy;ших адре&shy;сов и закан&shy;чи&shy;вая млад&shy;шими, т.е. в обрат&shy;ную сто&shy;рону.</p>
<div class="paragraph-right-side">03</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">04</div>
<p>Глядя на все это, невольно при&shy;хо&shy;дишь к выводу, что если не боль&shy;шинство, то мини&shy;мум поло&shy;вина всех опе&shy;ра&shy;ций, кото&shy;рыми зани&shy;ма&shy;ется про&shy;цес&shy;сор  &mdash;  это обслу&shy;жи&shy;ва&shy;ние струк&shy;туры прог&shy;раммы, а не её полез&shy;ной наг&shy;рузки. Т.е. обслу&shy;жи&shy;ва&shy;ние вызо&shy;вов мето&shy;дов, про&shy;верки типов на воз&shy;мож&shy;ность при&shy;вести один к дру&shy;гому, ком&shy;пи&shy;ля&shy;цию Generic вари&shy;а&shy;ций, поиск мето&shy;дов в таб&shy;ли&shy;цах интер&shy;фей&shy;сов&hellip; Осо&shy;бенно если мы вспом&shy;ним, что боль&shy;шинство сов&shy;ре&shy;мен&shy;ного кода напи&shy;сано с под&shy;хо&shy;дом работы через интер&shy;фейсы, раз&shy;бивку на мно&shy;жес&shy;тво пусть малень&shy;ких, но выпол&shy;ня&shy;ю&shy;щих каж&shy;дый  &mdash;  своё  &mdash;  мето&shy;дов… А работа при этом часто идёт с базо&shy;выми типами и при&shy;ве&shy;де&shy;нием типов то к интер&shy;фейсу, то к нас&shy;лед&shy;нику. При всех таких вхо&shy;дя&shy;щих усло&shy;виях вывод о рас&shy;то&shy;чи&shy;тель&shy;ности инф&shy;раст&shy;рук&shy;тур&shy;ного кода вполне может наз&shy;реть. Един&shy;ствен&shy;ное, что я могу вам на это все ска&shy;зать: ком&shy;пи&shy;ля&shy;торы, в том числе и JIT, обла&shy;дают мно&shy;жест&shy;вом тех&shy;ник, поз&shy;во&shy;ля&shy;ю&shy;щим им делать более про&shy;дук&shy;тив&shy;ный код. Где можно  &mdash;  вместо вызова метода встав&shy;ля&shy;ется его тело цели&shy;ком, а где воз&shy;можно вместо поиска метода в VSD интер&shy;фейса осу&shy;щес&shy;тв&shy;ляется его пря&shy;мой вызов. Что самое грус&shy;т&shy;ное, инф&shy;раст&shy;рук&shy;тур&shy;ную наг&shy;рузку очень сложно заме&shy;рить: надо чтобы JITter либо какой-либо ком&shy;пи&shy;ля&shy;тор встав&shy;лял бы какие-то мет&shy;рики до и после мест работы инф&shy;раст&shy;рук&shy;тур&shy;ного кода. Т.е. до вызова метода, а внутри метода  &mdash;  после ини&shy;ци&shy;а&shy;ли&shy;за&shy;ции кадра стека. До выхода из метода, после выхода из метода. До ком&shy;пи&shy;ля&shy;ции, после ком&shy;пи&shy;ля&shy;ции. И так далее. Однако, давайте не будем о груст&shy;ном, а пого&shy;во&shy;рим лучше о том, что мы можем с вами сде&shy;лать с полу&shy;чен&shy;ной инфор&shy;ма&shy;цией.</p>
<div class="paragraph-right-side">04</div>
</div>
<h2 id="x86-1">Нем&shy;ного про исклю&shy;че&shy;ния на плат&shy;форме x86</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">05</div>
<p>Если мы пос&shy;мот&shy;рим внутрь кода мето&shy;дов, то мы заме&shy;тим ещё одну струк&shy;туру, рабо&shy;та&shy;ю&shy;щую со сте&shy;ком потока. Посу&shy;дите сами:</p>
<div class="paragraph-right-side">05</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> Method1()
{
    <span style="color:Blue;">try</span>
    {
        Method2(123);
    } <span style="color:Blue;">catch</span> {
        <span style="color:Green;">// ...</span>
    }
}

<span style="color:Blue;">void</span> Method2(<span style="color:Blue;">int</span> arg)
{
    Method3();
}

<span style="color:Blue;">void</span> Method3()
{
    <span style="color:Blue;">try</span>
    {
        <span style="color:Green;">//...</span>
    } <span style="color:Blue;">catch</span> {
        <span style="color:Green;">//...</span>
    }
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">06</div>
<p>Если исклю&shy;че&shy;ние воз&shy;ник&shy;нет в любом из мето&shy;дов, выз&shy;ван&shy;ных из <code>Method3</code>, то управ&shy;ле&shy;ние будет возв&shy;ра&shy;щено в блок <code>catch</code> метода <code>Method3</code>. При этом если исклю&shy;че&shy;ние обра&shy;бо&shy;тано не будет, то его обра&shy;ботка начнётся в методе <code>Method1</code>. Однако если ничего не слу&shy;чится, то <code>Method3</code> завер&shy;шит свою работу, управ&shy;ле&shy;ние перейдёт в метод <code>Method2</code>, где также может воз&shy;ник&shy;нуть исклю&shy;че&shy;ние. Однако по естест&shy;вен&shy;ным при&shy;чи&shy;нам обра&shy;бо&shy;тано оно будет не в <code>Method3</code>, а в <code>Method1</code>. Воп&shy;рос такого удоб&shy;ного авто&shy;ма&shy;тизма зак&shy;лю&shy;ча&shy;ется в том, что струк&shy;туры дан&shy;ных, обра&shy;зу&shy;ю&shy;щие цепочки обра&shy;бот&shy;чи&shy;ков исклю&shy;че&shy;ний, также нахо&shy;дятся в сте&shy;ко&shy;вом кадре метода, где они объ&shy;яв&shy;лены. Про сами исклю&shy;че&shy;ния мы пого&shy;во&shy;рим отдельно, а здесь скажу только, что модель исклю&shy;че&shy;ний в .NET Frame&shy;work CLR и в Core CLR отли&shy;ча&shy;ется. Core&shy;CLR вынуж&shy;дена быть раз&shy;ной на раз&shy;ных плат&shy;фор&shy;мах, а потому модель исклю&shy;че&shy;ний там дру&shy;гая и предс&shy;тав&shy;ля&shy;ется в зави&shy;си&shy;мости от плат&shy;формы через прос&shy;лойку PAL (Plat&shy;form Adap&shy;tion Layer&shy;) раз&shy;лич&shy;ными импле&shy;мен&shy;та&shy;ци&shy;ями. Боль&shy;шому .NET Frame&shy;work CLR это не нужно: он живёт в эко&shy;сис&shy;теме плат&shy;формы Windows&shy;, в кото&shy;рой есть уже много лет обще&shy;из&shy;вест&shy;ный меха&shy;низм обра&shy;ботки исклю&shy;че&shy;ний, кото&shy;рый назы&shy;ва&shy;ется SEH (Struc&shy;tured Excep&shy;tion Handling&shy;). Этот меха&shy;низм исполь&shy;зу&shy;ется прак&shy;ти&shy;чески всеми язы&shy;ками прог&shy;рам&shy;ми&shy;ро&shy;ва&shy;ния (при конеч&shy;ной ком&shy;пи&shy;ля&shy;ции), потому что обес&shy;пе&shy;чи&shy;вает сквоз&shy;ную обра&shy;ботку исклю&shy;че&shy;ний между моду&shy;лями, напи&shy;сан&shy;ными на раз&shy;лич&shy;ных язы&shy;ках прог&shy;рам&shy;ми&shy;ро&shy;ва&shy;ния. Рабо&shy;тает это при&shy;мерно так:</p>
<div class="paragraph-right-side">06</div>
</div>
<ol>
<li>При вхож&shy;де&shy;нии в блок try на стек кладётся струк&shy;тура, кото&shy;рая пер&shy;вым полем ука&shy;зы&shy;вает на пре&shy;ды&shy;ду&shy;щий блок обра&shy;ботки исклю&shy;че&shy;ний (нап&shy;ри&shy;мер, вызы&shy;ва&shy;ю&shy;щий метод, у кото&shy;рого также есть try-catch), тип блока, код исклю&shy;че&shy;ния и адрес обра&shy;бот&shy;чика;</li>
<li>В TEB потока (Thread Envi&shy;ron&shy;ment Block&shy;, по сути  &mdash;  кон&shy;текст потока) меня&shy;ется адрес теку&shy;щей вер&shy;шины цепочки обра&shy;бот&shy;чи&shy;ков исклю&shy;че&shy;ний на тот, что мы соз&shy;дали. Таким обра&shy;зом, мы доба&shy;вили в цепочку наш блок.</li>
<li>Когда try закон&shy;чился, про&shy;из&shy;во&shy;дится обрат&shy;ная опе&shy;ра&shy;ция: в TEB запи&shy;сы&shy;ва&shy;ется ста&shy;рая вер&shy;шина, сни&shy;мая таким обра&shy;зом наш обра&shy;бот&shy;чик из цепочки;</li>
<li>Если воз&shy;ни&shy;кает исклю&shy;че&shy;ние, то из TEB заби&shy;ра&shy;ется вер&shy;шина и по оче&shy;реди по цепочке вызы&shy;ва&shy;ются обра&shy;бот&shy;чики, кото&shy;рые про&shy;ве&shy;ряют, под&shy;хо&shy;дит ли исклю&shy;че&shy;ние конк&shy;ретно им. Если да, выпол&shy;ня&shy;ется блок обра&shy;ботки (нап&shy;ри&shy;мер, catch).</li>
<li>В TEB восс&shy;та&shy;нав&shy;ли&shy;ва&shy;ется тот адрес струк&shy;туры SEH, кото&shy;рый нахо&shy;дится в стеке ДО метода, обра&shy;бо&shy;тав&shy;шего исклю&shy;че&shy;ние.</li>
</ol>
<p>Как видите, сов&shy;сем не сложно. Однако вся эта инфор&shy;ма&shy;ция также нахо&shy;дится в стеке.</p>
<h2 id="x64-amd64-in-progress">Базо&shy;вые све&shy;де&shy;ния про плат&shy;формы x64, AMD64 [In Progress&shy;]</h2>
<p>TODO</p>
<h2 id="x64-amd64-in-progress-1">Искл&shy;юч&shy;ения на плат&shy;фор&shy;мах x64, AMD64 [In Progress&shy;]</h2>
<p>TODO</p>
<h2 id="section-1">Сов&shy;сем нем&shy;ного про несо&shy;вер&shy;шенство стека потока</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">07</div>
<p>Давайте нем&shy;ного поду&shy;маем о воп&shy;росе безо&shy;пас&shy;ности и воз&shy;мож&shy;ных проб&shy;ле&shy;мах, кото&shy;рые чисто тео&shy;ре&shy;ти&shy;чески могут воз&shy;ник&shy;нуть. Для этого давайте ещё раз гля&shy;нем на струк&shy;туру стека потока, кото&shy;рая по своей сути  &mdash;  обыч&shy;ный мас&shy;сив. Диа&shy;па&shy;зон памяти, в кото&shy;ром стр&shy;оя&shy;тся фреймы, орга&shy;ни&shy;зо&shy;ван так, что он растёт с конца в начало. Т.е. более поз&shy;д&shy;ние фреймы рас&shy;по&shy;ла&shy;га&shy;ются по более ран&shy;ним адре&shy;сам. Так же, как уже было ска&shy;зано, фреймы свя&shy;заны однос&shy;вяз&shy;ным спис&shy;ком. Это сде&shy;лано потому, что раз&shy;мер фрейма не явля&shy;ется фик&shy;си&shy;ро&shy;ван&shy;ным и дол&shy;жен быть &laquo;счи&shy;тан&raquo; любым отлад&shy;чи&shy;ком. Про&shy;цес&shy;сор при этом не разг&shy;ра&shy;ни&shy;чи&shy;вает фреймы между собой: любой метод по сво&shy;ему жела&shy;нию может счи&shy;тать всю область памяти цели&shy;ком. А если учесть при этом, что мы нахо&shy;димся в вир&shy;ту&shy;альной памяти, кото&shy;рая поде&shy;лена на учас&shy;тки, явля&shy;ю&shy;щи&shy;еся реально выде&shy;лен&shy;ной памятью, то можно при помощи спе&shy;ци&shy;альной фун&shy;к&shy;ции Win&shy;API по любому адресу со стека полу&shy;чить диа&shy;па&shy;зон выде&shy;лен&shy;ной памяти, в кото&shy;рой этот адрес нахо&shy;дится. Ну а разоб&shy;рать однос&shy;вяз&shy;ный спи&shy;сок  &mdash;  дело тех&shy;ники:</p>
<div class="paragraph-right-side">07</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// переменная находится в стеке</span>
    <span style="color:Blue;">int</span> x;

    <span style="color:Green;">// Забрать информацию об участке памяти, выделенной под стек</span>
    MEMORY_BASIC_INFORMATION *stackData = <span style="color:Blue;">new</span> MEMORY_BASIC_INFORMATION();
    VirtualQuery((<span style="color:Blue;">void</span> *)&amp;x, stackData, <span style="color:Blue;">sizeof</span>(MEMORY_BASIC_INFORMATION));
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">08</div>
<p>Это даёт нам воз&shy;мож&shy;ность полу&shy;чить и моди&shy;фи&shy;ци&shy;ро&shy;вать все дан&shy;ные, кото&shy;рые нахо&shy;дятся в качес&shy;тве локаль&shy;ных пере&shy;мен&shy;ных у мето&shy;дов, кото&shy;рые нас выз&shy;вали. Если при&shy;ло&shy;же&shy;ние никак не нас&shy;тра&shy;и&shy;вает песоч&shy;ницу, в рам&shy;ках кото&shy;рой вызы&shy;ва&shy;ются сто&shy;рон&shy;ние биб&shy;ли&shy;о&shy;теки, рас&shy;ши&shy;ря&shy;ю&shy;щие фун&shy;кци&shy;о&shy;нал при&shy;ло&shy;же&shy;ния, то сто&shy;рон&shy;няя биб&shy;ли&shy;о&shy;тека смо&shy;жет ута&shy;щить дан&shy;ные, даже если тот API, кото&shy;рый вы ей отдаёте, этого не пред&shy;по&shy;ла&shy;гает. Мето&shy;дика эта может пока&shy;заться вам наду&shy;ман&shy;ной, однако в мире C/C++, где нет такой прек&shy;рас&shy;ной вещи как App&shy;Domain с нас&shy;тро&shy;ен&shy;ными пра&shy;вами атака по стеку  &mdash;  это самое типич&shy;ное, что только можно встр&shy;етить из взлома при&shy;ло&shy;же&shy;ний. Мало того, можно через реф&shy;лек&shy;сию пос&shy;мот&shy;реть на тип, кото&shy;рый нам необ&shy;хо&shy;дим, пов&shy;то&shy;рить его струк&shy;туру у себя, и, пройдя по ссылке со стека на объ&shy;ект, заме&shy;нить адрес VMT на наш, пере&shy;нап&shy;ра&shy;вив таким обра&shy;зом всю работу с конк&shy;рет&shy;ным экземп&shy;ля&shy;ром к нам. SEH, кстати говоря, также вовсю исполь&shy;зу&shy;ется для взлома при&shy;ло&shy;же&shy;ний. Через него вы также можете, меняя адрес обра&shy;бот&shy;чика исклю&shy;че&shy;ния, зас&shy;тав&shy;лять ОС выпол&shy;нить вре&shy;до&shy;нос&shy;ный код. Но вывод из всего этого очень прос&shy;той: всегда нас&shy;тра&shy;ивайте песоч&shy;ницу, когда хотите рабо&shy;тать с биб&shy;ли&shy;о&shy;те&shy;ками, рас&shy;ши&shy;ря&shy;ю&shy;щими фун&shy;кци&shy;о&shy;нал вашего при&shy;ло&shy;же&shy;ния. Я, конечно же, имею ввиду вся&shy;чес&shy;кие пла&shy;гины, аддоны и про&shy;чие рас&shy;ши&shy;ре&shy;ния.</p>
<div class="paragraph-right-side">08</div>
</div>
<h2 id="section-2">Боль&shy;шой при&shy;мер: кло&shy;ни&shy;ро&shy;ва&shy;ние потока на плат&shy;форме х86</h2>
<div class="paragraph-container">
<div class="paragraph-left-side">09</div>
<p>Чтобы запом&shy;нить все, что мы про&shy;чи&shy;тали до мель&shy;чай&shy;ших под&shy;роб&shy;нос&shy;тей, надо зайти к воп&shy;росу осве&shy;ще&shy;ния какой-либо темы с нес&shy;коль&shy;ких сто&shy;рон. Каза&shy;лось бы, какой при&shy;мер можно пос&shy;тро&shy;ить для стека потока? Выз&shy;вать метод из дру&shy;гого? Магия&hellip; Конечно же, нет: это мы делаем ежед&shy;невно по много раз. Вместо этого мы скло&shy;ни&shy;руем поток испол&shy;не&shy;ния. Т.е. сде&shy;лаем так, чтобы после вызова опре&shy;делённого метода у нас вместо одного потока ока&shy;за&shy;лось бы два: наш и новый, но про&shy;дол&shy;жа&shy;ю&shy;щий выпол&shy;нять код с точки вызова метода кло&shy;ни&shy;ро&shy;ва&shy;ния так, как будто он сам туда дошёл. А выг&shy;ля&shy;деть это будет так:</p>
<div class="paragraph-right-side">09</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> MakeFork()
{
    <span style="color:Green;">// Для уверенности что все склонировалось мы делаем локальные переменные:</span>
    <span style="color:Green;">// В новом потоке их значения обязаны быть такими же как и в родительском</span>
    <span style="color:Blue;">var</span> sameLocalVariable = 123;
    <span style="color:Blue;">var</span> sync = <span style="color:Blue;">new</span> <span style="color:Blue;">object</span>();

    <span style="color:Green;">// Замеряем время</span>
    <span style="color:Blue;">var</span> stopwatch = Stopwatch.StartNew();

    <span style="color:Green;">// Клонируем поток</span>
    <span style="color:Blue;">var</span> forked = Fork.CloneThread();

    <span style="color:Green;">// С этой точки код исполняется двумя потоками.</span>
    <span style="color:Green;">// forked = true для дочернего потока, false для родительского</span>
    <span style="color:Blue;">lock</span>(sync)
    {
        Console.WriteLine(<span style="color:#A31515;">&quot;in {0} thread: {1}, local value: {2}, time to enter = {3} ms&quot;</span>,
            forked ? <span style="color:#A31515;">&quot;forked&quot;</span> : <span style="color:#A31515;">&quot;parent&quot;</span>,
            Thread.CurrentThread.ManagedThreadId,
            sameLocalVariable,
            stopwatch.ElapsedMilliseconds);
    }

    <span style="color:Green;">// При выходе из метода родительский вернёт управления в метод,</span>
    <span style="color:Green;">// который вызвал MakeFork(), т.е. продолжит работу как ни в чем ни бывало,</span>
    <span style="color:Green;">// а дочерний завершит исполнение.</span>
}

<span style="color:Green;">// Примерный вывод:</span>
<span style="color:Green;">// in forked thread: 2, local value: 123, time to enter = 2 ms</span>
<span style="color:Green;">// in parent thread: 1, local value: 123, time to enter = 2 ms</span>
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">10</div>
<p>Сог&shy;ла&shy;си&shy;тесь, кон&shy;цепт инте&shy;рес&shy;ный. Конечно же, тут можно много спо&shy;рить про целе&shy;со&shy;об&shy;раз&shy;ность таких действий, но задача этого при&shy;мера  &mdash;  пос&shy;та&shy;вить жир&shy;ную точку в пони&shy;ма&shy;нии работы этой струк&shy;туры дан&shy;ных. Как же сде&shy;лать кло&shy;ни&shy;ро&shy;ва&shy;ние? Для ответа на дан&shy;ный воп&shy;рос надо отве&shy;тить на дру&shy;гой воп&shy;рос: что вообще опре&shy;де&shy;ляет поток? А поток опре&shy;де&shy;ляют сле&shy;ду&shy;ю&shy;щие струк&shy;туры и области дан&shy;ных:</p>
<div class="paragraph-right-side">10</div>
</div>
<ol>
<li>Набор регист&shy;ров про&shy;цес&shy;сора. Все регис&shy;тры опре&shy;де&shy;ляют сос&shy;то&shy;я&shy;ние потока испол&shy;не&shy;ния инстр&shy;укций: от адреса теку&shy;щей инстр&shy;укции испол&shy;не&shy;ния до адре&shy;сов стека потока и дан&shy;ных, кото&shy;рыми он опе&shy;ри&shy;рует;</li>
<li><a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">Thread Envi&shy;ron&shy;ment Block</a> или TIB/TEB, кото&shy;рый хра&shy;нит сис&shy;тем&shy;ную инфор&shy;ма&shy;цию по потоку, вклю&shy;чая адреса обра&shy;бот&shy;чи&shy;ков исклю&shy;че&shy;ний;</li>
<li>Стек потока, адрес кото&shy;рого опре&shy;де&shy;ля&shy;ется регист&shy;рами SS:ESP;</li>
<li>Плат&shy;фор&shy;мен&shy;ный кон&shy;текст потока, кото&shy;рый содер&shy;жит локаль&shy;ные для потока дан&shy;ные (ссылка идёт из TIB)</li>
</ol>
<div class="paragraph-container">
<div class="paragraph-left-side">11</div>
<p>Ну и навер&shy;няка что-то ещё, о чем мы можем не знать. Да и знать нам всего для при&shy;мера нет ника&shy;кой надоб&shy;ности: в про&shy;мыш&shy;лен&shy;ное исполь&shy;зо&shy;ва&shy;ние дан&shy;ный код не пойдёт, а ско&shy;рее будет слу&shy;жить нам отлич&shy;ным при&shy;ме&shy;ром, кото&shy;рый помо&shy;жет разоб&shy;раться в теме. А потому он не будет учи&shy;ты&shy;вать всего, а только самое основ&shy;ное. А для того чтобы он зара&shy;бо&shy;тал в базо&shy;вом виде, нам пона&shy;до&shy;бится ско&shy;пи&shy;ро&shy;вать в новый поток набор регист&shy;ров (испра&shy;вив SS:ESP, т.к. стек будет новым), а также под&shy;ре&shy;дак&shy;ти&shy;ро&shy;вать сам стек, чтобы он содер&shy;жал ровно то что нам надо.</p>
<div class="paragraph-right-side">11</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">12</div>
<p>Итак. Если стек потока опре&shy;де&shy;ляет, по сути, какие методы были выз&shy;ваны и какими дан&shy;ными они опе&shy;ри&shy;руют, то полу&shy;ча&shy;ется что по идее, меняя эти струк&shy;туры, можно поме&shy;нять как локаль&shy;ные пере&shy;мен&shy;ные мето&shy;дов, так и выре&shy;зать из стека вызов какого-то метода, поме&shy;нять метод на дру&shy;гой или же доба&shy;вить в любое место цепочки свой. Хорошо, с этим опре&shy;де&shy;ли&shy;лись. Теперь давайте пос&shy;мот&shy;рим на некий псев&shy;до&shy;код:</p>
<div class="paragraph-right-side">12</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> RootMethod()
{
    MakeFork();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">13</div>
<p>Когда вызо&shy;вется Make&shy;Fork&shy;(), что мы ожи&shy;даем с точки зре&shy;ния стек трей&shy;сов? Что в роди&shy;т&shy;ельском потоке все оста&shy;нется без изме&shy;не&shy;ний, а дочер&shy;ний будет взят из пула пото&shy;ков (для ско&shy;рости), в нем будет сыми&shy;ти&shy;ро&shy;ван вызов метода <code>Make&shy;Fork</code> вместе с его локаль&shy;ными пере&shy;мен&shy;ными, а код про&shy;дол&shy;жит выпол&shy;не&shy;ние не с начала метода, а с точки, сле&shy;ду&shy;ю&shy;щей после вызова <code>Clone&shy;Thread</code>. Т.е. стек трейс в наших фан&shy;та&shy;зиях будет выг&shy;ля&shy;деть при&shy;мерно так:</p>
<div class="paragraph-right-side">13</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Green;">// Parent Thread</span>
RootMethod -&gt; MakeFork

<span style="color:Green;">// Child Thread</span>
ThreadPool -&gt; MakeFork
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">14</div>
<p>Что у нас есть изна&shy;чально? Есть наш поток. Также есть воз&shy;мож&shy;ность соз&shy;дать новый поток либо зап&shy;ла&shy;ни&shy;ро&shy;вать задачу в пул пото&shy;ков, выпол&shy;нив там свой код. Также мы пони&shy;маем, что инфор&shy;ма&shy;ция по вло&shy;жен&shy;ным вызо&shy;вам хра&shy;нится в стеке вызо&shy;вов и что при жела&shy;нии мы можем ею мани&shy;пу&shy;ли&shy;ро&shy;вать (нап&shy;ри&shy;мер, исполь&shy;зуя C++/CLI). Причём, если сле&shy;до&shy;вать сог&shy;ла&shy;ше&shy;ниям и впи&shy;сать в вер&shy;хушку стека адрес возв&shy;рата для инстр&shy;укции ret, зна&shy;че&shy;ние регис&shy;тра EBP и выде&shy;лить место под локаль&shy;ные (если необ&shy;хо&shy;димо), то можно ими&shy;ти&shy;ро&shy;вать вызов метода. Руч&shy;ную запись в стек потока воз&shy;можно сде&shy;лать из C#, однако нам пона&shy;до&shy;бятся регис&shy;тры и их очень акку&shy;рат&shy;ное исполь&shy;зо&shy;ва&shy;ние, а потому без ухода в C++ нам не обой&shy;тись. Тут к нам на помощь впер&shy;вые в жизни (лично у меня) при&shy;хо&shy;дит CLI/C++, кото&shy;рый поз&shy;во&shy;ляет писать сме&shy;шан&shy;ный код: часть инстр&shy;укций  &mdash;  на .NET, часть  &mdash;  на C++, а иногда даже ухо&shy;дить на уро&shy;вень ассемб&shy;лера. Именно то, что нам надо.</p>
<div class="paragraph-right-side">14</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">15</div>
<p>Итак, как будет выг&shy;ля&shy;деть стек потока, когда наш код вызо&shy;вет Make&shy;Fork&shy;, кото&shy;рый вызо&shy;вет Clone&shy;Thread&shy;, кото&shy;рый уйдёт в unma&shy;naged мир CLI/C++ и вызо&shy;вет метод кло&shy;ни&shy;ро&shy;ва&shy;ние (саму реа&shy;ли&shy;за&shy;цию)  &mdash;  там? Давайте пос&shy;мот&shy;рим на схему (ещё раз напомню, что стек растёт от стар&shy;ших адре&shy;сов к млад&shy;шим. Справа налево):</p>
<div class="paragraph-right-side">15</div>
</div>
<p><img src="./imgs/ThreadStack/step1.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">16</div>
<p>Ну а для того чтобы не тащить всю прос&shy;тыню со схемы на схему, упрос&shy;тим, отбро&shy;сив то, что нам не нужно:</p>
<div class="paragraph-right-side">16</div>
</div>
<p><img src="./imgs/ThreadStack/step2.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">17</div>
<p>Когда мы соз&shy;да&shy;дим поток либо возьмём гото&shy;вый из пула пото&shy;ков, в нашей схеме появ&shy;ля&shy;ется ещё один стек, пока ещё ничем не про&shy;и&shy;ни&shy;ци&shy;а&shy;ли&shy;зи&shy;ро&shy;ван&shy;ный:</p>
<div class="paragraph-right-side">17</div>
</div>
<p><img src="./imgs/ThreadStack/step3.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">18</div>
<p>Теперь наша задача  &mdash;  сыми&shy;ти&shy;ро&shy;вать запуск метода <code>Fork&shy;.Clone&shy;Thread&shy;()</code> в новом потоке. Для этого мы дол&shy;жны в конец его стека потока допи&shy;сать серию кад&shy;ров: как будто из деле&shy;гата, пере&shy;дан&shy;ного Thread&shy;Pool&shy;'у был выз&shy;ван <code>Fork&shy;.Clone&shy;Thread&shy;()</code>, из кото&shy;рого через врап&shy;пер C++ кода managed обёрткой был выз&shy;ван CLI/C++ метод. Для этого мы просто ско&shy;пи&shy;руем необ&shy;хо&shy;ди&shy;мый учас&shy;ток стека в мас&shy;сив (замечу, что со скло&shy;ни&shy;ро&shy;ван&shy;ного учас&shy;тка на ста&shy;рый &laquo;смот&shy;рят&raquo; копии регист&shy;ров EBP, обес&shy;пе&shy;чи&shy;ва&shy;ю&shy;щих пос&shy;тро&shy;е&shy;ние цепочки кад&shy;ров):</p>
<div class="paragraph-right-side">18</div>
</div>
<p><img src="./imgs/ThreadStack/step4.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">19</div>
<p>Далее чтобы обес&shy;пе&shy;чить целост&shy;ность стека после опе&shy;ра&shy;ции копи&shy;ро&shy;ва&shy;ния скло&shy;ни&shy;ро&shy;ван&shy;ного на пре&shy;ды&shy;ду&shy;щем шаге учас&shy;тка, мы зара&shy;нее расс&shy;чи&shy;ты&shy;ваем, по каким адре&shy;сам будут нахо&shy;диться поля <code>EBP</code> на новом месте, и сразу же исправ&shy;ляем их, прямо на копии:</p>
<div class="paragraph-right-side">19</div>
</div>
<p><img src="./imgs/ThreadStack/step5.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">20</div>
<p>Пос&shy;лед&shy;ним шагом, очень акку&shy;ратно, зад&shy;ействуя мини&shy;маль&shy;ное коли&shy;чес&shy;тво регист&shy;ров, копи&shy;руем наш мас&shy;сив в конец стека дочер&shy;него потока, после чего сдви&shy;гаем регис&shy;тры ESP и EBP на новые места. С точки зре&shy;ния стека мы сыми&shy;ти&shy;ро&shy;вали вызов всех этих мето&shy;дов:</p>
<div class="paragraph-right-side">20</div>
</div>
<p><img src="./imgs/ThreadStack/step6.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">21</div>
<p>Но пока не с точки зре&shy;ния кода. С точки зре&shy;ния кода нам надо попасть в те методы, кото&shy;рые только что соз&shy;дали. Самое прос&shy;тое  &mdash;  просто сыми&shy;ти&shy;ро&shy;вать выход из метода: восс&shy;та&shy;но&shy;вить <code>ESP</code> до <code>EBP</code>, в <code>EBP</code> поло&shy;жить то, на что он ука&shy;зы&shy;вает и выз&shy;вать инстр&shy;укцию <code>ret</code>, ини&shy;ци&shy;и&shy;ро&shy;вав выход из якобы выз&shy;ван&shy;ного C++ метода кло&shy;ни&shy;ро&shy;ва&shy;ния потока, что при&shy;ведёт к возв&shy;рату в реальный wrapper CLI/C++ вызова, кото&shy;рый вернёт управ&shy;ле&shy;ние в <code>Make&shy;Fork&shy;()</code>, но в дочер&shy;нем потоке. Тех&shy;ника сра&shy;бо&shy;тала.</p>
<div class="paragraph-right-side">21</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">22</div>
<p>Теперь давайте взгл&shy;янем на код. Пер&shy;вое что мы сде&shy;лаем  &mdash;  это воз&shy;мож&shy;ность для CLI/C++ кода соз&shy;дать .NET поток. Для этого мы его дол&shy;жны соз&shy;дать в .NET:</p>
<div class="paragraph-right-side">22</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">extern</span> <span style="color:#A31515;">&quot;C&quot;</span> __declspec(dllexport)
<span style="color:Blue;">void</span> __stdcall MakeManagedThread(AdvancedThreading_Unmanaged *helper, StackInfo *stackCopy)
{
    AdvancedThreading::Fork::MakeThread(helper, stackCopy);
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">23</div>
<p>На типы пара&shy;мет&shy;ров пока не обра&shy;щайте вни&shy;ма&shy;ния. Они нужны для пере&shy;дачи инфор&shy;ма&shy;ции о том, какой учас&shy;ток стека необ&shy;хо&shy;димо у себя рисо&shy;вать из роди&shy;тел&shy;ьского потока в дочер&shy;ний. Метод соз&shy;да&shy;ния потока обо&shy;ра&shy;чи&shy;вает в деле&shy;гат вызов unma&shy;naged метода, передаёт дан&shy;ные и ста&shy;вит деле&shy;гат в оче&shy;редь на обра&shy;ботку пулом пото&shy;ков.</p>
<div class="paragraph-right-side">23</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">void</span> MakeThread(AdvancedThreading_Unmanaged *helper, StackInfo *stackCopy)
{
    ForkData^ data = gcnew ForkData();
    data-&gt;helper = helper;
    data-&gt;info = stackCopy;

    ThreadPool::QueueUserWorkItem(gcnew WaitCallback(&amp;InForkedThread), data);
}

[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">void</span> InForkedThread(Object^ state)
{
    ForkData^ data = (ForkData^)state;
    data-&gt;helper-&gt;InForkedThread(data-&gt;info);
}
</pre></div>
</div>
<p>И, нако&shy;нец, сам метод кло&shy;ни&shy;ро&shy;ва&shy;ния (вер&shy;нее, его .NET часть):</p>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
[MethodImpl(MethodImplOptions::NoInlining | MethodImplOptions::NoOptimization | MethodImplOptions::PreserveSig)]
<span style="color:Blue;">static</span> <span style="color:Blue;">bool</span> CloneThread()
{
    ManualResetEvent^ resetEvent = gcnew ManualResetEvent(<span style="color:Blue;">false</span>);
    AdvancedThreading_Unmanaged *helper = <span style="color:Blue;">new</span> AdvancedThreading_Unmanaged();
    <span style="color:Blue;">int</span> somevalue;

    <span style="color:Green;">// *</span>
    helper-&gt;stacktop = (<span style="color:Blue;">int</span>)(<span style="color:Blue;">int</span> *)&amp;somevalue;
    <span style="color:Blue;">int</span> forked = helper-&gt;ForkImpl();
    <span style="color:Blue;">if</span> (!forked)
    {
        resetEvent-&gt;WaitOne();
    }
    <span style="color:Blue;">else</span>
    {
        resetEvent-&gt;Set();
    }
    <span style="color:Blue;">return</span> forked;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">24</div>
<p>Чтобы пони&shy;мать, где в цепочке кад&shy;ров стека нахо&shy;дится дан&shy;ный метод, мы сох&shy;ра&shy;няем себе адрес сте&shy;ко&shy;вой пере&shy;мен&shy;ной (*). Испол&shy;ьз&shy;овать этот адрес мы будем в методе кло&shy;ни&shy;ро&shy;ва&shy;ния, речь о кото&shy;ром пойдёт чуть ниже. Также, чтобы вы пони&shy;мали, о чем идёт речь, при&shy;веду код струк&shy;туры, необ&shy;хо&shy;ди&shy;мой для хра&shy;не&shy;ния инфор&shy;ма&shy;ции о копии стека:</p>
<div class="paragraph-right-side">24</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">class</span> StackInfo
{
<span style="color:Blue;">public</span>:
    <span style="color:Green;">// Копия значений регистров</span>
    <span style="color:Blue;">int</span> EAX, EBX, ECX, EDX;
    <span style="color:Blue;">int</span> EDI, ESI;
    <span style="color:Blue;">int</span> ESP;
    <span style="color:Blue;">int</span> EBP;
    <span style="color:Blue;">int</span> EIP;
    <span style="color:Blue;">short</span> CS;

    <span style="color:Green;">// Адрес копии стека</span>
    <span style="color:Blue;">void</span> *frame;

    <span style="color:Green;">// Размер копии</span>
    <span style="color:Blue;">int</span> size;

    <span style="color:Green;">// Диапазоны адресов оригинального стека нужны,</span>
    <span style="color:Green;">// чтобы поправить адреса на стеке если они есть на новые</span>
    <span style="color:Blue;">int</span> origStackStart, origStackSize;
};
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">25</div>
<p>Работа же самого алго&shy;ритма раз&shy;де&shy;лена на две части: в роди&shy;т&shy;ельском потоке мы под&shy;го&shy;тав&shy;ли&shy;ваем дан&shy;ные для того, чтобы в дочер&shy;нем потоке отри&shy;со&shy;вать нуж&shy;ные кадры стека. Вто&shy;рым же эта&shy;пом восс&shy;та&shy;нав&shy;ли&shy;ва&shy;ются дан&shy;ные в дочер&shy;нем потоке, нак&shy;ла&shy;ды&shy;ва&shy;ясь на свой собст&shy;венный стек потока испол&shy;не&shy;ния, ими&shy;ти&shy;руя, таким обра&shy;зом, вызовы мето&shy;дов, кото&shy;рые в реаль&shy;ности выз&shy;ваны не были.</p>
<div class="paragraph-right-side">25</div>
</div>
<h3 id="section-3">Метод под&shy;го&shy;товки к копи&shy;ро&shy;ва&shy;нию</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">26</div>
<p>Опи&shy;са&shy;ние кода я буду делать бло&shy;ками. Т.е. еди&shy;ный код будет раз&shy;бит на части, и каж&shy;дая из час&shy;тей будет отдельно про&shy;ком&shy;мен&shy;ти&shy;ро&shy;вана. Итак, прис&shy;ту&shy;пим. Когда внеш&shy;ний код вызы&shy;вает <code>Fork&shy;.Clone&shy;Thread&shy;()</code>, то через внут&shy;рен&shy;нюю обёртку над неуп&shy;рав&shy;ля&shy;е&shy;мым кодом и через ряд допол&shy;ни&shy;тель&shy;ных мето&shy;дов, если код рабо&shy;тает под отлад&shy;кой (так назы&shy;ва&shy;е&shy;мые debugger assis&shy;tants). Именно поэ&shy;тому мы в .NET части запом&shy;нили адрес пере&shy;мен&shy;ной в стеке: для C++ метода этот адрес явля&shy;ется сво&shy;еоб&shy;разной мет&shy;кой: теперь мы точно знаем, какой учас&shy;ток стека мы можем спо&shy;койно копи&shy;ро&shy;вать.</p>
<div class="paragraph-right-side">26</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">int</span> AdvancedThreading_Unmanaged::ForkImpl()
{
    StackInfo copy;
    StackInfo* info;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">27</div>
<p>Пер&shy;вым делом, до того как про&shy;и&shy;зойдёт хоть какая-то опе&shy;ра&shy;ция, чтобы не полу&shy;чить запор&shy;чен&shy;ные регис&shy;тры, мы их копи&shy;руем локально. Также допол&shy;ни&shy;тельно необ&shy;хо&shy;димо сох&shy;ра&shy;нить адрес кода, куда будет сде&shy;лан <code>goto</code>, когда в дочер&shy;нем потоке стек будет сыми&shy;ти&shy;ро&shy;ван, и необ&shy;хо&shy;димо будет про&shy;из&shy;вести про&shy;це&shy;руду выхода из <code>Clone&shy;Thread</code> из дочер&shy;него потока. В качес&shy;тве &laquo;точки выхода&raquo; мы выби&shy;раем <code>Jmp&shy;Point&shy;On&shy;Methods&shy;Chain&shy;Call&shy;Emulation</code> и не просто так: после опе&shy;ра&shy;ции сох&shy;ра&shy;не&shy;ния этого адреса &laquo;на буду&shy;щее&raquo; мы допол&shy;ни&shy;тельно зак&shy;ла&shy;ды&shy;ваем в стек число 0.</p>
<div class="paragraph-right-side">27</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// Save ALL registers</span>
    _asm
    {
        mov copy.EAX, EAX
        mov copy.EBX, EBX
        mov copy.ECX, ECX
        mov copy.EDX, EBX
        mov copy.EDI, EDI
        mov copy.ESI, ESI
        mov copy.EBP, EBP
        mov copy.ESP, ESP

        <span style="color:Green;">// Save CS:EIP for far jmp</span>
        mov copy.CS, CS
        mov copy.EIP, offset JmpPointOnMethodsChainCallEmulation

        <span style="color:Green;">// Save mark for this method, from what place it was called</span>
        push 0
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">28</div>
<p>После чего, после <code>Jmp&shy;Point&shy;On&shy;Methods&shy;Chain&shy;Call&shy;Emulation</code> мы достаём это число из стека и про&shy;ве&shy;ряем: там лежит <code>0</code>? Если да, мы нахо&shy;димся в том же самом потоке: а зна&shy;чит у нас ещё много дел, и мы пере&shy;хо&shy;дим на <code>Non&shy;Clonned</code>. Если же там не <code>0</code>, а по факту <code>1</code>, это зна&shy;чит, что дочер&shy;ний поток закон&shy;чил &laquo;дори&shy;совку&raquo; стека потока до необ&shy;хо&shy;ди&shy;мого сос&shy;то&shy;я&shy;ния, поло&shy;жил на стек число <code>1</code> и сде&shy;лал goto в эту точку (замечу, что goto он делает из дру&shy;гого метода). А это зна&shy;чит, что нас&shy;тало время для выхода из <code>Clone&shy;Thread</code> в дочер&shy;нем потоке, вызов кото&shy;рого был сыми&shy;ти&shy;ро&shy;ван.</p>
<div class="paragraph-right-side">28</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
JmpPointOnMethodsChainCallEmulation:

    _asm
    {
        pop EAX
        cmp EAX, 0
        je NonClonned

        pop EBP
        mov EAX, 1
        ret
    }
NonClonned:
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">29</div>
<p>Хорошо, мы убе&shy;ди&shy;лись, что мы все ещё мы, а зна&shy;чит надо под&shy;го&shy;то&shy;вить дан&shy;ные для дочер&shy;него потока. Чтобы более не спус&shy;каться на уро&shy;вень ассемб&shy;лера, рабо&shy;тать мы будем со струк&shy;ту&shy;рой ранее сох&shy;ранённых регист&shy;ров. Дос&shy;та&shy;нем из неё зна&shy;че&shy;ние регис&shy;тра EBP: он по сути явля&shy;ется полем &laquo;Next&raquo; в однос&shy;вяз&shy;ном списке кар&shy;дов стека. Перейдя по адресу, кото&shy;рый там содер&shy;жится, мы очу&shy;тимся в кадре метода, кото&shy;рый нас выз&shy;вал. Если и там возьмём пер&shy;вое поле и перейдём по тому адресу, то ока&shy;жемся в ещё более ран&shy;нем кадре. Так мы смо&shy;жем дойти до managed части <code>Clone&shy;Thread</code>: ведь мы сох&shy;ра&shy;нили адрес пере&shy;мен&shy;ной в её сте&shy;ко&shy;вом кадре, а зна&shy;чит, прек&shy;расно знаем, где оста&shy;но&shy;виться. Этой зада&shy;чей и зани&shy;ма&shy;ется цикл, при&shy;ведённый ниже.</p>
<div class="paragraph-right-side">29</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">int</span> *curptr = (<span style="color:Blue;">int</span> *)copy.EBP;
    <span style="color:Blue;">int</span> frames = 0;

    <span style="color:Green;">//</span>
    <span style="color:Green;">//  Calculate frames count between current call and Fork.CloneTherad() call</span>
    <span style="color:Green;">//</span>
    <span style="color:Blue;">while</span> ((<span style="color:Blue;">int</span>)curptr &lt; stacktop)
    {
        curptr = (<span style="color:Blue;">int</span>*)*curptr;
        frames++;
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">30</div>
<p>Полу&shy;чив адрес начала кадра managed метода <code>Clone&shy;Thread</code>, мы теперь знаем, сколько надо копи&shy;ро&shy;вать для ими&shy;та&shy;ции вызова <code>Clone&shy;Thread</code> из <code>Make&shy;Fork</code>. Однако пос&shy;кольку нам <code>Make&shy;Fork</code> также нужен (наша задача выйти именно в него), то мы делаем допол&shy;ни&shy;тельно ещё один пере&shy;ход по однос&shy;вяз&shy;ному списку: <code>*(int *)curptr</code>. После чего создаём мас&shy;сив под сох&shy;ра&shy;не&shy;ние стека и сох&shy;ра&shy;няем его прос&shy;тым копи&shy;ро&shy;ва&shy;нием.</p>
<div class="paragraph-right-side">30</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">//</span>
    <span style="color:Green;">//  We need to copy stack part from our method to user code method including its locals in stack</span>
    <span style="color:Green;">//</span>
    <span style="color:Blue;">int</span> localsStart = copy.EBP;                             <span style="color:Green;">// our EBP points to EBP value for parent method + saved ESI, EDI</span>
    <span style="color:Blue;">int</span> localsEnd = *(<span style="color:Blue;">int</span> *)curptr;                         <span style="color:Green;">// points to end of user&#39;s method&#39;s locals (additional leave)</span>

    <span style="color:Blue;">byte</span> *arr = <span style="color:Blue;">new</span> <span style="color:Blue;">byte</span>[localsEnd - localsStart];
    memcpy(arr, (<span style="color:Blue;">void</span>*)localsStart, localsEnd - localsStart);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">31</div>
<p>Ещё одна задача, кото&shy;рую надо будет решить,  &mdash;  это исправ&shy;ле&shy;ние адре&shy;сов пере&shy;мен&shy;ных, кото&shy;рые попали на стек и при этом ука&shy;зы&shy;ва&shy;ю&shy;щих на стек. Для реше&shy;ния этой проб&shy;лемы мы полу&shy;чаем диа&shy;па&shy;зон адре&shy;сов, кото&shy;рые нам выде&shy;лила опе&shy;ра&shy;ци&shy;он&shy;ная сис&shy;тема под стек потока. Сох&shy;ра&shy;няем полу&shy;чен&shy;ную инфор&shy;ма&shy;цию и запу&shy;каем вто&shy;рую часть про&shy;цесса кло&shy;ни&shy;ро&shy;ва&shy;ния, зап&shy;ла&shy;ни&shy;ро&shy;вав деле&shy;гат в пул пото&shy;ков:</p>
<div class="paragraph-right-side">31</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// Get information about stack pages</span>
    MEMORY_BASIC_INFORMATION *stackData = <span style="color:Blue;">new</span> MEMORY_BASIC_INFORMATION();
    VirtualQuery((<span style="color:Blue;">void</span> *)copy.EBP, stackData, <span style="color:Blue;">sizeof</span>(MEMORY_BASIC_INFORMATION));

    <span style="color:Green;">// fill StackInfo structure</span>
    info = <span style="color:Blue;">new</span> StackInfo(copy);
    info-&gt;origStackStart = (<span style="color:Blue;">int</span>)stackData-&gt;BaseAddress;
    info-&gt;origStackSize = (<span style="color:Blue;">int</span>)stackData-&gt;RegionSize;
    info-&gt;frame = arr;
    info-&gt;size = (localsEnd - localsStart);

    <span style="color:Green;">// call managed ThreadPool.QueueUserWorkitem to make fork</span>
    MakeManagedThread(<span style="color:Blue;">this</span>, info);

    <span style="color:Blue;">return</span> 0;
}
</pre></div>
</div>
<h3 id="section-4">Метод восс&shy;та&shy;нов&shy;ле&shy;ния из копии</h3>
<div class="paragraph-container">
<div class="paragraph-left-side">32</div>
<p>Этот метод вызы&shy;ва&shy;ется как резуль&shy;тат работы пре&shy;ды&shy;ду&shy;щего: нам пере&shy;даны копия учас&shy;тка стека роди&shy;тел&shy;ьского потока, а также пол&shy;ный набор его регист&shy;ров. Наша задача в нашем потоке, взя&shy;том из пула пото&shy;ков, дори&shy;со&shy;вать все вызовы, ско&shy;пи&shy;ро&shy;ван&shy;ные из роди&shy;тел&shy;ьского потока таким обра&shy;зом, как будто мы сами их осу&shy;щест&shy;вили. Завер&shy;шив работу, Make&shy;Fork дочер&shy;него потока попадёт обратно в этот метод, кото&shy;рый, завер&shy;шив работу, осво&shy;бо&shy;дит поток и вернёт его в пул пото&shy;ков.</p>
<div class="paragraph-right-side">32</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> AdvancedThreading_Unmanaged::InForkedThread(StackInfo * stackCopy)
{
    StackInfo copy;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">33</div>
<p>Пер&shy;вым делом мы сох&shy;ра&shy;няем зна&shy;че&shy;ния рабо&shy;чих регист&shy;ров, чтобы, когда <code>Make&shy;Fork</code> завер&shy;шит свою работу, мы смогли их без&shy;бо&shy;лез&shy;ненно восс&shy;тав&shy;но&shy;вить. Чтобы в даль&shy;ней&shy;шем мини&shy;мально вли&shy;ять на регис&shy;тры, мы выг&shy;ру&shy;жаем пере&shy;дан&shy;ные нам пара&shy;метры к себе на стек. Дос&shy;туп к ним будет идти только через <code>SS:ESP</code>, что для нас будет предс&shy;ка&shy;зу&shy;е&shy;мым.</p>
<div class="paragraph-right-side">33</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Blue;">short</span> CS_EIP[3];

    <span style="color:Green;">// Save original registers to restore</span>
    __asm pushad

    <span style="color:Green;">// safe copy w-out changing registers</span>
    <span style="color:Blue;">for</span>(<span style="color:Blue;">int</span> i = 0; i &lt; <span style="color:Blue;">sizeof</span>(StackInfo); i++)
        ((<span style="color:Blue;">byte</span> *)&amp;copy)[i] = ((<span style="color:Blue;">byte</span> *)stackCopy)[i];

    <span style="color:Green;">// Setup FWORD for far jmp</span>
    *(<span style="color:Blue;">int</span>*)CS_EIP = copy.EIP;
    CS_EIP[2] = copy.CS;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">34</div>
<p>Наша сле&shy;ду&shy;ю&shy;щая задача - это испра&shy;вить в копии стека зна&shy;че&shy;ния <code>EBP</code>, кото&shy;рые обра&shy;зуют однос&shy;вяз&shy;ный спи&shy;сок кад&shy;ров на их буду&shy;щие новые поло&shy;же&shy;ния. Для этого мы расс&shy;чи&shy;ты&shy;ваем дельту между адре&shy;сом нашего стека потока и роди&shy;тел&shy;ьского стека потока, дельту между копией диа&shy;па&shy;зона стека роди&shy;тел&shy;ьского потока и самим роди&shy;т&shy;ельским пото&shy;ком.</p>
<div class="paragraph-right-side">34</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// calculate ranges</span>
    <span style="color:Blue;">int</span> beg = (<span style="color:Blue;">int</span>)copy.frame;
    <span style="color:Blue;">int</span> size = copy.size;
    <span style="color:Blue;">int</span> baseFrom = (<span style="color:Blue;">int</span>) copy.origStackStart;
    <span style="color:Blue;">int</span> baseTo = baseFrom + (<span style="color:Blue;">int</span>)copy.origStackSize;
    <span style="color:Blue;">int</span> ESPr;

    __asm mov ESPr, ESP

    <span style="color:Green;">// target = EBP[ - locals - EBP - ret - whole stack frames copy]</span>
    <span style="color:Blue;">int</span> targetToCopy = ESPr - 8 - size;

    <span style="color:Green;">// offset between parent stack and current stack;</span>
    <span style="color:Blue;">int</span> delta_to_target = (<span style="color:Blue;">int</span>)targetToCopy - (<span style="color:Blue;">int</span>)copy.EBP;

    <span style="color:Green;">// offset between parent stack start and its copy;</span>
    <span style="color:Blue;">int</span> delta_to_copy = (<span style="color:Blue;">int</span>)copy.frame - (<span style="color:Blue;">int</span>)copy.EBP;
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">35</div>
<p>Испол&shy;ьзуя эти дан&shy;ные, мы в цикле идём по копии стека и исправ&shy;ляем адреса на их буду&shy;щие новые поло&shy;же&shy;ния.</p>
<div class="paragraph-right-side">35</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// In stack copy we have many saved EPBs, which where actually one-way linked list.</span>
    <span style="color:Green;">// we need to fix copy to make these pointers correct for our thread&#39;s stack.</span>
    <span style="color:Blue;">int</span> ebp_cur = beg;
    <span style="color:Blue;">while</span>(<span style="color:Blue;">true</span>)
    {
        <span style="color:Blue;">int</span> val = *(<span style="color:Blue;">int</span>*)ebp_cur;

        <span style="color:Blue;">if</span>(baseFrom &lt;= val &amp;&amp; val &lt; baseTo)
        {
            <span style="color:Blue;">int</span> localOffset = val + delta_to_copy;
            *(<span style="color:Blue;">int</span> *)ebp_cur += delta_to_target;
            ebp_cur = localOffset;
        }
        <span style="color:Blue;">else</span>
            <span style="color:Blue;">break</span>;
    }
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">36</div>
<p>Когда правка однос&shy;вяз&shy;ного списка завер&shy;шена, мы дол&shy;жны испра&shy;вить зна&shy;че&shy;ния регист&shy;ров в их копии, чтобы, если там при&shy;сут&shy;ствуют ссылки на стек, они были бы исправ&shy;лены. Тут на самом деле алго&shy;ритм сов&shy;сем не точен. Ведь если там по неко&shy;то&shy;рой слу&shy;чай&shy;ности ока&shy;жется не удач&shy;ное число из диа&shy;па&shy;зона адре&shy;сов стека, то оно будет исправ&shy;лено по ошибке. Но наша задача не для про&shy;дукта кон&shy;цепт напи&shy;сать, а просто понять работу стека потока. Потому для этих целей нам дан&shy;ная мето&shy;дика подойдёт.</p>
<div class="paragraph-right-side">36</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    CHECKREF(EAX);
    CHECKREF(EBX);
    CHECKREF(ECX);
    CHECKREF(EDX);

    CHECKREF(ESI);
    CHECKREF(EDI);
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">37</div>
<p>Теперь, основ&shy;ная и самая ответст&shy;венная часть. Когда мы ско&shy;пи&shy;руем в конец нашего стека копию диа&shy;па&shy;зона роди&shy;тел&shy;ьского, все будет хорошо до момента, когда <code>Make&shy;Fork</code> в дочер&shy;нем потоке захо&shy;чет выйти (сде&shy;лать <code>return</code>). Нам надо ука&shy;зать ему, куда он дол&shy;жен выйти. Для этого мы также ими&shy;ти&shy;руем вызов самого &lsquo;Make&shy;Fork&rsquo; из этого метода. Мы зак&shy;ла&shy;ды&shy;ваем в стек адрес метки <code>Restore&shy;Point&shy;After&shy;Clonned&shy;Exited</code>, как будто инстр&shy;укция про&shy;цес&shy;сора <code>call</code> зало&shy;жила в стек адрес возв&shy;рата, а также поло&shy;жили теку&shy;щий <code>EBP</code>, сыми&shy;ти&shy;ро&shy;вав пос&shy;тро&shy;е&shy;ние однос&shy;вяз&shy;ного списка цепо&shy;чек кад&shy;ров мето&shy;дов. После чего зак&shy;ла&shy;ды&shy;ваем в стек обыч&shy;ной опе&shy;ра&shy;цией <code>push</code> копию роди&shy;тел&shy;ьского стека тем самым отри&shy;со&shy;вав все методы, кото&shy;рые были выз&shy;ваны в роди&shy;т&shy;ельском стеке из метода <code>Make&shy;Fork</code>, вклю&shy;чая его самого. Стек готов!</p>
<div class="paragraph-right-side">37</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
    <span style="color:Green;">// prepare for __asm nret</span>
    __asm push offset RestorePointAfterClonnedExited
    __asm push EBP

    <span style="color:Blue;">for</span>(<span style="color:Blue;">int</span> i = (size &gt;&gt; 2) - 1; i &gt;= 0; i--)
    {
        <span style="color:Blue;">int</span> val = ((<span style="color:Blue;">int</span> *)beg)[i];
        __asm push val;
    };
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">38</div>
<p>Далее пос&shy;кольку мы также дол&shy;жны восс&shy;та&shy;но&shy;вить и регис&shy;тры, восс&shy;та&shy;нав&shy;ли&shy;ваем и их самих.</p>
<div class="paragraph-right-side">38</div>
</div>
<pre><code>    // restore registers, push 1 for Fork() and jmp
    _asm {
        push copy.EAX
        push copy.EBX
        push copy.ECX
        push copy.EDX
        push copy.ESI
        push copy.EDI
        pop EDI
        pop ESI
        pop EDX
        pop ECX
        pop EBX
        pop EAX
</code></pre>
<div class="paragraph-container">
<div class="paragraph-left-side">39</div>
<p>А вот теперь самое время вспом&shy;нить тот стран&shy;ный код с зак&shy;ла&shy;ды&shy;ва&shy;нием <code>0</code> в стек и про&shy;верки на <code>0</code>. В этом потоке мы зак&shy;ла&shy;ды&shy;ваем <code>1</code> и делаем даль&shy;ний jmp в код метода <code>Fork&shy;Impl</code>. Ведь по стеку мы нахо&shy;димся именно там, а реально все ещё тут. Когда мы туда попадём, то <code>Fork&shy;Impl</code> рас&shy;поз&shy;нает смену потока и осу&shy;щест&shy;вит выход в метод <code>Make&shy;Fork</code>, кото&shy;рый, завер&shy;шив работу, попадёт в точку <code>Restore&shy;Point&shy;After&shy;Clonned&shy;Exited</code>, т.к. нем&shy;ного ранее мы сым&shy;ти&shy;ро&shy;вали вызов <code>Make&shy;Fork</code> из этой точки. Восс&shy;та&shy;но&shy;вив регис&shy;тры до сос&shy;то&shy;я&shy;ния &laquo;только что выз&shy;ваны из Thead&shy;Pool&raquo;, мы завер&shy;шаем работу, отда&shy;вая поток в пул пото&shy;ков.</p>
<div class="paragraph-right-side">39</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
        push 1
        jmp fword ptr CS_EIP
    }

RestorePointAfterClonnedExited:

    <span style="color:Green;">// Restore original registers</span>
    __asm popad
    <span style="color:Blue;">return</span>;
 }
</pre></div>
</div>
<p>Про&shy;ве&shy;рим? Это  &mdash;  скрин&shy;шот до вызова кло&shy;ни&shy;ро&shy;ва&shy;ния потока:</p>
<p><img src="./imgs/ThreadStack/ForkBeforeEnter.png" alt="" /></p>
<p>И после:</p>
<p><img src="./imgs/ThreadStack/ForkAfterEnter.png" alt="" /></p>
<div class="paragraph-container">
<div class="paragraph-left-side">40</div>
<p>Как мы видим, теперь вместо одного потока внутри Fork&shy;Impl мы видим два. И оба  &mdash;  вышли из этого метода.</p>
<div class="paragraph-right-side">40</div>
</div>
<h1 id="section-5">Пара слов об уровне пониже</h1>
<div class="paragraph-container">
<div class="paragraph-left-side">41</div>
<p>Если мы заг&shy;ля&shy;нем краем глаза на ещё более низ&shy;кий уро&shy;вень, то узнаем или же вспом&shy;ним, что память на самом деле явля&shy;ется вир&shy;ту&shy;альной и что она поде&shy;лена на стра&shy;ницы объёмом 8 или 4 Кб. Каж&shy;дая такая стра&shy;ница может физи&shy;чески сущест&shy;во&shy;вать или же нет. А если она сущес&shy;твует, то может быть отоб&shy;ра&shy;жена на файл или же реальную опе&shy;ра&shy;тив&shy;ную память. Именно этот меха&shy;низм вир&shy;ту&shy;а&shy;ли&shy;за&shy;ции поз&shy;во&shy;ляет при&shy;ло&shy;же&shy;ниям иметь раз&shy;дель&shy;ную друг от друга память и обес&shy;пе&shy;чи&shy;вает уровни безо&shy;пас&shy;ности между при&shy;ло&shy;же&shy;нием и опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;те&shy;мой. При чем же здесь стек потока? Как и любая дру&shy;гая опе&shy;ра&shy;тив&shy;ная память при&shy;ло&shy;же&shy;ния стек потока явля&shy;ется её частью и также сос&shy;тоит из стра&shy;ниц объёмом 4 или 8 Кб. По краям от выде&shy;лен&shy;ного для стека прост&shy;ранства нахо&shy;дятся две стра&shy;ницы, дос&shy;туп к кото&shy;рым при&shy;во&shy;дит к сис&shy;тем&shy;ному исклю&shy;че&shy;нию, ноти&shy;фи&shy;ци&shy;ру&shy;ю&shy;щему опе&shy;ра&shy;ци&shy;он&shy;ную сис&shy;тему о том, что при&shy;ло&shy;же&shy;ние пыта&shy;ется обра&shy;титься в невы&shy;де&shy;лен&shy;ный учас&shy;ток памяти. Внутри этого реги&shy;она реально выде&shy;лен&shy;ными участ&shy;ками явля&shy;ются только те стра&shy;ницы, к кото&shy;рым обра&shy;ти&shy;лось при&shy;ло&shy;же&shy;ние: т.е. если при&shy;ло&shy;же&shy;ние резер&shy;ви&shy;рует под поток 2Мб памяти, это не зна&shy;чит, что они будут выде&shy;лены сразу же. Отнюдь, они будут выде&shy;лены по тре&shy;бо&shy;ва&shy;нию: если стек потока вырас&shy;тет до 1 Мб, это будет озна&shy;чать, что при&shy;ло&shy;же&shy;ние полу&shy;чило именно 1 Мб опе&shy;ра&shy;тив&shy;ной памяти под стек.</p>
<div class="paragraph-right-side">41</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">42</div>
<p>Когда при&shy;ло&shy;же&shy;ние резер&shy;ви&shy;рует память под локаль&shy;ные пере&shy;мен&shy;ные, то про&shy;ис&shy;хо&shy;дят две вещи: нара&shy;щи&shy;ва&shy;ется зна&shy;че&shy;ние регис&shy;тра ESP и зану&shy;ля&shy;ется память под сами пере&shy;мен&shy;ные. Поэ&shy;тому, когда вы напи&shy;шете рекур&shy;сив&shy;ный метод, кото&shy;рый ухо&shy;дит в бес&shy;ко&shy;неч&shy;ную рекур&shy;сию, вы полу&shy;чите Stack&shy;Overflow&shy;Exception&shy;: заняв всю выде&shy;лен&shy;ную под стек память (весь дос&shy;туп&shy;ный регион), вы напо&shy;ри&shy;тесь на спе&shy;ци&shy;альную стра&shy;ницу, Guard Page&shy;, дос&shy;туп к кото&shy;рой вызо&shy;вет ноти&shy;фи&shy;ка&shy;цию опе&shy;ра&shy;ци&shy;он&shy;ной сис&shy;темы, кото&shy;рая ини&shy;ци&shy;и&shy;рует Stack&shy;Overflow уровня ОС, кото&shy;рое уйдёт в .NET, будет перех&shy;ва&shy;чено и выб&shy;ро&shy;сется исклю&shy;че&shy;ние Stack&shy;Overflow&shy;Exception для .NET при&shy;ло&shy;же&shy;ния.</p>
<div class="paragraph-right-side">42</div>
</div>
<h1 id="stackalloc">Выде&shy;ле&shy;ние памяти на стеке: stac&shy;kalloc</h1>
<div class="paragraph-container">
<div class="paragraph-left-side">43</div>
<p>В C# сущес&shy;твует дос&shy;та&shy;точно инте&shy;рес&shy;ное и очень редко исполь&shy;зу&shy;е&shy;мое клю&shy;че&shy;вое слово <code>stac&shy;kalloc</code>. Оно нас&shy;только редко встр&shy;еч&shy;ае&shy;тся в коде (тут я даже со сло&shy;вом &laquo;нем&shy;ного&raquo; пре&shy;у&shy;мень&shy;шил. Ско&shy;рее, &laquo;никогда&raquo;), что найти под&shy;хо&shy;дя&shy;щий при&shy;мер его исполь&shy;зо&shy;ва&shy;ния дос&shy;та&shy;точно трудно, а уж при&shy;ду&shy;мать тем более трудно: ведь если что-то редко исполь&shy;зу&shy;ется, то и опыт работы с ним слиш&shy;ком мал. А все почему? Потому что для тех, кто нако&shy;нец реша&shy;ется выяс&shy;нить, что делает эта команда, <code>stac&shy;kalloc</code> ста&shy;но&shy;вится более пуга&shy;ю&shy;щим чем полез&shy;ным: тёмная сто&shy;рона <code>stac&shy;kalloc</code>  &mdash;  unsafe код. Тот резуль&shy;тат, что он возв&shy;ра&shy;щает не явля&shy;ется managed ука&shy;за&shy;те&shy;лем: зна&shy;че&shy;ние  &mdash;  обыч&shy;ный ука&shy;за&shy;тель на учас&shy;ток не защищённой памяти. Причём если по этому адресу сде&shy;лать запись уже после того, как метод завер&shy;шил работу, вы начнёте писать в локаль&shy;ные пере&shy;мен&shy;ные неко&shy;то&shy;рого метода или же вообще перетрёте адрес возв&shy;рата из метода, после чего при&shy;ло&shy;же&shy;ние закон&shy;чит работу с ошиб&shy;кой. Однако наша задача  &mdash;  про&shy;ник&shy;нуть в самые уголки и разоб&shy;раться, что в них скрыто. И понять, в част&shy;ности, что если нам дали этот инст&shy;румент, то не просто же так, чтобы мы смогли найти сек&shy;рет&shy;ные грабли и нас&shy;ту&shy;пить на них со всего маху. Нао&shy;бо&shy;рот: нам дали этот инст&shy;румент чтобы мы смогли им вос&shy;поль&shy;зо&shy;ваться и делать поис&shy;тине быст&shy;рый софт. Я, наде&shy;юсь, вдох&shy;но&shy;вил вас? Тогда начнём.</p>
<div class="paragraph-right-side">43</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">44</div>
<p>Чтобы найти пра&shy;виль&shy;ные при&shy;меры исполь&shy;зо&shy;ва&shy;ния этого клю&shy;че&shy;вого слова надо прос&shy;ле&shy;до&shy;вать прежде всего к его авто&shy;рам: ком&shy;па&shy;нии Micro&shy;soft и пос&shy;мот&shy;реть как его исполь&shy;зуют они. Сде&shy;лать это можно поис&shy;кав пол&shy;но&shy;текс&shy;то&shy;вым поис&shy;ком по репо&shy;зи&shy;то&shy;рию <a href="https://github.com/dotnet/coreclr">coreclr</a>. Помимо раз&shy;лич&shy;ных тес&shy;тов самого клю&shy;че&shy;вого слова мы найдём не более 25 исполь&shy;зо&shy;ва&shy;ний этого клю&shy;че&shy;вого слова по коду биб&shy;ли&shy;о&shy;теки. Я наде&shy;юсь, что в пре&shy;ды&shy;ду&shy;щем абзаце я дос&shy;та&shy;точно сильно вас моти&shy;ви&shy;ро&shy;вал, чтобы вы не оста&shy;но&shy;вили чте&shy;ние, уви&shy;дев эту малень&shy;кую цифру, и не зак&shy;рыли мой труд. Скажу чес&shy;тно: команда CLR куда более даль&shy;но&shy;вид&shy;ная и про&shy;фес&shy;си&shy;о&shy;наль&shy;ная чем команда .NET Framework&shy;. И если она что-то сде&shy;лала, то это нам сильно в чем-то дол&shy;жно помочь. А если это не исполь&shy;зо&shy;вано в .NET Frame&shy;work&hellip; Ну, тут можно пред&shy;по&shy;ло&shy;жить, что там не все инже&shy;неры в курсе, что есть такой мощ&shy;ный инст&shy;румент опти&shy;ми&shy;за&shy;ции. Иначе бы объёмы его исполь&shy;зо&shy;ва&shy;ния были бы гораздо больше.</p>
<div class="paragraph-right-side">44</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">45</div>
<p><strong>Класс Interop&shy;.Read&shy;Dir</strong>
<a href="https://github.com/dotnet/coreclr/blob/b29f6328510207970763580d6f4db864e4b198af/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs#L71-L83">/src/mscorlib/shared/Interop&shy;/Unix&shy;/System&shy;.Native&shy;/Interop&shy;.Read&shy;Dir&shy;.cs</a></p>
<div class="paragraph-right-side">45</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">unsafe</span>
{
    <span style="color:Green;">// s_readBufferSize is zero when the native implementation does not support reading into a buffer.</span>
    <span style="color:Blue;">byte</span>* buffer = <span style="color:Blue;">stackalloc</span> <span style="color:Blue;">byte</span>[s_readBufferSize];
    InternalDirectoryEntry temp;
    <span style="color:Blue;">int</span> ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, <span style="color:Blue;">out</span> temp);
    <span style="color:Green;">// We copy data into DirectoryEntry to ensure there are no dangling references.</span>
    outputEntry = ret == 0 ?
                <span style="color:Blue;">new</span> DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } :
                <span style="color:Blue;">default</span>(DirectoryEntry);

    <span style="color:Blue;">return</span> ret;
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">46</div>
<p>Для чего здесь исполь&shy;зу&shy;ется <code>stac&shy;kalloc</code>? Как мы видим, после выде&shy;ле&shy;ния памяти код ухо&shy;дит в unsafe метод для запол&shy;не&shy;ния соз&shy;дан&shy;ного буфера дан&shy;ными. Т.е. unsafe метод, кото&shy;рому необ&shy;хо&shy;дим учас&shy;ток для записи, выде&shy;ля&shy;ется место прямо на стеке: дина&shy;ми&shy;чески. Это отлич&shy;ная опти&shy;ми&shy;за&shy;ция, если учесть, что аль&shy;те&shy;рн&shy;ативы: зап&shy;ро&shy;сить учас&shy;ток памяти у Windows или fixed (pinned) мас&shy;сив .NET, кото&shy;рый помимо наг&shy;рузки на кучу наг&shy;ру&shy;жает GC тем, что мас&shy;сив при&shy;би&shy;ва&shy;ется гвоз&shy;дями, чтобы GC его не подод&shy;ви&shy;нул во время дос&shy;тупа к его дан&shy;ным. Выде&shy;ляя память на стеке, мы не рис&shy;куем ничем: выде&shy;ле&shy;ние про&shy;ис&shy;хо&shy;дит почти момен&shy;тально, и мы можем совер&shy;шенно спо&shy;койно запол&shy;нить его дан&shy;ными и выйти из метода. А вместе с выхо&shy;дом из метода исчез&shy;нет и stack frame метода. В общем, эко&shy;но&shy;мия вре&shy;мени зна&shy;чи&shy;тель&shy;ней&shy;шая.</p>
<div class="paragraph-right-side">46</div>
</div>
<p>Давайте расс&shy;мот&shy;рим ещё один при&shy;мер:</p>
<div class="paragraph-container">
<div class="paragraph-left-side">47</div>
<p><strong>Класс Number&shy;.Formatting::Format&shy;Decimal</strong>
<a href="https://github.com/dotnet/coreclr/blob/efebb38f3c18425c57f94ff910a50e038d13c848/src/mscorlib/shared/System/Number.Formatting.cs#L287-L311">/src/mscorlib/shared/System&shy;/Number&shy;.Formatting&shy;.cs</a></p>
<div class="paragraph-right-side">47</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">public</span> <span style="color:Blue;">static</span> <span style="color:Blue;">string</span> FormatDecimal(<span style="color:Blue;">decimal</span> value, ReadOnlySpan&lt;<span style="color:Blue;">char</span>&gt; format, NumberFormatInfo info)
{
    <span style="color:Blue;">char</span> fmt = ParseFormatSpecifier(format, <span style="color:Blue;">out</span> <span style="color:Blue;">int</span> digits);

    NumberBuffer number = <span style="color:Blue;">default</span>;
    DecimalToNumber(value, <span style="color:Blue;">ref</span> number);

    ValueStringBuilder sb;
    <span style="color:Blue;">unsafe</span>
    {
        <span style="color:Blue;">char</span>* stackPtr = <span style="color:Blue;">stackalloc</span> <span style="color:Blue;">char</span>[CharStackBufferSize];
        sb = <span style="color:Blue;">new</span> ValueStringBuilder(<span style="color:Blue;">new</span> Span&lt;<span style="color:Blue;">char</span>&gt;(stackPtr, CharStackBufferSize));
    }

    <span style="color:Blue;">if</span> (fmt != 0)
    {
        NumberToString(<span style="color:Blue;">ref</span> sb, <span style="color:Blue;">ref</span> number, fmt, digits, info, isDecimal:<span style="color:Blue;">true</span>);
    }
    <span style="color:Blue;">else</span>
    {
        NumberToStringFormat(<span style="color:Blue;">ref</span> sb, <span style="color:Blue;">ref</span> number, format, info);
    }

    <span style="color:Blue;">return</span> sb.ToString();
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">48</div>
<p>Это  &mdash;  при&shy;мер фор&shy;ма&shy;ти&shy;ро&shy;ва&shy;ния чисел, опи&shy;ра&shy;ющийся на ещё более инте&shy;рес&shy;ный при&shy;мер класса <a href="https://github.com/dotnet/coreclr/blob/efebb38f3c18425c57f94ff910a50e038d13c848/src/mscorlib/shared/System/Text/ValueStringBuilder.cs">Value&shy;String&shy;Builder</a>, рабо&shy;та&shy;ю&shy;щий на основе <code>Span&shy;<T></code>. Суть дан&shy;ного учас&shy;тка кода в том, что для того чтобы соб&shy;рать текс&shy;то&shy;вое предс&shy;тав&shy;ле&shy;ние фор&shy;ма&shy;ти&shy;ро&shy;ван&shy;ного числа мак&shy;си&shy;мально быс&shy;тро, код не исполь&shy;зует выде&shy;ле&shy;ния памяти под буфер накоп&shy;ле&shy;ния сим&shy;во&shy;лов. Этот прек&shy;рас&shy;ный код выде&shy;ляет память прямо в сте&shy;ко&shy;вом кадре метода, обес&shy;пе&shy;чи&shy;вая тем самым отс&shy;утствие работы сбор&shy;щика мусора по экземп&shy;ля&shy;рам String&shy;Builder&shy;, если бы метод рабо&shy;тал на его основе. Плюс умень&shy;ша&shy;ется время работы самого метода: выде&shy;ле&shy;ние памяти в куче тоже время зани&shy;мает. А исполь&shy;зо&shy;ва&shy;ние типа <code>Span&shy;<T></code> вместо голых ука&shy;за&shy;те&shy;лей вно&shy;сит чувство безо&shy;пас&shy;ности в работу кода, осно&shy;ван&shy;ного на stac&shy;kalloc.</p>
<div class="paragraph-right-side">48</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">49</div>
<p>Также, перед тем как перейти к выво&shy;дам, стоит упо&shy;мя&shy;нуть, как делать нельзя. Дру&shy;гими сло&shy;вами, какой код может рабо&shy;тать хорошо, но в один прек&shy;рас&shy;ный момент выст&shy;ре&shy;лит в самый не под&shy;хо&shy;дя&shy;щий момент. Опять же, расс&shy;мот&shy;рим при&shy;мер:</p>
<div class="paragraph-right-side">49</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> GenerateNoise(<span style="color:Blue;">int</span> noiseLength)
{
    <span style="color:Blue;">var</span> buf = <span style="color:Blue;">new</span> Span(<span style="color:Blue;">stackalloc</span> <span style="color:Blue;">int</span>[noiseLength]);
    <span style="color:Green;">// generate noise</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">50</div>
<p>Код мал да удал: нельзя вот так брать и пере&shy;да&shy;вать раз&shy;мер для выде&shy;ле&shy;ния памяти на стеке извне. Если вам так нужен задан&shy;ный сна&shy;ружи раз&shy;мер, при&shy;мите сам буфер:</p>
<div class="paragraph-right-side">50</div>
</div>
<div class="lang-csharp editor-colors"><div style="color:Black;background-color:White;"><pre>
<span style="color:Blue;">void</span> GenerateNoise(Span&lt;<span style="color:Blue;">int</span>&gt; noiseBuf)
{
    <span style="color:Green;">// generate noise</span>
}
</pre></div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">51</div>
<p>Этот код гораздо инфор&shy;ма&shy;тив&shy;нее, т.к. зас&shy;тав&shy;ляет поль&shy;зо&shy;ва&shy;теля заду&shy;маться и быть акку&shy;рат&shy;ным при выборе чисел. Пер&shy;вый вари&shy;ант при неудачно сло&shy;жив&shy;шихся обсто&shy;я&shy;т&shy;ельствах может выб&shy;ро&shy;сить <code>Stack&shy;Overflow&shy;Exception</code> при дос&shy;та&shy;точно нег&shy;лу&shy;бо&shy;ком поло&shy;же&shy;нии метода в стеке потока: дос&shy;та&shy;точно пере&shy;дать боль&shy;шое число в качес&shy;тве пара&shy;метра. Вто&shy;рой вари&shy;ант, когда раз&shy;мер при&shy;ни&shy;мать всё-таки можно  &mdash;  это когда этот метод вызы&shy;ва&shy;ется в конк&shy;рет&shy;ных слу&shy;чаях и при этом вызы&shy;ва&shy;ю&shy;щий код &laquo;знает&raquo; алго&shy;ритм работы этого метода. Без зна&shy;ния о внут&shy;рен&shy;нем устрой&shy;стве метода нет конк&shy;рет&shy;ного пони&shy;ма&shy;ния воз&shy;мож&shy;ного диа&shy;па&shy;зона для noi&shy;se&shy;Length и как след&shy;с&shy;твие  &mdash;  воз&shy;можны ошибки</p>
<div class="paragraph-right-side">51</div>
</div>
<div class="paragraph-container">
<div class="paragraph-left-side">52</div>
<p>Вто&shy;рая проб&shy;лема, кото&shy;рую я вижу: если нам слу&shy;чай&shy;ным обра&shy;зом не уда&shy;лось попасть в раз&shy;мер того буфера, кото&shy;рый мы сами себе выде&shy;лили на стеке, а терять рабо&shy;тос&shy;по&shy;соб&shy;ность мы не хотим, то, конечно, можно пойти нес&shy;коль&shy;кими путями: либо довы&shy;де&shy;лить памяти, опять же на стеке, либо выде&shy;лить её в куче. Причём, ско&shy;рее всего вто&shy;рой вари&shy;ант в боль&shy;шинстве слу&shy;чаев ока&shy;жется более пред&shy;поч&shy;ти&shy;тель&shy;ным (так и пос&shy;ту&shy;пили в слу&shy;чае <code>Value&shy;String&shy;Buffer</code>), т.к. более безо&shy;па&shy;сен с точки зре&shy;ния полу&shy;че&shy;ния <code>Stack&shy;Overflow&shy;Exception</code>.</p>
<div class="paragraph-right-side">52</div>
</div>
<h2 id="stackalloc-1">Выводы к stac&shy;kalloc</h2>
<p>Итак, для чего же лучше всего исполь&shy;зо&shy;вать <code>stac&shy;kalloc</code>?</p>
<ul>
<li><p>Для работы с неуп&shy;рав&shy;ля&shy;е&shy;мым кодом, когда необ&shy;хо&shy;димо запол&shy;нить неуп&shy;рав&shy;ля&shy;е&shy;мым мето&shy;дом неко&shy;то&shy;рый буфер дан&shy;ных или же при&shy;нять от неуп&shy;рав&shy;ля&shy;е&shy;мого метода некий буфер дан&shy;ных, кото&shy;рый будет исполь&shy;зо&shy;ваться в рам&shy;ках жизни тела метода;</p>
</li>
<li><p>Для мето&shy;дов, кото&shy;рым нужен мас&shy;сив, но опять же на время работы самого метода. При&shy;мер с фор&shy;ма&shy;ти&shy;ро&shy;ва&shy;нием очень хоро&shy;ший: этот метод может вызы&shy;ваться слиш&shy;ком часто чтобы он выде&shy;лял вре&shy;мен&shy;ные мас&shy;сивы в куче;</p>
</li>
</ul>
<div class="paragraph-container">
<div class="paragraph-left-side">53</div>
<p>Испол&shy;ьз&shy;ов&shy;ание дан&shy;ного алло&shy;ка&shy;тора может сильно повы&shy;сить про&shy;из&shy;во&shy;ди&shy;тель&shy;ность ваших при&shy;ло&shy;же&shy;ний.</p>
<div class="paragraph-right-side">53</div>
</div>
<h1 id="section-6">Выводы к раз&shy;делу</h1>
<div class="paragraph-container">
<div class="paragraph-left-side">54</div>
<p>Конечно же, в общем виде нам нет надоб&shy;ности редак&shy;ти&shy;ро&shy;вать стек в про&shy;дук&shy;то&shy;вом коде: только если захо&shy;чется занять своё сво&shy;бод&shy;ное время инте&shy;рес&shy;ной задач&shy;кой. Однако пони&shy;ма&shy;ние его струк&shy;туры даёт нам види&shy;мость прос&shy;тоты задачи полу&shy;че&shy;ния дан&shy;ных из него и его редак&shy;ти&shy;ро&shy;ва&shy;ния. Т.е. если вы раз&shy;ра&shy;бо&shy;та&shy;ете API для рас&shy;ши&shy;ре&shy;ния фун&shy;кци&shy;о&shy;нала вашего при&shy;ло&shy;же&shy;ния и если это API не пре&shy;дос&shy;тав&shy;ляет дос&shy;тупа к каким-либо дан&shy;ным это не зна&shy;чит что эти дан&shy;ные невоз&shy;можно полу&shy;чить. Потому всегда про&shy;ве&shy;ряйте ваше при&shy;ло&shy;же&shy;ние на устой&shy;чи&shy;вость к взло&shy;мам.</p>
<div class="paragraph-right-side">54</div>
</div>

        </div>
        <footer>
            <div class="footer-container">
                <div class="footer-wrap">
                    <img src="../../res/img/logo-w-noindex.svg">
                    <p>
                        <a class="footer-link" target="_blank" href="mailto:sidristij@clrium.ru"><i class="far fa-envelope" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://vk.com/clrium"><i class="fab fa-vk" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://youtube.com/clrium"><i class="fab fa-youtube" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://github.com/clrium"><i class="fab fa-github" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="skype:stanislav.sidristyi"><i class="fab fa-skype" aria-hidden="true"></i></a>
                        <a class="footer-link" target="_blank" href="https://t.me/clrium_group"><i class="fab fa-telegram" aria-hidden="true"></i></a>
                    </p>
                </div>
            </div>
        </footer>
    </div>
</body>
</html>